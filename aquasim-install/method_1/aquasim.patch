diff -crBN ns-2.35/common/packet.h ns-2.35-aquasim/common/packet.h
*** ns-2.35/common/packet.h	2010-05-10 06:28:41.000000000 +0800
--- ns-2.35-aquasim/common/packet.h	2016-09-02 23:21:34.000000000 +0800
***************
*** 69,74 ****
--- 69,81 ----
  #define HDR_CDIFF(p)    (hdr_cdiff::access(p))  /* chalermak's diffusion*/
  //#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
  #define HDR_LMS(p)		(hdr_lms::access(p))
+ /* start aquasim */
+ #define HDR_UWVB(p)      (hdr_uwvb::access(p))      // added by peng xie
+ #define HDR_UWVBVA(p)    (hdr_uwvbva::access(p))      // added by peng xie
+ #define HDR_RMAC(p)      (hdr_rmac::access(p))  // added by Peng Xie
+ #define HDR_TMAC(p)      (hdr_tmac::access(p))  // added by Peng Xie
+ #define HDR_DBR(p)      (hdr_dbr::access(p))  /* hai's dbr */
+ /* end aquasim */
  
  /* --------------------------------------------------------------------*/
  
***************
*** 198,206 ****
  
          // M-DART packets
  static const packet_t PT_MDART = 72;
  	
          // insert new packet types here
! static packet_t       PT_NTYPE = 73; // This MUST be the LAST one
  
  enum packetClass
  {
--- 205,231 ----
  
          // M-DART packets
  static const packet_t PT_MDART = 72;
+ 
+ // add by norbert
+ static const packet_t PT_UWVB = 73;
+ static const packet_t PT_UWVBVA = 74;
+ static const packet_t PT_RMAC = 75;
+ static const packet_t PT_TMAC = 76;
+ static const packet_t PT_DBR = 77;
+ /*UWAN-MAC*/
+ static const packet_t PT_UWAN_SYNC = 78;
+ static const packet_t PT_UWAN_ML = 79;
+ static const packet_t PT_UWAN_HELLO = 80;
+ static const packet_t PT_OTMAN = 81; /*COPE-MAC*/
+ static const packet_t PT_FAMA = 82;  /*FAMA*/
+ static const packet_t PT_SFAMA = 83; /*Slotted FAMA*/
+ static const packet_t PT_UW_SROUTE = 84;  /*Static Routing for Underwater*/	
+ static const packet_t PT_UW_MESSAGE = 85; /*the packet generated by uw_sink agent*/
+ static const packet_t PT_UWALOHA = 86;
+ static const packet_t PT_UW_DROUTING = 87;
  	
          // insert new packet types here
! static packet_t       PT_NTYPE = 88; // This MUST be the LAST one
  
  enum packetClass
  {
***************
*** 416,422 ****
  		name_[PT_DCCP_CLOSE]="DCCP_Close";
  		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
  		name_[PT_DCCP_RESET]="DCCP_Reset";
! 
  		name_[PT_NTYPE]= "undefined";
  	}
  	static int addPacket(char *name);
--- 441,464 ----
  		name_[PT_DCCP_CLOSE]="DCCP_Close";
  		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
  		name_[PT_DCCP_RESET]="DCCP_Reset";
! 		//added by norbert
! 		name_[PT_UWVB]="vectorbasedforward";
! 		name_[PT_UWVBVA]="vectorbasedvoidavoidance";
! 		name_[PT_RMAC]="UnderwaterRmac";
! 		name_[PT_TMAC]="UnderwaterTmac";
!  		name_[PT_DBR]="dbr";
! 		//UWAN_MAC: donot include it in release version
! 		name_[PT_UWAN_SYNC] = "uwan-SYNC";
! 		name_[PT_UWAN_HELLO] = "uwan-hello";
! 		name_[PT_UWAN_ML] = "uwan-missinglist";
! 		name_[PT_OTMAN] = "OTMAN";
! 		name_[PT_FAMA] = "FAMA";
! 		name_[PT_SFAMA] ="Slotted-FAMA";
! 		name_[PT_UW_SROUTE] = "UW-StaticRouting";
! 		name_[PT_UW_MESSAGE] = "UW-Message";
! 		name_[PT_UWALOHA] = "UW-Aloha-ACK";
! 		name_[PT_UW_DROUTING]= "uw_drouting";
! 		
  		name_[PT_NTYPE]= "undefined";
  	}
  	static int addPacket(char *name);
***************
*** 610,615 ****
--- 652,661 ----
  	// source routing 
          char src_rt_valid;
  	double ts_arr_; // Required by Marker of JOBS 
+ 	bool	uw_flag_;	/*add by norbert,
+  				 to indicate this is a underwater packet
+  				so ll will not do arp resolve
+  				 */
  
  	//Monarch extn begins
  	nsaddr_t prev_hop_;     // IP addr of forwarding hop
***************
*** 665,671 ****
  	inline int& num_forwards() { return (num_forwards_); }
  	inline int& opt_num_forwards() { return (opt_num_forwards_); }
          //monarch_end
! 
  	ModulationScheme mod_scheme_;
  	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
  };
--- 711,718 ----
  	inline int& num_forwards() { return (num_forwards_); }
  	inline int& opt_num_forwards() { return (opt_num_forwards_); }
          //monarch_end
! 	//for underwater
! 	inline bool& uw_flag() { return uw_flag_; }
  	ModulationScheme mod_scheme_;
  	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
  };
***************
*** 710,715 ****
--- 757,763 ----
  	init(p); // Initialize bits_[]
  	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
  	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
+ 	(HDR_CMN(p))->uw_flag() = false; //by default, it will do arp resolve
  	p->fflag_ = TRUE;
  	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
  	/* setting all direction of pkts to be downward as default; 
diff -crBN ns-2.35/common/scheduler.cc ns-2.35-aquasim/common/scheduler.cc
*** ns-2.35/common/scheduler.cc	2009-01-01 11:42:13.000000000 +0800
--- ns-2.35-aquasim/common/scheduler.cc	2016-09-02 23:24:04.000000000 +0800
***************
*** 140,146 ****
  void
  Scheduler::dispatch(Event* p, double t)
  {
! 	if (t < clock_) {
  		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
  		abort();
  	}
--- 140,146 ----
  void
  Scheduler::dispatch(Event* p, double t)
  {
! 	/*if (t < clock_) {
  		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
  		abort();
  	}
***************
*** 148,153 ****
--- 148,171 ----
  	clock_ = t;
  	p->uid_ = -p->uid_;	// being dispatched
  	p->handler_->handle(p);	// dispatch
+ 	*/
+ 
+ 	if ((t < clock_) && (p->uid_ != 0)) {
+ 		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
+ 		printf("Current Event:\n");
+ 		printf("t:%f uid: ", p->time_);
+ 		printf(UID_PRINTF_FORMAT, p->uid_);
+ 		printf(" handler: %p\n", p->handler_);
+ 		dumpq();
+ 		abort();
+ 	}
+ 	if (p->uid_ != 0) { // will this kill the sim by not running a handler?
+  		clock_ = t;
+  		p->uid_ = -p->uid_;     // being dispatched
+  		p->handler_->handle(p); // dispatch
+  	} else {
+  		fprintf(stderr, "Warning: discarding Event without an a valid id\n");
+  	}
  }
  
  void
diff -crBN ns-2.35/linkstate/ls.h ns-2.35-aquasim/linkstate/ls.h
*** ns-2.35/linkstate/ls.h	2010-03-08 13:54:51.000000000 +0800
--- ns-2.35-aquasim/linkstate/ls.h	2016-09-02 23:13:08.000000000 +0800
***************
*** 134,140 ****
  		return ib.second ? ib.first : baseMap::end();
  	}
  
! 	void eraseAll() { erase(baseMap::begin(), baseMap::end()); }
  	T* findPtr(Key key) {
  		iterator it = baseMap::find(key);
  		return (it == baseMap::end()) ? (T *)NULL : &((*it).second);
--- 134,140 ----
  		return ib.second ? ib.first : baseMap::end();
  	}
  
! 	void eraseAll() { this->erase(baseMap::begin(), baseMap::end()); }
  	T* findPtr(Key key) {
  		iterator it = baseMap::find(key);
  		return (it == baseMap::end()) ? (T *)NULL : &((*it).second);
diff -crBN ns-2.35/mac/ll.cc ns-2.35-aquasim/mac/ll.cc
*** ns-2.35/mac/ll.cc	2010-03-08 13:54:51.000000000 +0800
--- ns-2.35-aquasim/mac/ll.cc	2016-09-02 23:25:38.000000000 +0800
***************
*** 199,208 ****
  			break;
  		}
  		/* Assuming arptable is present, send query */
! 		if (arptable_) {
  			tx = arptable_->arpresolve(dst, p, this);
  			break;
! 		}
  		//if (varp_) {
  		//tx = varp_->arpresolve(dst, p);
  		//break;
--- 199,211 ----
  			break;
  		}
  		/* Assuming arptable is present, send query */
! 		if (arptable_ && !ch->uw_flag()) {
  			tx = arptable_->arpresolve(dst, p, this);
  			break;
! 		} else {
!  			mac_->hdr_dst((char*)HDR_MAC(p), dst);
!  			break;
!  		}
  		//if (varp_) {
  		//tx = varp_->arpresolve(dst, p);
  		//break;
***************
*** 215,221 ****
  		int IPnh = (lanrouter_) ? lanrouter_->next_hop(p) : -1;
  		if (IPnh < 0)
  			mac_->hdr_dst((char*) HDR_MAC(p),macDA_);
! 		else if (varp_)
  			tx = varp_->arpresolve(IPnh, p);
  		else
  			mac_->hdr_dst((char*) HDR_MAC(p), IPnh);
--- 218,224 ----
  		int IPnh = (lanrouter_) ? lanrouter_->next_hop(p) : -1;
  		if (IPnh < 0)
  			mac_->hdr_dst((char*) HDR_MAC(p),macDA_);
! 		else if (varp_ && !ch->uw_flag())
  			tx = varp_->arpresolve(IPnh, p);
  		else
  			mac_->hdr_dst((char*) HDR_MAC(p), IPnh);
diff -crBN ns-2.35/Makefile.in ns-2.35-aquasim/Makefile.in
*** ns-2.35/Makefile.in	2011-10-24 00:29:54.000000000 +0800
--- ns-2.35-aquasim/Makefile.in	2016-09-02 23:27:21.000000000 +0800
***************
*** 333,338 ****
--- 333,365 ----
  	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
  	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
  	apps/pbc.o \
+     underwatersensor/uw_common/underwatersensornode.o \
+     underwatersensor/uw_common/uw_hash_table.o  \
+     underwatersensor/uw_common/uw_sink.o \
+     underwatersensor/uw_common/uw_sink_vbva.o  \
+     underwatersensor/uw_common/uw_poi_traffic.o \
+     underwatersensor/uw_routing/vectorbasedforward.o \
+     underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.o \
+     underwatersensor/uw_routing/uw_drouting/uw_drouting.o \
+     underwatersensor/uw_routing/uw_routing_buffer.o \
+     underwatersensor/uw_routing/vectorbasedvoidavoidance.o \
+     underwatersensor/uw_routing/static_routing/static_routing.o \
+     underwatersensor/uw_mac/underwaterpropagation.o  \
+     underwatersensor/uw_mac/underwaterchannel.o \
+     underwatersensor/uw_mac/underwaterphy.o  \
+     underwatersensor/uw_mac/underwatermac.o \
+     underwatersensor/uw_mac/broadcastmac.o \
+     underwatersensor/uw_mac/uwbuffer.o underwatersensor/uw_mac/rmac.o  \
+     underwatersensor/uw_mac/tmac.o \
+     underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.o underwatersensor/uw_mac/uwan-mac/uwan-mac.o \
+     underwatersensor/uw_mac/COPEMAC/copemac.o \
+     underwatersensor/uw_mac/FAMA/fama.o \
+     underwatersensor/uw_mac/slotted-fama/sfama.o \
+     underwatersensor/uw_mac/uwaloha/uwaloha.o \
+     underwatersensor/uw_mobility_pattern/uw_mobility_pattern.o \
+     underwatersensor/uw_mobility_pattern/uw_mobility_rwp.o \
+     underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.o \
+     dbr/dbr.o dbr/pkt_cache.o \
  	@V_STLOBJ@
  
  
***************
*** 524,529 ****
--- 551,557 ----
  	tcl/lib/ns-srcrt.tcl \
  	tcl/mcast/ns-lms.tcl \
  	tcl/lib/ns-qsnode.tcl \
+ 	tcl/lib/ns-underwatersensornode.tcl \
  	@V_NS_TCL_LIB_STL@
  
  $(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
diff -crBN ns-2.35/mobile/god.cc ns-2.35-aquasim/mobile/god.cc
*** ns-2.35/mobile/god.cc	2006-12-27 22:57:23.000000000 +0800
--- ns-2.35-aquasim/mobile/god.cc	2016-09-02 23:33:36.000000000 +0800
***************
*** 88,93 ****
--- 88,95 ----
  	num_send = 0;
  	active = false;
  	allowTostop = false;
+ 	// added by norbert
+ 	strcpy(f_name,"test.data");
  }
  
  
***************
*** 515,520 ****
--- 517,542 ----
  
  }
  
+ //added by  peng xie
+ double God::ConsumpedEnergy()
+ {
+ 	int i;
+ 	double sum=0.0;
+ 	FILE * fp;
+ 	if ((fp=fopen(f_name,"a"))==NULL){
+ 		printf("god can not open file\n");
+ 		return -1;
+ 	}
+ 	for (i=0; i<num_nodes; i++) {
+ 		if(!mb_node[i])printf("node pointer is null\n");
+ 		double s1=mb_node[i]->energy_model()->initialenergy();
+ 		double s2=mb_node[i]->energy_model()->energy();
+ 		sum=sum+(s1-s2);
+ 	}
+ 	fprintf(fp,"God : consumped_energy = %f\n", sum);
+ 	fclose(fp);
+ 	return sum;
+ }
  
  bool God::ExistSource()
  {
***************
*** 821,827 ****
  		  ComputeRoute();
  		  return TCL_OK;
  		}
! 
                  if(strcmp(argv[1], "dump") == 0) {
  		        Dump();
                          return TCL_OK;
--- 843,853 ----
  		  ComputeRoute();
  		  return TCL_OK;
  		}
! 		if(strcmp(argv[1], "compute_energy") == 0) {
! 			double s2=ConsumpedEnergy();
! 			printf("god: the energy consumped is %f\n",s2);
! 			return TCL_OK;
! 		}
                  if(strcmp(argv[1], "dump") == 0) {
  		        Dump();
                          return TCL_OK;
***************
*** 895,901 ****
  		  }
  		  return TCL_OK;
  	        }
! 
  	        if (strcasecmp(argv[1], "is_on_trees") == 0) {
  		  int node_id = atoi(argv[2]);
  
--- 921,932 ----
  		  }
  		  return TCL_OK;
  	        }
! 		if (strcasecmp(argv[1], "set_filename") == 0) {
! 			printf("GOD: the old file name is%s\n",f_name);
! 			strcpy(f_name,argv[2]);
! 			printf("GOD: the new file name is%s\n",f_name);
!  		  	return TCL_OK;
!  	        }
  	        if (strcasecmp(argv[1], "is_on_trees") == 0) {
  		  int node_id = atoi(argv[2]);
  
***************
*** 997,1002 ****
--- 1028,1044 ----
  
  	    return TCL_OK;
  	  }
+ 	 // added by Peng Xie to return the minimum num of hops between n1 and n2, -1 if there is no path between n1 and n2
+  	  if (strcasecmp(argv[1], "get_number_of_hop") == 0) {
+  			int n1 = atoi(argv[2]);
+  			int n2 = atoi(argv[3]);
+  		   	printf("ok, the n1=%d and n2=%d hop=%d\n",n1,n2,MIN_HOPS(n1,n2));
+  			if(MIN_HOPS(n1,n2)!=INFINITY) 
+  				tcl.resultf("%d",MIN_HOPS(n1,n2));
+  			else 
+  				tcl.resultf("%d",-1);
+  			return TCL_OK;
+  	  }
  
  
  	  // We can add source from tcl script or call AddSource directly.
diff -crBN ns-2.35/mobile/god.h ns-2.35-aquasim/mobile/god.h
*** ns-2.35/mobile/god.h	2006-02-21 23:20:19.000000000 +0800
--- ns-2.35-aquasim/mobile/god.h	2016-09-02 23:34:17.000000000 +0800
***************
*** 52,57 ****
--- 52,58 ----
  
  #include "node.h"
  #include "diffusion/hash_table.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
  
  
  // Added by Chalermek  12/1/99
***************
*** 154,160 ****
          int  *sink_table;
          int  *num_send;            // for each data type
          Data_Hash_Table dtab;
! 
          void DumpNodeStatus();
          void DumpNumSend();
          void CountNewData(int *attr);
--- 155,163 ----
          int  *sink_table;
          int  *num_send;            // for each data type
          Data_Hash_Table dtab;
!         
! 	char f_name[80];// added by peng xie to define the filename
! 	double ConsumpedEnergy(); // add by peng xie to compute energy consumped
          void DumpNodeStatus();
          void DumpNumSend();
          void CountNewData(int *attr);
diff -crBN ns-2.35/mobile/propagation.h ns-2.35-aquasim/mobile/propagation.h
*** ns-2.35/mobile/propagation.h	2005-02-04 04:15:00.000000000 +0800
--- ns-2.35-aquasim/mobile/propagation.h	2016-09-02 23:34:51.000000000 +0800
***************
*** 41,47 ****
  #define ns_propagation_h
  
  #define SPEED_OF_LIGHT	300000000		// 3 * 10^8 m/s
! #define PI		3.1415926535897
  
  
  #include <topography.h>
--- 41,49 ----
  #define ns_propagation_h
  
  #define SPEED_OF_LIGHT	300000000		// 3 * 10^8 m/s
! #ifndef PI
!  	#define PI		3.1415926535897
! #endif
  
  
  #include <topography.h>
diff -crBN ns-2.35/mobile/topography.cc ns-2.35-aquasim/mobile/topography.cc
*** ns-2.35/mobile/topography.cc	2003-12-24 01:36:34.000000000 +0800
--- ns-2.35-aquasim/mobile/topography.cc	2016-09-03 00:32:11.664000000 +0800
***************
*** 83,88 ****
--- 83,102 ----
  	return 0;
  }
  
+ //added by Peng Xie
+  
+ int
+ Topography::load_cubicgrid(int x, int y,int z, int res)
+ {
+  	/* No Reason to malloc a grid */
+  
+  	grid_resolution = res;	// default is 1 meter
+  	maxX = (double) x;
+  	maxY = (double) y;
+        maxZ = (double) z; 
+  	return 0;
+ }
+ 
  
  int
  Topography::load_demfile(const char *fname)
***************
*** 165,171 ****
  			if(load_flatgrid(atoi(argv[2]), atoi(argv[3]), atoi(argv[4])))
  				return TCL_ERROR;
  			return TCL_OK;
! 		}
! 	}
  	return TclObject::command(argc, argv);
  }
--- 179,195 ----
  			if(load_flatgrid(atoi(argv[2]), atoi(argv[3]), atoi(argv[4])))
  				return TCL_ERROR;
  			return TCL_OK;
! 		} else if(strcmp(argv[1], "load_cubicgrid") == 0) {
!  			if(load_cubicgrid(atoi(argv[2]), atoi(argv[3]),atoi(argv[4])))
!  				return TCL_ERROR;
!  			return TCL_OK;
!  		}
!  	} else if(argc == 6) {
!  		if(strcmp(argv[1], "load_cubicgrid") == 0) {
!  			if(load_cubicgrid(atoi(argv[2]), atoi(argv[3]), atoi(argv[4]),atoi(argv[5])))
!  		      	return TCL_ERROR;
!  			return TCL_OK;
!  		}
!   	}
  	return TclObject::command(argc, argv);
  }
diff -crBN ns-2.35/mobile/topography.h ns-2.35-aquasim/mobile/topography.h
*** ns-2.35/mobile/topography.h	2003-12-24 01:36:34.000000000 +0800
--- ns-2.35-aquasim/mobile/topography.h	2016-09-02 23:38:05.000000000 +0800
***************
*** 46,52 ****
  class Topography : public TclObject {
  
  public:
! 	Topography() { maxX = maxY = grid_resolution = 0.0; grid = 0; }
  
  	/* List-keeper */
  	void updateNodesList(class MobileNode *mn, double oldX);
--- 46,52 ----
  class Topography : public TclObject {
  
  public:
! 	Topography() { maxX = maxY = maxZ = grid_resolution = 0.0; grid = 0; }
  
  	/* List-keeper */
  	void updateNodesList(class MobileNode *mn, double oldX);
***************
*** 55,70 ****
--- 55,74 ----
  	double	upperX() { return maxX * grid_resolution; }
  	double	lowerY() { return 0.0; }
  	double	upperY() { return maxY * grid_resolution; }
+  	double	lowerZ() { return 0.0; }
+  	double	upperZ() { return maxZ * grid_resolution; }
  	double	resol() { return grid_resolution; }
  	double	height(double x, double y);
  
  private:
  	virtual int command(int argc, const char*const* argv);
  	int	load_flatgrid(int x, int y, int res = 1);
+ 	int	load_cubicgrid(int x, int y, int z,int res = 1);
  	int	load_demfile(const char *fname);
  
  	double	maxX;
  	double	maxY;
+ 	double  maxZ;// added by Peng Xie
  
  	double	grid_resolution;
  	int*	grid;
diff -crBN ns-2.35/tcl/lib/ns-agent.tcl ns-2.35-aquasim/tcl/lib/ns-agent.tcl
*** ns-2.35/tcl/lib/ns-agent.tcl	2009-01-15 14:23:49.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-agent.tcl	2016-09-02 23:41:45.000000000 +0800
***************
*** 137,142 ****
--- 137,204 ----
  	$self ctrl-target [$tbf target]
  }
  
+ #add by Peng Xie
+  
+ Agent/UWSink instproc attach-vectorbasedforward {w1} {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   $rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   $rt set width $w1
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   #set demux [$node_ demux_]
+   #puts " [$entrance defaulttarget]"
+   #$rt  name
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+  
+ Agent/UWSink instproc attach-uwflooding { } {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   $rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+  
+ Agent/UWSink instproc attach-routing { } {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   #$rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+  
+ Agent/UW_VBVA_Sink instproc attach-routing { } {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   $rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+ 
  #
  # A lot of agents want to store the maxttl locally.  However,
  # setting a class variable based on the Agent::ttl_ variable
diff -crBN ns-2.35/tcl/lib/ns-default.tcl ns-2.35-aquasim/tcl/lib/ns-default.tcl
*** ns-2.35/tcl/lib/ns-default.tcl	2010-07-04 06:45:45.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-default.tcl	2016-09-02 23:45:43.000000000 +0800
***************
*** 558,564 ****
  Node/MobileNode set Y_				0
  Node/MobileNode set Z_				0
  Node/MobileNode set speed_				0
! Node/MobileNode set position_update_interval_	0
  Node/MobileNode set bandwidth_			0	;# not used
  Node/MobileNode set delay_				0	;# not used
  Node/MobileNode set REGAGENT_PORT 0
--- 558,564 ----
  Node/MobileNode set Y_				0
  Node/MobileNode set Z_				0
  Node/MobileNode set speed_				0
! Node/MobileNode set position_update_interval_	1.0
  Node/MobileNode set bandwidth_			0	;# not used
  Node/MobileNode set delay_				0	;# not used
  Node/MobileNode set REGAGENT_PORT 0
***************
*** 1590,1592 ****
--- 1590,1689 ----
  
  Agent/MDART set macFailed_ true
  Agent/MDART set etxMetric_ true
+ 
+ Application/Traffic/UW_POI set maxpkts_ -1 ;# infinity
+ Application/Traffic/UW_POI set data_rate_ -1 ;# for checking error purpose
+ Application/Traffic/UW_POI set packetSize_ -1 ;# same as data_rate
+ # The following is added by Peng Xie
+ Node/MobileNode/UnderwaterSensorNode set  sinkStatus_ 0 
+ Node/MobileNode/UnderwaterSensorNode  set max_speed   0  
+ Node/MobileNode/UnderwaterSensorNode set min_speed    0  
+ Node/MobileNode/UnderwaterSensorNode set position_update_interval_  1.0 
+ Node/MobileNode/UnderwaterSensorNode set max_thought_time_ 3.0
+ 
+ #added by Peng Xie
+ Mac/UnderwaterMac/BroadcastMac set packetheader_size_ 8 ;# 40 bytes
+ Mac/UnderwaterMac/BroadcastMac set packet_size_ 0 ;# 
+ Mac/UnderwaterMac/RMac set PhaseOne_window_  3 ;# 2 second
+ Mac/UnderwaterMac/RMac set ND_window_  1 ;# 1 second
+ Mac/UnderwaterMac/RMac set ACKND_window_  1.5 ;# 1.5 second
+ Mac/UnderwaterMac/RMac set PhyOverhead_  8 ;# 8 bits 
+ Mac/UnderwaterMac/RMac set PhyOne_cycle_  1 ;# 8 bits 
+ Mac/UnderwaterMac/RMac set large_packet_size_  80   ;# 10 bytes 
+ Mac/UnderwaterMac/RMac set short_packet_size_  480  ;# 60 bytes
+ Mac/UnderwaterMac/RMac set IntervalPhase2Phase3 1  ;# 60 bytes
+ Mac/UnderwaterMac/RMac set PhaseTwo_window_  1
+ Mac/UnderwaterMac/RMac set duration_  0.1
+ Mac/UnderwaterMac/RMac set PeriodInterval_  1
+ Mac/UnderwaterMac/RMac set SIF_  0.00001
+ Mac/UnderwaterMac/RMac set ACKRevInterval_  0.08  
+ Mac/UnderwaterMac/TMac set PhaseOne_window_  3 ;# 2 second
+ Mac/UnderwaterMac/TMac set ND_window_  1 ;# 1 second
+ Mac/UnderwaterMac/TMac set ACKND_window_  1.5 ;# 1.5 second
+ Mac/UnderwaterMac/TMac set PhyOverhead_  8 ;# 8 bits 
+ Mac/UnderwaterMac/TMac set PhyOne_cycle_  1 ;# 8 bits 
+ Mac/UnderwaterMac/TMac set large_packet_size_  80   ;# 10 bytes 
+ Mac/UnderwaterMac/TMac set short_packet_size_  480  ;# 60 bytes
+ Mac/UnderwaterMac/TMac set IntervalPhase2Phase3 1  ;# 60 bytes
+ Mac/UnderwaterMac/TMac set PhaseTwo_window_  1
+ Mac/UnderwaterMac/TMac set duration_  0.1
+ Mac/UnderwaterMac/TMac set PeriodInterval_  1
+ Mac/UnderwaterMac/TMac set SIF_  0.00001
+ #Mac/UnderwaterMac/TMac set ACKRevInterval_  0.08  
+ Mac/UnderwaterMac/TMac set transmission_time_error_  0.001
+ Mac/UnderwaterMac/TMac set ContentionWindow_  0.1
+ Mac/UnderwaterMac/TMac set TransmissionRange_ 90
+ Mac/UnderwaterMac/UWANMac set AvgCyclePeriod 10
+ Mac/UnderwaterMac/UWANMac set StdCyclePeriod 1
+ Mac/UnderwaterMac/OTMAN set NDInterval 3
+ Mac/UnderwaterMac/OTMAN set DataAccuPeriod 1
+ Mac/UnderwaterMac/OTMAN set RevAckAccumTime 1
+ Mac/UnderwaterMac/OTMAN set DataAckAccumTime 1
+ Mac/UnderwaterMac/OTMAN set MajorBackupInterval 0.5
+ Mac/UnderwaterMac/OTMAN set MajorIntervalLB 2
+ Mac/UnderwaterMac/OTMAN set MajorIntervalUB 3
+ Mac/UnderwaterMac/OTMAN set GuardTime 0.01
+ Mac/UnderwaterMac/OTMAN set isParallel 1
+ 
+ Mac/UnderwaterMac/FAMA set MaxBurst 1
+ 
+ #Mac/UnderwaterMac/SFAMA set max_burst_ 1
+ #Mac/UnderwaterMac/SFAMA set guard_time_ 0.00001
+ #Mac/UnderwaterMac/SFAMA set max_backoff_slots_ 4
+ 
+ #added by peng xie
+ Phy/UnderwaterPhy set CPThresh_ 10.0
+ Phy/UnderwaterPhy set CSThresh_ 1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 3.652e-10
+ #Phy/UnderwaterPhy set bandwidth_ 2e6
+ Phy/UnderwaterPhy set Pt_ 0.28183815
+ Phy/UnderwaterPhy set freq_ 914e+6
+ Phy/UnderwaterPhy set L_ 1.0  
+ Phy/UnderwaterPhy set debug_ false
+ Phy/UnderwaterPhy set K_ 1.5
+ Phy/UnderwaterPhy set TurnOnEnergy 0.0
+ Phy/UnderwaterPhy set TurnOffEnergy 0.0
+ Phy/UnderwaterPhy set sync_hdr_len  0.0
+ Phy/UnderwaterPhy set fowarding_delay 0.0
+ Phy/UnderwaterPhy set bit_error_rate 0.0
+ 
+ #added by Peng Xie 
+ Agent/UWSink set data_rate_ 1.0 
+ Agent/UWSink set packetsize_ 50 ;#bytes
+ Agent/UWSink set random_ 0 
+ Agent/UWSink set passive 0 
+ Agent/UWSink set ActiveSense 0
+ Agent/UWSink set SenseInterval 30
+ #Agent/UWSink set activate_vbf  1
+ Agent/UW_VBVA_Sink set data_rate_ 1.0 
+ Agent/UW_VBVA_Sink set packetsize_ 50 ;#bytes
+ Agent/UW_VBVA_Sink set random_ 0 
+ Agent/UW_VBVA_Sink set passive 0 
+ Agent/Vectorbasedforward set width 100
+ Agent/Vectorbasedforward set control_packet_size 20
+ Agent/Vectorbasedforward set hop_by_hop_ 0
+ Agent/Vectorbasedforward set EnableRouting 1 
+ Agent/VectorbasedVoidAvoidance set width 100
+ Agent/VectorbasedVoidAvoidance set  control_packet_size 20  
+ Agent/uw_drouting set accessible_var_ true
+ 
diff -crBN ns-2.35/tcl/lib/ns-lib.tcl ns-2.35-aquasim/tcl/lib/ns-lib.tcl
*** ns-2.35/tcl/lib/ns-lib.tcl	2010-05-10 06:28:41.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-lib.tcl	2016-09-03 01:00:47.056000000 +0800
***************
*** 137,142 ****
--- 137,143 ----
  source ns-rtmodule.tcl
  source ns-hiernode.tcl
  source ns-mobilenode.tcl
+ source ns-underwatersensornode.tcl
  source ns-bsnode.tcl
  source ns-link.tcl
  source ns-source.tcl
***************
*** 624,629 ****
--- 625,633 ----
  		    DSDV {
  			    set ragent [$self create-dsdv-agent $node]
  		    }
+ 		    SillyRouting {
+ 			    set ragent [$self create-sillyrouting-agent $node]
+ 		    }
  		    DSR {
  			    $self at 0.0 "$node start-dsr"
  		    }
***************
*** 643,648 ****
--- 647,670 ----
  			    Simulator set IMEPFlag_ ON
  			    set ragent [$self create-tora-agent $node]
  		    }
+ 		    StaticRouting {
+ 			    set ragent [$self creat-staticrouting-agent $node] 
+ 		    }
+ 		    DBR { 
+ 		   	    set ragent [$self create-dbr-agent $node]
+ 	   	    }
+ 		    Vectorbasedforward {
+ 			set ragent [$self create-vectorbasedforward-agent $node]
+ 		    }
+ 	    	    VectorbasedVoidAvoidance {
+ 			set ragent [$self create-vectorbasedvoidavoidance-agent $node]
+ 		    }
+ 		    UWFlooding {
+ 			set ragent [$self create-uwflooding-agent $node]
+ 		    }
+ 		    uw_drouting {
+ 			set ragent [$self create-uw_drouting-agent $node]             
+ 		    }
  		    DIFFUSION/RATE {
  			    eval $node addr $args
  			    set ragent [$self create-diffusion-rate-agent $node]
***************
*** 703,709 ****
              $routingAgent_ == "DIFFUSION/PROB" ||
              $routingAgent_ == "FLOODING" ||
              $routingAgent_ == "OMNIMCAST" ||
! 	    $routingAgent_ == "Directed_Diffusion" } {
  		$ragent port-dmux [$node demux]
  		$node instvar ll_
  		$ragent add-ll $ll_(0)
--- 725,736 ----
              $routingAgent_ == "DIFFUSION/PROB" ||
              $routingAgent_ == "FLOODING" ||
              $routingAgent_ == "OMNIMCAST" ||
! 	    $routingAgent_ == "Directed_Diffusion" ||
! 	    $routingAgent_ == "DBR"|| 
! 	    $routingAgent_ == "Vectorbasedforward"||
! 	    $routingAgent_ == "VectorbasedVoidAvoidance"||
! 	    $routingAgent_ == "UWFlooding" ||
! 	    $routingAgent_ == "StaticRouting" } {
  		$ragent port-dmux [$node demux]
  		$node instvar ll_
  		$ragent add-ll $ll_(0)
***************
*** 776,787 ****
  }
  
  Simulator instproc create-node-instance args {
! 	$self instvar routingAgent_
  	# DSR is a special case
  	if {$routingAgent_ == "DSR"} {
  		set nodeclass [$self set-dsr-nodetype]
  	} else {
! 		set nodeclass Node/MobileNode
  	}
  	return [eval new $nodeclass $args]
  }
--- 803,821 ----
  }
  
  Simulator instproc create-node-instance args {
! 	$self instvar routingAgent_ propType_
  	# DSR is a special case
  	if {$routingAgent_ == "DSR"} {
  		set nodeclass [$self set-dsr-nodetype]
  	} else {
! 		#added by Peng Xie to create underwater sensor node 
! 		if {$propType_ == "Propagation/UnderwaterPropagation"} {
! 			# puts "propagation type is $propType_"
! 			set nodeclass Node/MobileNode/UnderwaterSensorNode
! 			# puts "after create the underwatersensor node..."
! 		} else { 
! 			set nodeclass Node/MobileNode
! 		}
  	}
  	return [eval new $nodeclass $args]
  }
***************
*** 824,829 ****
--- 858,934 ----
  }
  
  
+ Simulator instproc create-sillyrouting-agent { node } {
+ 	set ragent [new Agent/SillyRouting]
+ 	set addr [$node node-addr]
+ 	$ragent node $node
+ 	$ragent addr $addr
+ 
+ 	$node set ragent_ $ragent
+ 	return $ragent
+ }
+ 
+ # dbr @ hai
+ Simulator instproc create-dbr-agent { node } {
+ 	set ragent [new Agent/DBR]
+ 	$ragent node $node
+ 	$ragent start-dbr
+ 	$node set ragent_ $ragent
+ 	return $ragent
+ }
+ 
+ 
+ Simulator instproc creat-staticrouting-agent { node } {
+ 	set ragent [new Agent/StaticRouting]
+ 	set addr [$node node-addr]
+ 	$ragent node $node
+ 	$ragent addr $addr
+ 
+ 	$node set ragent_ $ragent
+ 	return $ragent
+ 
+ }
+ 
+ 
+ Simulator instproc create-vectorbasedforward-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/Vectorbasedforward]
+ 	# puts " I am in create vb before assign a ragent"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
+ Simulator instproc create-vectorbasedvoidavoidance-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/VectorbasedVoidAvoidance]
+ 	# puts " I am in create vb before assign a ragent"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
+ 
+ 
+ Simulator instproc create-uwflooding-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/UWFlooding]
+ 	# puts " I am in create vb before assign a ragent"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
+ Simulator instproc create-uw_drouting-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/uw_drouting [$node node-addr]]
+ 	# puts " I am in create vb before assign a ragent"
+        $self at 0.0 "$ragent start"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
  Simulator instproc create-dumb-agent { node } {
  	
  	# create a simple wireless agent
diff -crBN ns-2.35/tcl/lib/ns-packet.tcl ns-2.35-aquasim/tcl/lib/ns-packet.tcl
*** ns-2.35/tcl/lib/ns-packet.tcl	2011-10-15 06:11:08.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-packet.tcl	2016-09-02 23:54:49.000000000 +0800
***************
*** 176,181 ****
--- 176,191 ----
          MIP 	# Mobile IP, mobile/mip-reg.cc
  	Smac 	# Sensor-MAC
  	TORA 	# routing protocol for ad-hoc networks
+ 	UWVB      #underwatersensor
+ 	UWVBVA
+         uw_drouting
+ 	RMAC     
+ 	TMAC
+     	SFAMA
+ 	StaticRouting
+ 	UWANMac
+ 	OTMAN
+ 	UW_ALOHA
  	MDART 	# routing protocol for ad-hoc networks
  	# AOMDV patch
  	AOMDV
diff -crBN ns-2.35/trace/cmu-trace.cc ns-2.35-aquasim/trace/cmu-trace.cc
*** ns-2.35/trace/cmu-trace.cc	2011-10-03 06:32:35.000000000 +0800
--- ns-2.35-aquasim/trace/cmu-trace.cc	2016-09-03 00:04:26.000000000 +0800
***************
*** 64,69 ****
--- 64,71 ----
  //</zheng: add for 802.15.4>
  
  #include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
+ #include "underwatersensor/uw_mac/underwaterchannel.h"
+ #include "underwatersensor/uw_mac/slotted-fama/sfama-pkt.h"
  
  
  PacketTracer::PacketTracer() : next_(0)
***************
*** 859,864 ****
--- 861,904 ----
  }
  
  void
+ CMUTrace::format_sfama(Packet* p, int offset)
+ {
+ 		hdr_SFAMA* SFAMAh = hdr_SFAMA::access(p);
+ 		
+ 		char packet_name[50];
+ 		
+ 		switch( SFAMAh->packet_type ) {
+ 		  case hdr_SFAMA::SFAMA_RTS:
+ 			strcpy(packet_name, "RTS");
+ 			break;
+ 		  case hdr_SFAMA::SFAMA_CTS:
+ 			strcpy(packet_name, "CTS");
+ 			break;
+ 		  case hdr_SFAMA::SFAMA_DATA:
+ 			strcpy(packet_name, "DATA");
+ 			break;
+ 		  case hdr_SFAMA::SFAMA_ACK:
+ 			strcpy(packet_name, "ACK");
+ 		  default:
+ 			break;
+ 		}
+ 		
+ 		if( pt_->tagged() ) {
+ 		   sprintf(pt_->buffer() + offset,
+ 			    "-SFAMA:n %s", packet_name);
+ 		  
+ 		} else if (newtrace_ ) {
+ 		  sprintf(pt_->buffer() + offset, 
+ 			"-P SFAMA -Pt %s", packet_name);
+ 		  
+ 		} else {
+ 		   sprintf(pt_->buffer() + offset, 
+ 			"[SFAMA %s]", packet_name);
+ 		  
+ 		}
+ }
+ 
+ void
  CMUTrace::format_aodv(Packet *p, int offset)
  {
          struct hdr_aodv *ah = HDR_AODV(p);
***************
*** 1191,1197 ****
  	//	return;
  
  	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
! 	char ptype[11];
  	strcpy(ptype,
  	((ch->ptype() == PT_MAC) ? (
  	  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
--- 1231,1237 ----
  	//	return;
  
  	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
! 	char ptype[50];
  	strcpy(ptype,
  	((ch->ptype() == PT_MAC) ? (
  	  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
***************
*** 1348,1396 ****
  	    }   
          }
  
! 	sprintf(pt_->nbuffer() ,
! 		"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
! 		op,
! 		Scheduler::instance().clock(),
! 		src_,                           // this node
! 		next_hop,
! 		ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
! 		ch->size(),
! 		pkt_color,
! 		ch->uid(),
! 		tracename);
  
! //<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
! if (Nam802_15_4::Nam_Status)
! {
! 	if ((strcmp(tracename, "AGT") != 0) || ((u_int32_t)(ih->daddr()) == IP_BROADCAST))		//<zheng: add: next_hop info not available at agent level>
  											//(doesn't really matter -- seems agent level has no effect on nam)
! 	if (next_hop == -1 && op == 'h') {
! 		// print extra fields for broadcast packets
  
! 		// bradius is calculated assuming 2-ray ground reflectlon
! 		// model using default settings of Phy/WirelessPhy and
! 		// Antenna/OmniAntenna
! 		if (bradius == 0.0) calculate_broadcast_parameters();
! 
! 		double radius = bradius*radius_scaling_factor_; 
! 
! 		// duration is calculated based on the radius and
! 		// the speed of light (299792458 m/s)
! 		double duration = (bradius/299792458.0)*duration_scaling_factor_;
! 		//<zheng: add -- the duration in 802.15.4 could be very small and rounded to 0.0>
! 		if (Nam802_15_4::Nam_Status)
! 		if (duration < 0.000000001)
! 			duration = 0.000000001;
! 		//</zheng: add>
! 		sprintf(pt_->nbuffer() + strlen(pt_->nbuffer()),
! 			" -R %.2f -D %.2f",
! 			radius,
! 			duration);
  	}
! }
! //</zheng>
  
  	offset = strlen(pt_->nbuffer());
  	pt_->namdump();
  }
--- 1388,1544 ----
  	    }   
          }
  
! 	if( op=='h' or op=='r' ) {
! 	
! 		sprintf(pt_->nbuffer() ,
! 			"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s -R %.6f",
! 			op,
! 			Scheduler::instance().clock(),
! 			src_,                           // this node
! 			next_hop,
! 			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
! 			ch->size(),
! 			pkt_color,
! 			ch->uid(),
! 			tracename,
! 			UnderwaterChannel::Transmit_distance()
! 			);
! 	}
! 	else {
! 		sprintf(pt_->nbuffer() ,
! 			"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
! 			op,
! 			Scheduler::instance().clock(),
! 			src_,                           // this node
! 			next_hop,
! 			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
! 			ch->size(),
! 			pkt_color,
! 			ch->uid(),
! 			tracename);
! 	}
  
! 	//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
! 	if (Nam802_15_4::Nam_Status)
! 	{
! 		if ((strcmp(tracename, "AGT") != 0) || ((u_int32_t)(ih->daddr()) == IP_BROADCAST))		//<zheng: add: next_hop info not available at agent level>
  											//(doesn't really matter -- seems agent level has no effect on nam)
! 		if (next_hop == -1 && op == 'h') {
! 			// print extra fields for broadcast packets
! 
! 			// bradius is calculated assuming 2-ray ground reflectlon
! 			// model using default settings of Phy/WirelessPhy and
! 			// Antenna/OmniAntenna
! 			if (bradius == 0.0) calculate_broadcast_parameters();
! 			
! 			double radius = bradius*radius_scaling_factor_; 
  
! 			// duration is calculated based on the radius and
! 			// the speed of light (299792458 m/s)
! 			double duration = (bradius/299792458.0)*duration_scaling_factor_;
! 			//<zheng: add -- the duration in 802.15.4 could be very small and rounded to 0.0>
! 			if (Nam802_15_4::Nam_Status)
! 				if (duration < 0.000000001)
! 					duration = 0.000000001;
! 			//</zheng: add>
! 			sprintf(pt_->nbuffer() + strlen(pt_->nbuffer()),
! 				" -R %.2f -D %.2f",
! 				radius,
! 				duration);
! 		}
  	}
! 	//</zheng>
! 	offset = strlen(pt_->nbuffer());
! 	pt_->namdump();
  
+ 	static int u_seq_id = 0;
+ 	u_seq_id++;
+ 	switch(op)
+ 	{
+ 		case 'h':
+ 			//forward packet
+ 			sprintf(pt_->nbuffer() ,
+ 				"v -t %.9f -e sim_annotation %.9f %d node %d sendout packet (%s) %d",
+ 				Scheduler::instance().clock(),
+ 				Scheduler::instance().clock(),
+ 				u_seq_id,
+ 				src_,
+ 				ptype,
+ 				ch->uid() );
+ 			/*
+ 			if( next_hop == -1 ) {
+ 				//broadcast packet
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d sendout packet %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					src_,
+ 					ch->uid() );
+ 				
+ 			}
+ 			else {
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d forward %s %d to %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					src_,
+ 					ptype,
+ 					ch->uid(),
+ 					next_hop );
+ 			}
+ 			*/
+ 			break;
+ 		case 'd':
+ 			//drop packet
+ 			sprintf(pt_->nbuffer() ,
+ 				"v -t %.9f -e sim_annotation %.9f %d node %d drop packet(%s) %d",
+ 				Scheduler::instance().clock(),
+ 				Scheduler::instance().clock(),
+ 				u_seq_id,
+ 				src_,                           // this node
+ 				ptype,
+ 				ch->uid());
+ 			break;
+ 		case 'r':
+ 			if( next_hop == -1 ) {
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d receive packet(%s) %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					node_->nodeid(),
+ 					ptype,
+ 					ch->uid() );
+ 				/*
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d receive broadcast %s %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					node_->nodeid(),
+ 					ptype,
+ 					ch->uid(),
+ 					);
+ 					*/
+ 			}
+ 			else {
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d receive %s %d from %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					next_hop,
+ 					ptype,
+ 					ch->uid(),
+ 					src_ );
+ 			}
+ 			break;
+ 
+ 		default:
+ 			break;
+ 	}
  	offset = strlen(pt_->nbuffer());
  	pt_->namdump();
  }
***************
*** 1456,1461 ****
--- 1604,1632 ----
  		case PT_GAF:
  		case PT_PING:
  			break;
+ 		case PT_DBR:
+ 			break;
+               	case PT_UW_DROUTING:
+ 			break;
+ 		case PT_UWVB:
+ 			break;
+         	case PT_UWVBVA:
+             		break;
+         	case PT_RMAC:
+ 			break; 
+         	case PT_TMAC:
+ 			break;
+ 		
+         	case PT_UWAN_SYNC:
+         	case PT_UWAN_HELLO:
+         	case PT_UWAN_ML:
+ 			break;
+         	case PT_OTMAN:
+ 			break;
+         	case PT_UW_SROUTE:
+             		break;
+         	case PT_SFAMA:
+ 			format_sfama(p, offset);
  		default:
  
  			if(pktTrc_ && pktTrc_->format_unknow(p, offset, pt_, newtrace_))
***************
*** 1586,1593 ****
  	bradius = pow(P_t*G_r*G_t*pow(h,4.0)/(P_r*L), 0.25);
  	//<zheng: add for 802.15.4>
  	//the above calculation is not accurate for short distance
! 	double PI,freq,lambda,crossover_dist;
! 	PI = 3.14159265359;
  	tcl.evalc("Phy/WirelessPhy set freq_");
  	freq = atof(tcl.result());
  	lambda = 3.0e8/freq;
--- 1757,1765 ----
  	bradius = pow(P_t*G_r*G_t*pow(h,4.0)/(P_r*L), 0.25);
  	//<zheng: add for 802.15.4>
  	//the above calculation is not accurate for short distance
! 	//double PI,freq,lambda,crossover_dist;
! 	//PI = 3.14159265359;
! 	double freq,lambda,crossover_dist;
  	tcl.evalc("Phy/WirelessPhy set freq_");
  	freq = atof(tcl.result());
  	lambda = 3.0e8/freq;
diff -crBN ns-2.35/trace/cmu-trace.h ns-2.35-aquasim/trace/cmu-trace.h
*** ns-2.35/trace/cmu-trace.h	2010-05-10 06:28:41.000000000 +0800
--- ns-2.35-aquasim/trace/cmu-trace.h	2016-09-03 00:04:59.000000000 +0800
***************
*** 161,167 ****
          void    format_aodv(Packet *p, int offset);
  	void    format_aomdv(Packet *p, int offset);
  	void    format_mdart(Packet *p, int offset);
! 
  	// This holds all the tracers added at run-time
  	static PacketTracer *pktTrc_;
  
--- 161,167 ----
          void    format_aodv(Packet *p, int offset);
  	void    format_aomdv(Packet *p, int offset);
  	void    format_mdart(Packet *p, int offset);
! 	void	format_sfama(Packet* p, int offset);
  	// This holds all the tracers added at run-time
  	static PacketTracer *pktTrc_;
  
