diff -crBN ns-2.35/common/packet.h ns-2.35-aquasim/common/packet.h
*** ns-2.35/common/packet.h	2010-05-10 06:28:41.000000000 +0800
--- ns-2.35-aquasim/common/packet.h	2016-09-02 23:21:34.000000000 +0800
***************
*** 69,74 ****
--- 69,81 ----
  #define HDR_CDIFF(p)    (hdr_cdiff::access(p))  /* chalermak's diffusion*/
  //#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
  #define HDR_LMS(p)		(hdr_lms::access(p))
+ /* start aquasim */
+ #define HDR_UWVB(p)      (hdr_uwvb::access(p))      // added by peng xie
+ #define HDR_UWVBVA(p)    (hdr_uwvbva::access(p))      // added by peng xie
+ #define HDR_RMAC(p)      (hdr_rmac::access(p))  // added by Peng Xie
+ #define HDR_TMAC(p)      (hdr_tmac::access(p))  // added by Peng Xie
+ #define HDR_DBR(p)      (hdr_dbr::access(p))  /* hai's dbr */
+ /* end aquasim */
  
  /* --------------------------------------------------------------------*/
  
***************
*** 198,206 ****
  
          // M-DART packets
  static const packet_t PT_MDART = 72;
  	
          // insert new packet types here
! static packet_t       PT_NTYPE = 73; // This MUST be the LAST one
  
  enum packetClass
  {
--- 205,231 ----
  
          // M-DART packets
  static const packet_t PT_MDART = 72;
+ 
+ // add by norbert
+ static const packet_t PT_UWVB = 73;
+ static const packet_t PT_UWVBVA = 74;
+ static const packet_t PT_RMAC = 75;
+ static const packet_t PT_TMAC = 76;
+ static const packet_t PT_DBR = 77;
+ /*UWAN-MAC*/
+ static const packet_t PT_UWAN_SYNC = 78;
+ static const packet_t PT_UWAN_ML = 79;
+ static const packet_t PT_UWAN_HELLO = 80;
+ static const packet_t PT_OTMAN = 81; /*COPE-MAC*/
+ static const packet_t PT_FAMA = 82;  /*FAMA*/
+ static const packet_t PT_SFAMA = 83; /*Slotted FAMA*/
+ static const packet_t PT_UW_SROUTE = 84;  /*Static Routing for Underwater*/	
+ static const packet_t PT_UW_MESSAGE = 85; /*the packet generated by uw_sink agent*/
+ static const packet_t PT_UWALOHA = 86;
+ static const packet_t PT_UW_DROUTING = 87;
  	
          // insert new packet types here
! static packet_t       PT_NTYPE = 88; // This MUST be the LAST one
  
  enum packetClass
  {
***************
*** 416,422 ****
  		name_[PT_DCCP_CLOSE]="DCCP_Close";
  		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
  		name_[PT_DCCP_RESET]="DCCP_Reset";
! 
  		name_[PT_NTYPE]= "undefined";
  	}
  	static int addPacket(char *name);
--- 441,464 ----
  		name_[PT_DCCP_CLOSE]="DCCP_Close";
  		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
  		name_[PT_DCCP_RESET]="DCCP_Reset";
! 		//added by norbert
! 		name_[PT_UWVB]="vectorbasedforward";
! 		name_[PT_UWVBVA]="vectorbasedvoidavoidance";
! 		name_[PT_RMAC]="UnderwaterRmac";
! 		name_[PT_TMAC]="UnderwaterTmac";
!  		name_[PT_DBR]="dbr";
! 		//UWAN_MAC: donot include it in release version
! 		name_[PT_UWAN_SYNC] = "uwan-SYNC";
! 		name_[PT_UWAN_HELLO] = "uwan-hello";
! 		name_[PT_UWAN_ML] = "uwan-missinglist";
! 		name_[PT_OTMAN] = "OTMAN";
! 		name_[PT_FAMA] = "FAMA";
! 		name_[PT_SFAMA] ="Slotted-FAMA";
! 		name_[PT_UW_SROUTE] = "UW-StaticRouting";
! 		name_[PT_UW_MESSAGE] = "UW-Message";
! 		name_[PT_UWALOHA] = "UW-Aloha-ACK";
! 		name_[PT_UW_DROUTING]= "uw_drouting";
! 		
  		name_[PT_NTYPE]= "undefined";
  	}
  	static int addPacket(char *name);
***************
*** 610,615 ****
--- 652,661 ----
  	// source routing 
          char src_rt_valid;
  	double ts_arr_; // Required by Marker of JOBS 
+ 	bool	uw_flag_;	/*add by norbert,
+  				 to indicate this is a underwater packet
+  				so ll will not do arp resolve
+  				 */
  
  	//Monarch extn begins
  	nsaddr_t prev_hop_;     // IP addr of forwarding hop
***************
*** 665,671 ****
  	inline int& num_forwards() { return (num_forwards_); }
  	inline int& opt_num_forwards() { return (opt_num_forwards_); }
          //monarch_end
! 
  	ModulationScheme mod_scheme_;
  	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
  };
--- 711,718 ----
  	inline int& num_forwards() { return (num_forwards_); }
  	inline int& opt_num_forwards() { return (opt_num_forwards_); }
          //monarch_end
! 	//for underwater
! 	inline bool& uw_flag() { return uw_flag_; }
  	ModulationScheme mod_scheme_;
  	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
  };
***************
*** 710,715 ****
--- 757,763 ----
  	init(p); // Initialize bits_[]
  	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
  	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
+ 	(HDR_CMN(p))->uw_flag() = false; //by default, it will do arp resolve
  	p->fflag_ = TRUE;
  	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
  	/* setting all direction of pkts to be downward as default; 
diff -crBN ns-2.35/common/scheduler.cc ns-2.35-aquasim/common/scheduler.cc
*** ns-2.35/common/scheduler.cc	2009-01-01 11:42:13.000000000 +0800
--- ns-2.35-aquasim/common/scheduler.cc	2016-09-02 23:24:04.000000000 +0800
***************
*** 140,146 ****
  void
  Scheduler::dispatch(Event* p, double t)
  {
! 	if (t < clock_) {
  		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
  		abort();
  	}
--- 140,146 ----
  void
  Scheduler::dispatch(Event* p, double t)
  {
! 	/*if (t < clock_) {
  		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
  		abort();
  	}
***************
*** 148,153 ****
--- 148,171 ----
  	clock_ = t;
  	p->uid_ = -p->uid_;	// being dispatched
  	p->handler_->handle(p);	// dispatch
+ 	*/
+ 
+ 	if ((t < clock_) && (p->uid_ != 0)) {
+ 		fprintf(stderr, "ns: scheduler going backwards in time from %f to %f.\n", clock_, t);
+ 		printf("Current Event:\n");
+ 		printf("t:%f uid: ", p->time_);
+ 		printf(UID_PRINTF_FORMAT, p->uid_);
+ 		printf(" handler: %p\n", p->handler_);
+ 		dumpq();
+ 		abort();
+ 	}
+ 	if (p->uid_ != 0) { // will this kill the sim by not running a handler?
+  		clock_ = t;
+  		p->uid_ = -p->uid_;     // being dispatched
+  		p->handler_->handle(p); // dispatch
+  	} else {
+  		fprintf(stderr, "Warning: discarding Event without an a valid id\n");
+  	}
  }
  
  void
diff -crBN ns-2.35/dbr/dbr.cc ns-2.35-aquasim/dbr/dbr.cc
*** ns-2.35/dbr/dbr.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/dbr/dbr.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,1417 ----
+ extern "C" {
+ #include <stdlib.h>
+ #include <stdio.h>
+ }
+ 
+ #include <object.h>
+ #include <agent.h>
+ #include <trace.h>
+ #include <packet.h>
+ #include <scheduler.h>
+ #include <random.h>
+ 
+ #include <mac.h>
+ #include <ll.h>
+ #include <cmu-trace.h>
+ 
+ #include "dbr.h"
+ 
+ #define	BEACON_RESCHED				\
+ 	beacon_timer_->resched(bint_ + 		\
+ 			Random::uniform(2*bdesync_*bint_) - \
+ 			bdesync_*bint_);
+ 
+ #define DEBUG_AGENT
+ //#define DEBUG_BEACON
+ #define DEBUG_PRINT
+ //#define DEBUG_BROADCASTING
+ 
+ // parameters to control the delay
+ #define	DBR_MAX_DELAY	0.2	// maximal propagation delay for one hop
+ #define DBR_MAX_RANGE	100	// maximal transmmition range
+ #define DBR_MIN_BACKOFF	0.0	// minimal backoff time for the packet
+ 
+ //#define USE_FLOODING_ALG	// test for pure flooding protocol
+ #define DBR_USE_ROUTEFLAG
+ #define DBR_MAX_HOPS	3
+ #define DBR_DEPTH_THRESHOLD 0.0
+ #define DBR_SCALE	1.0
+ 
+ int hdr_dbr::offset_;
+ 
+ /** 
+  * The communication class with TclObject
+  */
+ 
+ static class DBRAgentClass : public TclClass {
+ public:
+ 	DBRAgentClass() : TclClass("Agent/DBR") {}
+ 	TclObject* create(int, const char* const*) {
+ 		return (new DBR_Agent);
+ 	}
+ } class_DBRAgent;
+ 
+ class DBRHeaderClass : public PacketHeaderClass {
+ public:
+ 	DBRHeaderClass() : PacketHeaderClass("PacketHeader/DBR",
+ 					sizeof(hdr_dbr)) {
+ 		bind_offset(&hdr_dbr::offset_);
+ 	}
+ } class_dbrhdr;
+ 
+ void DBR_BeaconHandler::handle(Event *e)
+ {
+ 	a_->forwardPacket((Packet*)e, 0);
+ }
+ 
+ void DBR_BeaconTimer::expire(Event *e)
+ {
+ 	a_->beacon_callback();
+ }
+ 
+ void DBR_SendingTimer::expire(Event *e)
+ {
+ 	a_->send_callback();
+ }
+ 
+ /*
+ void DBR_DeadNeighbTimer::expire(Event *e)
+ {
+ 	a->deadneighb_callback(ne);
+ }
+ */
+ 
+ // Insert the item into queue.
+ // The queue is sorted by the expected sending time
+ // of the packet.
+ void MyPacketQueue::insert(QueueItem *q)
+ {
+ 	QueueItem *tmp;
+ 	deque<QueueItem*>::iterator iter;
+ 	
+ 	// find the insert point
+ 	iter = dq_.begin();
+ 	while (iter != dq_.end())
+ 	{
+ 		tmp = *iter;
+ 		if (tmp->send_time_ > q->send_time_)
+ 		{
+ 			dq_.insert(iter, q);
+ 			return;
+ 		}
+ 		iter++;
+ 	}
+ 
+ 	// insert at the end of the queue
+ 	dq_.push_back(q);
+ }
+ 
+ // Check if packet p in queue needs to be updated.
+ // If packet is not found, or previous sending time 
+ // is larger than current one, return TRUE.
+ // Otherwise return FALSE.
+ bool
+ MyPacketQueue::update(Packet *p, double t)
+ {
+ 	Packet *pkt;
+ 	int curID;
+ 	deque<QueueItem*>::iterator iter;
+ 	hdr_dbr *dbrh;
+ 
+ 	// get current packet ID
+ 	dbrh = hdr_dbr::access(p);
+ 	curID = dbrh->packetID();
+ 
+ 	// search the queue
+ 	iter = dq_.begin();
+ 	while (iter != dq_.end())
+ 	{
+ 		dbrh = hdr_dbr::access((*iter)->p_);
+ 		if (dbrh->packetID() == curID) 
+ 		{ // entry found
+ 			if ((*iter)->send_time_ > t)
+ 			{
+ 				dq_.erase(iter);
+ 				return TRUE;
+ 			}
+ 			else
+ 				return FALSE;
+ 		}
+ 	}
+ 
+ 	// not found
+ 	return TRUE;
+ }
+ 
+ // Find the item in queue which has the same packet ID
+ // as p, and remove it.
+ // If such a item is found, return true, otherwise
+ // return false.
+ bool
+ MyPacketQueue::purge(Packet *p)
+ {
+ 	Packet *pkt;
+ 	int curID;
+ 	deque<QueueItem*>::iterator iter;
+ 	hdr_dbr *dbrh; 
+ 
+ 	// get current packet ID
+ 	dbrh = hdr_dbr::access(p);
+ 	curID = dbrh->packetID();
+ 
+ 	// search the queue
+ 	iter = dq_.begin();
+ 	while (iter != dq_.end())
+ 	{
+ 		dbrh = hdr_dbr::access((*iter)->p_);
+ 		if (dbrh->packetID() == curID)
+ 		{
+ 			dq_.erase(iter);
+ 			return TRUE;
+ 		}
+ 		iter++;
+ 	}
+ 
+ 	return FALSE;
+ }
+ 
+ // Dump all the items in queue for debug
+ void MyPacketQueue::dump()
+ {
+ 	deque<QueueItem*>::iterator iter;
+ 	hdr_dbr *dbrh; 
+ 	int i = 0;
+ 
+ 	iter = dq_.begin();
+ 	while (iter != dq_.end())
+ 	{
+ 		dbrh = hdr_dbr::access((*iter)->p_);
+ 		fprintf(stderr, "Queue[%d]: packetID %d, send time %f\n",
+ 				i, dbrh->packetID(), (*iter)->send_time_);
+ 		iter++;
+ 		i++;
+ 	}
+ }
+ 
+ NeighbTable::NeighbTable(DBR_Agent *a)
+ {
+     int i;
+ 
+     num_ents = 0;
+     max_ents = 100;
+ 
+     // create the default table with size 100
+     tab = new NeighbEnt* [100];
+     a_ = a;
+ 
+     for (i = 0; i < 100; i++)
+         tab[i] = new NeighbEnt(a);
+ }
+ 
+ NeighbTable::~NeighbTable()
+ {
+     int i;
+ 
+     for (i = 0; i < max_ents; i++)
+         delete tab[i];
+ 
+     delete[] tab;
+ }
+ 
+ static int neighbEntCmp(const void *a, const void *b)
+ {
+ 	nsaddr_t ia = ((const NeighbEnt*)a)->net_id;
+ 	nsaddr_t ib = ((const NeighbEnt*)b)->net_id;
+ 
+ 	if (ia > ib) return 1;
+ 	if (ia < ib) return -1;
+ 	return 0;
+ }
+ 
+ void NeighbTable::dump(void)
+ {
+ 	int i;
+ 	
+ 	for (i = 0; i < num_ents; i++)
+ 		fprintf(stderr, "tab[%d]: %d x = %f, y = %f, z = %f\n",
+ 				i, tab[i]->net_id, 
+ 				tab[i]->x, tab[i]->y, tab[i]->z);
+ }
+ 
+ void
+ NeighbTable::ent_delete(const NeighbEnt *ne)
+ {
+ 	int l, r, m;
+ 	int i;
+ 	NeighbEnt *owslot;
+ 
+ 	// binary search
+ 	l = 0; r = num_ents - 1;
+ 	while (l <= r)
+ 	{
+ 		m = l + (r - l)/2;
+ 		if (tab[m]->net_id < ne->net_id)
+ 			l = m + 1;
+ 		else if (tab[m]->net_id > ne->net_id)
+ 			r = m - 1;
+ 		else
+ 			// m is the entry to be deleted
+ 			break;
+ 	}
+ 
+ 	if (l > r)
+ 		// no found!
+ 		return;
+ 
+ 	owslot = tab[m];
+ 
+ 	// slide the entries
+ 	i = m + 1;
+ 	while (i < num_ents)
+ 		tab[i - 1] = tab[i++];
+ 
+ 	tab[num_ents-1] = owslot;
+ 	num_ents--;
+ }
+ 
+ #if 0
+ /** 
+  * Add a neighbor entry ne into the table.
+  * The table is sorted by node address.
+  */
+ 
+ NeighbEnt* 
+ NeighbTable::ent_add(const NeighbEnt *ne)
+ {
+ 	int l, r, m;
+ 	int i;
+ 	NeighbEnt *owslot;
+ 
+ 	if (num_ents >= max_ents)
+ 	{
+ 		fprintf(stderr, "Neighbor table is full!\n");
+ 		return 0;
+ 	}
+ 
+ 	// binary search
+ 	l = 0; r = num_ents - 1;
+ 	while (l <= r)
+ 	{
+ 		m = l + (r - l)/2;
+ 		if (tab[m]->net_id < ne->net_id)
+ 			l = m + 1;
+ 		else if (tab[m]->net_id > ne->net_id)
+ 			r = m - 1;
+ 		else
+ 		{
+ 			// the entry is existing
+ 			// update the info
+ 			tab[m]->x = ne->x;
+ 			tab[m]->y = ne->y;
+ 			tab[m]->z = ne->z;
+ 
+ 			return tab[m];
+ 		}	
+ 	}
+ 
+ 	// the entry should go to l
+ 	owslot = tab[num_ents];
+ 
+ 	// slide the entries after l
+ 	i = num_ents - 1;
+ 	while (i >= l)
+ 		tab[i+1] = tab[i--];
+ 
+ 	tab[l] = owslot;
+ 	tab[l]->net_id = ne->net_id;
+ 	tab[l]->x = ne->x;
+ 	tab[l]->y = ne->y;
+ 	tab[l]->z = ne->z;
+ 	num_ents++;
+ 
+ 	return tab[l];
+ }
+ #else
+ NeighbEnt*
+ NeighbTable::ent_add(const NeighbEnt *ne)
+ {
+ 	NeighbEnt **pte;
+ 	NeighbEnt *pe;
+ 	int i, j;
+ 	int l, r, m;
+ 	
+ 	// find if the neighbor is already existing
+ 	for (i = 0; i < num_ents; i++)
+ 		if (tab[i]->net_id == ne->net_id)
+ 		{
+ 			tab[i]->x = ne->x;
+ 			tab[i]->y = ne->y;
+ 			tab[i]->z = ne->z;
+ 			
+ 			return tab[i];
+ 		}
+ 
+ 	/*
+ 	if (pte = (NeighbEnt**)bsearch(ne, tab, num_ents, 
+ 				sizeof(NeighbEnt *), neighbEntCmp))
+ 	{
+ 		(*pte)->net_id = ne->net_id;	// it doesn't hurt to rewrite it!
+ 		(*pte)->x = ne->x;
+ 		(*pte)->y = ne->y;
+ 		(*pte)->z = ne->z;
+ 
+ 		return (*pte);
+ 	}
+ 	*/
+ 
+ 	// need we increase the size of table
+ 	if (num_ents == max_ents)
+ 	{
+ 		NeighbEnt **tmp = tab;
+ 		max_ents *= 2;			// double the space
+ 		tab = new NeighbEnt* [max_ents];
+ 		bcopy(tmp, tab, num_ents*sizeof(NeighbEnt *));
+ 
+ 		for (i = num_ents; i < max_ents; i++)
+ 			tab[i] = new NeighbEnt(a_);
+ 
+ 		delete[] tmp;
+ 	}
+ 
+ 	// get the insert point
+ 	if (num_ents == 0)
+ 		i = 0;
+ 	else 
+ 	{
+ 		l = 0;
+ 		r = num_ents - 1;
+ 
+ 		while (r > l)
+ 		{
+ 			m = l + (r - l) / 2;
+ 			if (ne->net_id < tab[m]->net_id)
+ 				r = m - 1; 
+ 			else
+ 				l = m + 1;
+ 		}
+ 			
+ 		if (r < l)
+ 			i = r + 1;
+ 		else
+ 			if (ne->net_id < tab[r]->net_id)
+ 				i = r;
+ 			else
+ 				i = r + 1;
+ 	}
+ 	
+ 	// assign an unused slot to i
+ 	if (i <= (num_ents - 1))
+ 		pe = tab[num_ents];
+ 
+ 	// adjust the entries after insert point i
+ 	j = num_ents - 1;
+ 	while (j >= i)
+ 	{
+ 		tab[j+1] = tab[j];
+ 		j--;
+ 	}
+ 
+ 	if (i <= (num_ents - 1))
+ 		tab[i] = pe;
+ 	tab[i]->net_id = ne->net_id;
+ 	tab[i]->x = ne->x;
+ 	tab[i]->y = ne->y;
+ 	tab[i]->z = ne->z;
+ 	num_ents++;
+ 
+ 	return tab[i];
+ }
+ #endif	// 0
+ 
+ /*
+  * update the neighbor entry's routeFlag field with va
+  */
+ 
+ void NeighbTable::updateRouteFlag(nsaddr_t addr, int val)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < num_ents; i++)
+ 	{
+ 		if (tab[i]->net_id == addr)
+ 		{
+ 			tab[i]->routeFlag = val;
+ 			return;
+ 		}
+ 	}
+ }
+ 
+ #ifdef	DBR_USE_ROUTEFLAG
+ NeighbEnt *
+ NeighbTable::ent_find_shadowest(MobileNode *mn)
+ {
+ 	NeighbEnt *ne = 0;
+ 	int i;
+ 	double x, y, z, t;
+ 
+ 	mn->getLoc(&x, &y, &z);
+ 	t = z;
+ 
+ 	#ifdef DEBUG_AGENT
+ 	fprintf(stderr, "[%d]: %d neighbors.\n", mn->address(), num_ents);
+ 	#endif
+ 
+ 	for (i = 0; i < num_ents; i++)
+ 	{
+ 		#ifdef	DEBUG_PRINT
+ 		fprintf(stderr, "%d[%d] x: %f, y: %f, z: %f\n", 
+ 			mn->address(), tab[i]->net_id, tab[i]->x, tab[i]->y, tab[i]->z);
+ 		#endif
+ 
+ 
+ 		if (tab[i]->routeFlag == 1)
+ 		{
+ 			ne = tab[i];
+ 			return ne;
+ 		}
+ 
+ 		if (tab[i]->z > t)
+ 		{
+ 		    t = tab[i]->z;
+ 		    ne = tab[i];
+ 		}
+ 	}
+ 	return ne;
+ }
+ #else
+ NeighbEnt *
+ NeighbTable::ent_find_shadowest(MobileNode *mn)
+ {
+     NeighbEnt *ne = 0;
+     int i;
+     double x, y, z, t;
+  
+     mn->getLoc(&x, &y, &z);
+     t = z;
+ 
+     for (i = 0; i < num_ents; i++)
+     {
+ 	#ifdef	DEBUG_PRINT
+ 	fprintf(stderr, "%d[%d] x: %f, y: %f, z: %f\n", 
+ 		mn->address(), tab[i]->net_id, tab[i]->x, tab[i]->y, tab[i]->z);
+ 	#endif
+ 
+         if (tab[i]->z > t)
+         {
+             t = tab[i]->z;
+             ne = tab[i];
+         }
+     }
+ 
+     return ne;
+ }
+ #endif	// DBR_USE_ROUTEFLAG
+ 
+ 
+ DBR_Agent::DBR_Agent() : Agent(PT_DBR),
+ 	bint_(DBR_BEACON_INT), bdesync_(DBR_BEACON_DESYNC), mn_(0), pkt_cnt_(0)
+ {
+ 	ntab_ = new NeighbTable(this);
+ 
+ 	// create packet cache
+ 	pc_ = new PktCache();
+ }
+ 
+ DBR_Agent::~DBR_Agent()  
+ {
+ 	delete ntab_;
+ 
+ 	// packet cache
+ 	delete pc_;
+ }
+ 
+ // construct the beacon packet
+ Packet* 
+ DBR_Agent::makeBeacon(void)
+ {
+ 	Packet *p = allocpkt();
+ 	assert(p != NULL);
+ 	
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 
+ 	// setup header
+ 	cmh->next_hop_ = IP_BROADCAST;
+ 	cmh->addr_type_ = AF_INET;
+ 	cmh->ptype_ = PT_DBR;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->size() = dbrh->size() + IP_HDR_LEN;
+ 
+ 	//iph->daddr() = IP_BROADCAST << Address::instance().nodeshift();
+ 	iph->saddr() = mn_->address();
+ 	iph->daddr() = IP_BROADCAST;
+ 	iph->dport() = DBR_PORT;
+ 
+ 	// fill in the location info 
+ 	mn_->getLoc(&(dbrh->x), &(dbrh->y), &(dbrh->z));
+ 	dbrh->mode() = DBRH_BEACON;
+ 	dbrh->nhops() = 1;
+ 
+ 	return p;
+ }
+ 
+ // send beacon pkt only once at the beginning
+ void DBR_Agent::sendBeacon(void)
+ {
+ 	Packet *p = makeBeacon();
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 
+ 	if (p) 
+ 	{
+ 		assert(!HDR_CMN(p)->xmit_failure_);
+ 		if (cmh->direction() == hdr_cmn::UP)
+ 			cmh->direction() = hdr_cmn::DOWN;
+ 		Scheduler::instance().schedule(ll, p, 0);
+ 	}
+ 	else
+ 	{
+ 		fprintf(stderr, "ERROR: Can't make new beacon!\n");
+ 		abort();
+ 	}
+ }
+ 
+ // fetch the packet from the sending queue
+ // and broadcast.
+ void DBR_Agent::send_callback(void)
+ {
+ 	QueueItem *q;
+ 	hdr_dbr *dbrh;
+ 
+ 	// we're done if there is no packet in queue
+ 	if (pq_.empty())
+ 		return;
+ 
+ 	// send the first packet out
+ 	q = pq_.front();
+ 	pq_.pop();
+ 	Scheduler::instance().schedule(ll, q->p_, 0);
+ 
+ 	// put the packet into cache
+ 	dbrh = hdr_dbr::access(q->p_);
+ 	pc_->addPacket(dbrh->packetID());
+ 
+ 	// reschedule the timer if there are
+ 	// other packets in the queue
+ 	if (!pq_.empty())
+ 	{
+ 		q = pq_.front();
+ 		latest_ = q->send_time_;
+ 		send_timer_->resched(latest_ - NOW);
+ 	}
+ }
+ 
+ void DBR_Agent::beacon_callback(void)
+ {
+ 	return;
+ 
+ 	Packet *p = makeBeacon();
+ 
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 
+ 	if (p) 
+ 	{
+ 		assert(!HDR_CMN(p)->xmit_failure_);
+ 		if (cmh->direction() == hdr_cmn::UP)
+ 			cmh->direction() = hdr_cmn::DOWN;
+ 
+ 		//fprintf(stderr, "%d is broadcasting beacon pkt src: %d, dst: %d\n",
+ 		//		mn_->address(), iph->saddr(), iph->daddr());
+ 
+ 		Scheduler::instance().schedule(ll, p, Random::uniform()*JITTER);
+ 	}
+ 	else
+ 	{
+ 		fprintf(stderr, "ERROR: Can't make new beacon!\n");
+ 		exit(-1);
+ 	}
+ 
+ 	//BEACON_RESCHED
+ }
+ 
+ void DBR_Agent::deadneighb_callback(NeighbEnt *ne)
+ {
+ 	ntab_->ent_delete(ne);
+ }
+ 
+ void DBR_Agent::forwardPacket(Packet *p, int flag)
+ {
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 	NeighbEnt *ne;
+ 
+ 	double delay = 0.0;
+ 
+ 	#ifdef	DEBUG_AGENT
+ 	fprintf(stderr, "node %d is forwarding to %d\n", 
+ 				mn_->address(), Address::instance().get_nodeaddr(iph->daddr()));
+ 	#endif
+ 
+ 	// common settings for forwarding
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->addr_type_ = AF_INET;
+ 	cmh->ptype_ = PT_DBR;
+ 	cmh->size() = dbrh->size() + IP_HDR_LEN;
+ 
+ 	// make decision on next hop based on packet mode
+ 	switch (dbrh->mode()) 
+ 	{
+ 	case DBRH_DATA_GREEDY: 
+ 		ne = ntab_->ent_find_shadowest(mn_);
+ 		if (ne)
+ 		{
+ 			cmh->next_hop() = ne->net_id;
+ 			#ifdef	DEBUG_AGENT
+ 			fprintf(stderr, "[%d] -> %d\n", mn_->address(), ne->net_id);
+ 			#endif
+ 		}
+ 		else
+ 		{
+ 			#ifdef	DEBUG_PRINT
+ 			fprintf(stderr, "[%d]: put pkt into recovery mode!\n", mn_->address());
+ 			#endif
+ 		
+ 			// put packet into recovery mode
+ 			cmh->next_hop() = IP_BROADCAST;
+ 			dbrh->mode() = DBRH_DATA_RECOVER;
+ 			dbrh->prev_hop() = mn_->address();
+ 			dbrh->owner() = mn_->address();
+ 			dbrh->nhops() = DBR_MAX_HOPS;		// set the range of broadcasting by hops
+ 		}
+ 		break;
+ 	case DBRH_DATA_RECOVER:
+ 		#ifdef	DEBUG_PRINT
+ 		fprintf(stderr, "[%d]: forward in recovery alogrithm!\n", mn_->address());
+ 		#endif
+ 
+ 		if (pc_->accessPacket(dbrh->packetID()))
+ 		{
+ 			// each node only broadcasts once 
+ 			#ifdef DEBUG_PRINT
+ 			fprintf(stderr, "[%d]: packet is already in cache!\n", mn_->address());
+ 			#endif
+ 
+ 			return;
+ 		}
+ 		else
+ 			pc_->addPacket(dbrh->packetID());
+ 
+ 		// can we find other greedy node?
+ 		ne = ntab_->ent_find_shadowest(mn_);
+ 		if (ne == NULL)
+ 		{
+ 			if (dbrh->nhops() <= 0)
+ 			{
+ 				#ifdef	DEBUG_BROADCASTING
+ 				fprintf(stderr, "[%d] drops pkt! (nhops < 0)\n", mn_->address());
+ 				#endif
+ 					
+ 				drop(p, DROP_RTR_TTL);
+ 				return;
+ 			}
+ 			else
+ 			{
+ 				// broadcasting
+ 				cmh->next_hop() = IP_BROADCAST;
+ 				dbrh->mode() = DBRH_DATA_RECOVER;
+ 				dbrh->owner() = dbrh->prev_hop();
+ 				dbrh->prev_hop() = mn_->address();
+ 				dbrh->nhops()--;
+ 			
+ 				// set broadcasting delay
+ 				delay = Random::uniform() * JITTER;
+ 			}
+ 		}
+ 		else if (ne->net_id != dbrh->prev_hop())
+ 		{
+ 			// new route is found, put pkt back to greedy alg
+ 			cmh->next_hop() = ne->net_id;
+ 			dbrh->mode() = DBRH_DATA_GREEDY;
+ 			#ifdef	DEBUG_AGENT
+ 			fprintf(stderr, "back to greedy: [%d] -> %d\n", mn_->address(), ne->net_id);
+ 			#endif
+ 		}
+ 		else
+ 		{
+ 			#ifdef	DEBUG_PRINT
+ 			fprintf(stderr, "[%d]:dbrh->nhops = %d\n", mn_->address(),
+ 					dbrh->nhops());
+ 			#endif
+ 
+ 			if (dbrh->nhops() <= 0)
+ 			{
+ 				#ifdef	DEBUG_BROADCASTING
+ 				fprintf(stderr, "[%d] drops pkt! (nhops < 0)\n", mn_->address());
+ 				#endif
+ 
+ 				drop(p, DROP_RTR_TTL);
+ 				return;
+ 			}
+ 			else
+ 			{
+ 				#ifdef	DEBUG_BROADCASTING
+ 				fprintf(stderr, "[%d] is broadcasting!\n", mn_->address());
+ 				#endif
+ 
+ 				// broadcasting
+ 				cmh->next_hop() = IP_BROADCAST;
+ 				dbrh->mode() = DBRH_DATA_RECOVER;
+ 				dbrh->owner() = dbrh->prev_hop();
+ 				dbrh->prev_hop() = mn_->address();
+ 				dbrh->nhops()--;
+ 
+ 				// set broadcasting delay
+ 				delay = Random::uniform() * JITTER;
+ 			}
+ 		}
+ 		break;
+ 	default:
+ 		fprintf(stderr, "Wrong! The packet can't be forwarded!\n");
+ 		abort();
+ 		break;
+ 	}
+ 
+ 	// schedule the sending
+ 	assert(!HDR_CMN(p)->xmit_failure_);
+ 	Scheduler::instance().schedule(ll, p, delay);
+ }
+ 
+ // get the info from beacon pkt
+ void DBR_Agent::beaconIn(Packet *p)
+ {
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 
+ 	nsaddr_t src = Address::instance().get_nodeaddr(iph->saddr());
+ 
+ 	// create NeighbEnt
+ 	NeighbEnt *ne;
+ 	ne = new NeighbEnt(this);
+ 
+ 	#ifdef DEBUG_BEACON
+ 	fprintf(stderr, "%d got beacon from %d\n",
+ 				mn_->address(), src);
+ 	#endif
+ 
+ 	ne->x = dbrh->x;
+ 	ne->y = dbrh->y;
+ 	ne->z = dbrh->z;
+ 	ne->net_id = src;
+ 	
+ 	ntab_->ent_add(ne);
+ 
+ 	delete ne;
+ 
+ 	// we consumed the packet, free it!
+ 	Packet::free(p);
+ }
+ 
+ #if 1
+ void DBR_Agent::recv(Packet *p, Handler *)
+ {
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 
+ 	double x, y, z;
+ 
+ 	nsaddr_t src = Address::instance().get_nodeaddr(iph->saddr());
+ 	nsaddr_t dst = Address::instance().get_nodeaddr(iph->daddr());
+ 
+ 	if (mn_ == NULL)
+ 	{
+ 		fprintf(stderr, "ERROR: Pointer to node is null!\n");
+ 		abort();
+ 	}
+ 
+ 	mn_->getLoc(&x, &y, &z);
+ 
+ 	if (dbrh->mode() == DBRH_BEACON)
+ 	{// although we eliminate the beacon pkt
+ 	 // but we still reserve the handler for 
+ 	 // furture control logic
+ 
+ 		#ifdef DEBUG_PRINT
+ 		fprintf(stderr, "[%d]: beacon pkt is received.\n", mn_->address());
+ 		#endif
+ 
+ 		// self is not one of the neighbors
+ 		if (src != mn_->address())
+ 			beaconIn(p); 
+ 		return;
+ 	}
+ 	
+ 	if ((src == mn_->address()) &&
+ 	    (cmh->num_forwards() == 0))
+ 	{// packet I'm originating
+ 
+ 		cmh->direction() = hdr_cmn::DOWN;
+ 		cmh->addr_type_ = AF_INET;
+ 		cmh->ptype_ = PT_DBR;
+ 		cmh->size() = dbrh->size() + IP_HDR_LEN;
+ 		cmh->next_hop() = IP_BROADCAST;
+ 		iph->ttl_ = 128;
+ 
+ 		// setup DBR header
+ 		dbrh->mode() = DBRH_DATA_GREEDY;
+ 		//dbrh->packetID() = (int)mn_->address();
+ 		dbrh->packetID() = pkt_cnt_++;
+ 		dbrh->depth() = z;		// save the depth info
+ 
+ 		// broadcasting the pkt
+ 		assert(!HDR_CMN(p)->xmit_failure_);
+ 		Scheduler::instance().schedule(ll, p, 0);
+ 
+ 		return;
+ 	}
+ 
+ 	if ((src == mn_->address()) &&
+ 	    (dbrh->mode() == DBRH_DATA_GREEDY))
+ 	{// Wow, it seems some one is broadcasting the pkt for us,
+ 	 // so we need to dismiss the timer for the pkt
+ 
+ 		#ifdef	DEBUG_PRINT
+ 		fprintf(stderr, "[%d] got the pkt I've sent\n", mn_->address());
+ 		#endif
+ 
+ 		drop(p, DROP_RTR_ROUTE_LOOP);
+ 		return;
+ 	}
+ 
+ 	if (dst == mn_->address())
+ 	{// packet is for me
+ 
+ 		#ifdef DEBUG_PRINT
+ 		fprintf(stderr, "[%d] packet is delivered!\n", mn_->address());
+ 		fflush(stderr);
+ 		#endif
+ 
+ 		// we may need to send it to upper layer agent
+ 		send_to_dmux(p, 0);
+ 
+ 		return;
+ 	}
+ 
+ 	// packet I'm forwarding
+ 	handlePktForward(p);
+ }
+ 
+ #ifdef USE_FLOODING_ALG
+ void DBR_Agent::handlePktForward(Packet *p)
+ {
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 
+ 	if (--iph->ttl_ == 0)
+ 	{
+ 		drop(p, DROP_RTR_TTL);
+ 		return;
+ 	}
+ 
+ 	// Is this pkt recieved before?
+ 	// each node only broadcasts same pkt once 
+ 	if (pc_->accessPacket(dbrh->packetID()))
+ 	{
+ 		drop(p, DROP_RTR_TTL);
+ 		return;
+ 	}
+ 	else
+ 		pc_->addPacket(dbrh->packetID());
+ 
+ 	// common settings for forwarding
+ 	cmh->num_forwards()++;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->addr_type_ = AF_INET;
+ 	cmh->ptype_ = PT_DBR;
+ 	cmh->size() = dbrh->size() + IP_HDR_LEN;
+ 	cmh->next_hop() = IP_BROADCAST;
+ 	
+ 	// finally broadcasting it!
+ 	assert(!HDR_CMN(p)->xmit_failure_);
+ 	Scheduler::instance().schedule(ll, p, Random::uniform()*JITTER);
+ }
+ #else
+ // Forward the packet according to its mode
+ // There are two modes right now: GREEDY and RECOVERY
+ // The node will broadcast all RECOVERY pakets, but
+ // it will drop the GREEDY pakets from upper level.
+ void DBR_Agent::handlePktForward(Packet *p)
+ {
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 
+ 	double delta;
+ 	double delay = .0;
+ 
+ 	double x, y, z;
+ 
+ 	if (--iph->ttl_ == 0)
+ 	{
+ 		drop(p, DROP_RTR_TTL);
+ 		return;
+ 	}
+ 
+ 	/*
+ 	// dump the queue
+ 	fprintf(stderr, "-------- Node id: %d --------\n", mn_->address());
+ 	fprintf(stderr, " curID: %d\n", dbrh->packetID());
+ 	pq_.dump();
+ 	*/
+ 
+ #if 0
+ 	// search sending queue for p
+ 	if (pq_.purge(p))
+ 	{
+ 		drop(p, DROP_RTR_TTL);
+ 		return;
+ 	}
+ #endif
+ 	
+ 	// common settings for forwarding
+ 	cmh->num_forwards()++;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->addr_type_ = AF_INET;
+ 	cmh->ptype_ = PT_DBR;
+ 	cmh->size() = dbrh->size() + IP_HDR_LEN;
+ 	cmh->next_hop() = IP_BROADCAST;
+ 
+ 	switch (dbrh->mode())
+ 	{
+ 	case DBRH_DATA_GREEDY:
+ 		mn_->getLoc(&x, &y, &z);
+ 	
+ 		// compare the depth
+ 		delta = z - dbrh->depth();
+ 
+ 		// only forward the packet from lower level
+ 		if (delta < DBR_DEPTH_THRESHOLD)
+ 		{
+ 			pq_.purge(p);
+ 			drop(p, DROP_RTR_TTL);
+ 			return;
+ 		}
+ 
+ 		#ifdef DEBUG_NONE
+ 		fprintf(stderr, "[%d]: z = %.3f, depth = %.3f, delta = %.3f\n", 
+ 			mn_->address(), z, dbrh->depth(), delta);
+ 		#endif
+ 
+ 		// update current depth
+ 		dbrh->depth() = z;
+ 
+ 		// compute the delay
+ 		//delay = DBR_DEPTH_THRESHOLD / delta * DBR_SCALE;
+ 		delta = 1.0 - delta / DBR_MAX_RANGE;
+ 		delay = DBR_MIN_BACKOFF + 4.0 * delta * DBR_MAX_DELAY;
+ 
+ 		// set time out for the packet
+ 		
+ 		break;
+ 	case DBRH_DATA_RECOVER:
+ 		if (dbrh->nhops() <= 0)
+ 		{
+ 			#ifdef	DEBUG_PRINT
+ 			fprintf(stderr, "[%d] drops pkt! (nhops < 0)\n", mn_->address());
+ 			#endif
+ 					
+ 			drop(p, DROP_RTR_TTL);
+ 			return;
+ 		}
+ 		dbrh->nhops()--;
+ 		break;
+ 	default:
+ 		fprintf(stderr, "Unknown data type!]n");
+ 		return;
+ 	}
+ 
+ 	// make up the DBR header
+ 	dbrh->owner() = dbrh->prev_hop();
+ 	dbrh->prev_hop() = mn_->address();
+ 
+ 	#ifdef DEBUG_NONE
+ 	fprintf(stderr, "[%d]: delay %f before broacasting!\n", 
+ 			mn_->address(), delay);
+ 	#endif
+ 
+ 	if (pc_ == NULL) {
+ 		fprintf(stderr, "packet cache pointer is null!\n");
+ 		exit(-1);
+ 	}
+ 
+ 	// Is this pkt recieved before?
+ 	// each node only broadcasts the same pkt once 
+ 	if (pc_->accessPacket(dbrh->packetID()))
+ 	{
+ 		drop(p, DROP_RTR_TTL);
+ 		return;
+ 	}
+ 	//else
+ 	//	pc_->addPacket(dbrh->packetID());
+ 
+ 	// put the packet into sending queue
+ 	double expected_send_time = NOW + delay;
+ 	QueueItem *q = new QueueItem(p, expected_send_time);
+ 
+ 	/*
+ 	pq_.insert(q);
+ 	QueueItem *qf;
+ 	qf = pq_.front();
+ 	send_timer_->resched(qf->send_time_ - NOW);
+ 	*/
+ 
+ 	if (pq_.empty())
+ 	{ 
+ 		pq_.insert(q);
+ 		latest_ = expected_send_time;
+ 		send_timer_->resched(delay);
+ 	}
+ 	else
+ 	{
+ 		if (pq_.update(p, expected_send_time))
+ 		{
+ 			pq_.insert(q);
+ 
+ 			// update the sending timer
+ 			if (expected_send_time < latest_)
+ 			{
+ 				latest_ = expected_send_time;
+ 				send_timer_->resched(delay);
+ 			}
+ 		}
+ 	}
+ }
+ #endif	// end of USE_FLOODING_ALG
+ #else
+ void DBR_Agent::recv(Packet *p, Handler *)
+ {
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 	
+ 	nsaddr_t src = Address::instance().get_nodeaddr(iph->saddr());
+ 	nsaddr_t dst = Address::instance().get_nodeaddr(iph->daddr());
+ 
+ 	#ifdef	DEBUG_PRINT
+ 	//fprintf(stderr, "%d receives pkt from %d to %d\n", 
+ 	//	mn_->address(), src, dst);
+ 	#endif
+ 
+ 	if (mn_ == NULL)
+ 	{
+ 		fprintf(stderr, "ERROR: Pointer to node is null!\n");
+ 		abort();
+ 	}
+ 
+ 	if (dbrh->mode() == DBRH_BEACON)
+ 	{// beacon packet
+ 
+ 		// self is not one of the neighbors
+ 		if (src != mn_->address())
+ 			beaconIn(p); 
+ 		return;
+ 	}
+ 	else if ((src == mn_->address()) &&
+ 		(cmh->num_forwards() == 0))
+ 	{// packet I'm originating
+ 
+ 		#ifdef DEBUG_PRINT
+ 		fprintf(stderr, "%d generates data packet.\n", src);
+ 		#endif
+ 		
+ 		cmh->size() += IP_HDR_LEN + 8;
+ 		cmh->direction() = hdr_cmn::DOWN;
+ 		iph->ttl_ = 128;
+ 		dbrh->mode() = DBRH_DATA_GREEDY;
+ 		dbrh->packetID() = (int)mn_->address();
+ 	}
+ 	else if ((src == mn_->address()) &&
+ 		(dbrh->mode() == DBRH_DATA_GREEDY))
+ 	{// duplicate packet, discard
+ 
+ 		#ifdef	DEBUG_PRINT
+ 		fprintf(stderr, "got the pkt I've sent\n");
+ 		#endif
+ 
+ 		drop(p, DROP_RTR_ROUTE_LOOP);
+ 		return;
+ 	}
+ 	else if (dst == mn_->address())
+ 	{// packet is for me
+ 
+ 		#ifdef DEBUG_BROADCASTING
+ 		fprintf(stderr, "Packet is delivered!\n");
+ 		fflush(stderr);
+ 		#endif
+ 
+ 		// we may need to send it to upper layer agent
+ 		send_to_dmux(p, 0);
+ 
+ 		return;
+ 	}
+ /*------------------------------------------------
+ 	else if (dst == IP_BROADCAST) 
+ 	{
+ 		if (dbrh->mode() == DBRH_BEACON)
+ 		{
+ 			// self is not one of the neighbors
+ 			if (src != mn_->address())
+ 				beaconIn(p); 
+ 			return;
+ 		}
+ 	}
+ ------------------------------------------------*/
+ 	else
+ 	{// packet I'm forwarding
+ 
+ 		if (--iph->ttl_ == 0)
+ 		{
+ 			drop(p, DROP_RTR_TTL);
+ 			return;
+ 		}
+ 
+ 		if((dbrh->mode() == DBRH_DATA_RECOVER) &&
+ 			(dbrh->owner() == mn_->address()))
+ 		{
+ 			//fprintf(stderr, "got the pkt I've sent\n");
+ 			drop(p, DROP_RTR_ROUTE_LOOP);
+ 			// it seems this neighbor couldn't find a greedy node
+ 			//ntab_->updateRouteFlag(dbrh->prev_hop(), 0);
+ 			return;
+ 		}
+ 	}
+ 
+ 	#ifdef	DEBUG_PRINT
+ 	fprintf(stderr, "owner %d, prev-hop: %d, cur: %d\n",
+ 		dbrh->owner(), dbrh->prev_hop(), mn_->address());
+ 	#endif
+ 
+ 	// it's time to forward the pkt now	
+ 	forwardPacket(p);
+ }
+ #endif
+ 
+ void DBR_Agent::recv2(Packet *p, Handler *)
+ {
+ 	hdr_ip *iph = hdr_ip::access(p);
+ 	hdr_cmn *cmh = hdr_cmn::access(p);
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 	
+ 	nsaddr_t src = Address::instance().get_nodeaddr(iph->saddr());
+ 	nsaddr_t dst = Address::instance().get_nodeaddr(iph->daddr());
+ 
+ 	#ifdef	DEBUG_PRINT
+ 	//fprintf(stderr, "%d receives pkt from %d to %d\n", 
+ 	//	mn_->address(), src, dst);
+ 	#endif
+ 
+ 	if (mn_ == NULL)
+ 	{
+ 		fprintf(stderr, "ERROR: Pointer to node is null!\n");
+ 		abort();
+ 	}
+ 
+ 	if (dbrh->mode() == DBRH_BEACON)
+ 	{// beacon packet
+ 
+ 		// self is not one of the neighbors
+ 		if (src != mn_->address())
+ 			beaconIn(p); 
+ 		return;
+ 	}
+ 	else if ((src == mn_->address()) &&
+ 		(cmh->num_forwards() == 0))
+ 	{// packet I'm originating
+ 
+ 		#ifdef DEBUG_PRINT
+ 		fprintf(stderr, "%d generates data packet.\n", src);
+ 		#endif
+ 		
+ 		cmh->size() += IP_HDR_LEN + 8;
+ 		cmh->direction() = hdr_cmn::DOWN;
+ 		iph->ttl_ = 128;
+ 		dbrh->mode() = DBRH_DATA_GREEDY;
+ 		dbrh->packetID() = (int)mn_->address();
+ 	}
+ 	else if ((src == mn_->address()) &&
+ 		(dbrh->mode() == DBRH_DATA_GREEDY))
+ 	{// duplicate packet, discard
+ 
+ 		#ifdef	DEBUG_PRINT
+ 		fprintf(stderr, "got the pkt I've sent\n");
+ 		#endif
+ 
+ 		drop(p, DROP_RTR_ROUTE_LOOP);
+ 		return;
+ 	}
+ 	else if (dst == mn_->address())
+ 	{// packet is for me
+ 
+ 		#ifdef DEBUG_BROADCASTING
+ 		fprintf(stderr, "Packet is delivered!\n");
+ 		fflush(stderr);
+ 		#endif
+ 
+ 		// we may need to send it to upper layer agent
+ 		send_to_dmux(p, 0);
+ 
+ 		return;
+ 	}
+ /*------------------------------------------------
+ 	else if (dst == IP_BROADCAST) 
+ 	{
+ 		if (dbrh->mode() == DBRH_BEACON)
+ 		{
+ 			// self is not one of the neighbors
+ 			if (src != mn_->address())
+ 				beaconIn(p); 
+ 			return;
+ 		}
+ 	}
+ ------------------------------------------------*/
+ 	else
+ 	{// packet I'm forwarding
+ 
+ 		if (--iph->ttl_ == 0)
+ 		{
+ 			drop(p, DROP_RTR_TTL);
+ 			return;
+ 		}
+ 
+ 		if((dbrh->mode() == DBRH_DATA_RECOVER) &&
+ 			(dbrh->owner() == mn_->address()))
+ 		{
+ 			//fprintf(stderr, "got the pkt I've sent\n");
+ 			drop(p, DROP_RTR_ROUTE_LOOP);
+ 			// it seems this neighbor couldn't find a greedy node
+ 			//ntab_->updateRouteFlag(dbrh->prev_hop(), 0);
+ 			return;
+ 		}
+ 	}
+ 
+ 	#ifdef	DEBUG_PRINT
+ 	fprintf(stderr, "owner %d, prev-hop: %d, cur: %d\n",
+ 		dbrh->owner(), dbrh->prev_hop(), mn_->address());
+ 	#endif
+ 
+ 	// it's time to forward the pkt now	
+ 	forwardPacket(p);
+ }
+ 
+ int DBR_Agent::command(int argc, const char * const *argv)
+ {
+ 	if (argc == 2)
+ 	{
+ 		if (strcmp(argv[1], "start-dbr") == 0)
+ 		{
+ 			init();
+ 			return TCL_OK;
+ 		}
+ 		
+ 		if (strcmp(argv[1], "test") == 0)
+ 		{
+ 			sendBeacon();	// only send beacon once
+ 			return TCL_OK;
+ 		}
+ 	}
+ 	else if (argc == 3)
+ 	{
+ 		TclObject *obj;
+ 			
+ 		if (strcmp(argv[1], "port-dmux") == 0) {
+ 			dmux = (PortClassifier *)TclObject::lookup(argv[2]);
+ 			if (dmux == 0) {
+ 				fprintf(stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1],
+ 					argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "tracetarget") == 0)
+ 		{
+ 			if ((obj = TclObject::lookup(argv[2])) == 0)
+ 			{
+ 				fprintf(stderr, "%s: %s lookup of %s failed\n", 
+ 					__FILE__, argv[1], argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			traceagent = (Trace *)obj;
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "node") == 0)
+ 		{
+ 			if ((obj = TclObject::lookup(argv[2])) == 0)
+ 			{
+ 				fprintf(stderr, "%s: %s lookup of %s failed\n", 
+ 					__FILE__, argv[1], argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			mn_ = (MobileNode *)obj;
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "add-ll") == 0)
+ 		{
+ 			if ((obj = TclObject::lookup(argv[2])) == 0)
+ 			{
+ 				fprintf(stderr, "DBRAgent: %s lookup of %s failed\n",
+ 						argv[1], argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			ll = (NsObject*)obj;
+ 			return TCL_OK;
+ 		}
+ 
+ 	}
+ 	return (Agent::command(argc, argv));
+ }
+ 
+ void DBR_Agent::trace(char* fmt, ...)
+ {
+ 	va_list ap;
+ 
+ 	if (!traceagent) return;
+ 
+ 	va_start(ap, fmt);
+ 	vsprintf(traceagent->pt_->buffer(), fmt, ap);
+ 	traceagent->pt_->dump();
+ 	va_end(ap);
+ }
+ 
+ void DBR_Agent::init(void)
+ {
+ 	// setup the timer
+ 	beacon_timer_ = new DBR_BeaconTimer(this);
+ 	beacon_timer_->sched(Random::uniform(bint_));
+ 
+ 	send_timer_ = new DBR_SendingTimer(this);
+ 	//send_timer_->sched(Random::uniform(bint_));
+ }
+ 
+ void DBR_Agent::tap(const Packet *p)
+ {
+ 	// add function later
+ }
+ 
+ //////////////////////////////////////////////////////////////////
+ void dumpDBRHdr(Packet *p)
+ // dump the header info for debug
+ {
+ 	hdr_dbr *dbrh = hdr_dbr::access(p);
+ 
+ }
diff -crBN ns-2.35/dbr/dbr.h ns-2.35-aquasim/dbr/dbr.h
*** ns-2.35/dbr/dbr.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/dbr/dbr.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,244 ----
+ /** 
+  *  Depth based routing alogrithm header file.
+  *  Author: Hai Yan, University of Connecticut CSE, March, 2007
+  */
+ 
+ #ifndef	_DBR_H_
+ #define	_DBR_H_
+ 
+ #include <deque>
+ 
+ #include <stdarg.h>
+ 
+ #include <object.h>
+ #include <agent.h>
+ #include <trace.h>
+ #include <packet.h>
+ #include <mac.h>
+ #include <mobilenode.h>
+ #include <classifier-port.h>
+ 
+ #include "pkt_cache.h"
+ 
+ #define	DBR_PORT		0xFF
+ 
+ #define	DBR_BEACON_DESYNC	0.1		// desynchronizing form for alive beacons
+ #define	DBR_BEACON_INT		10		// interval between beacons
+ #define	JITTER			1		// jitter for broadcasting
+ 
+ class DBR_Agent;
+ class MyPacketQueue;
+ class NeighbEnt;
+ class NeighbTable;
+ class hdr_dbr;
+ 
+ #if	0
+ struct DBRPacket {
+ 	int dest;
+ 	int src;
+ 	Packet *pkt;	// inner NS packet
+ 
+ 	DBRPacket() : pkt(NULL) {}
+ 	DBRPacket(Packet *p, hdr_dbr *dbrh) : 
+ 			pkt(p) {}
+ };
+ #endif
+ 
+ class DBR_AgentTimer : public TimerHandler {
+ public:
+ 	DBR_AgentTimer(DBR_Agent *a) { a_ = a; }
+ 	virtual void expire(Event *e) = 0;
+ 
+ protected:
+ 	DBR_Agent *a_;
+ };
+ 
+ class DBR_BeaconHandler : public Handler {
+ public:
+ 	DBR_BeaconHandler(DBR_Agent *a) { a_ = a; }
+ 	virtual void handle(Event *e);
+ 
+ private:
+ 	DBR_Agent *a_;
+ };
+ 
+ class DBR_BeaconTimer : public DBR_AgentTimer {
+ public:
+ 	DBR_BeaconTimer(DBR_Agent *a) : DBR_AgentTimer(a) {}
+ 	virtual void expire(Event *e); 
+ };
+ 
+ class DBR_SendingTimer : public DBR_AgentTimer {
+ public:
+ 	DBR_SendingTimer(DBR_Agent *a) : DBR_AgentTimer(a) {}
+ 	virtual void expire(Event *e); 
+ };
+ 
+ class QueueItem {
+ public:
+ 	QueueItem() : p_(0), send_time_(0) {}
+ 	QueueItem(Packet *p, double t) : p_(p), send_time_(t) {}
+ 
+ 	Packet *p_;		// pointer to the packet
+ 	double send_time_;	// time to send the packet 
+ };
+ 
+ class MyPacketQueue {
+ public:
+ 	MyPacketQueue() : dq_() {}
+ 	~MyPacketQueue() { dq_.clear(); }
+ 
+ 	bool empty() { return dq_.empty(); }
+ 	int size() { return dq_.size(); }
+ 	void dump();
+ 
+ 	void pop() { dq_.pop_front(); }; 
+ 	QueueItem* front() { return dq_.front(); };
+ 	void insert(QueueItem* q);
+ 	bool update(Packet *p, double t);
+ 	bool purge(Packet *p);
+ 
+ private:
+ 	deque<QueueItem*> dq_;
+ };
+ 
+ class NeighbEnt {
+ public:
+ 	NeighbEnt(DBR_Agent* ina) : 
+ 		x(0.0), y(0.0), z(0.0), routeFlag(0) {}	
+ 	// the agent is used for timer object
+ 
+ 	double x, y, z;		// location of neighbor, actually we only need depth info
+ 	nsaddr_t net_id;    // IP of neighbor 
+ 	int routeFlag;		// indicates that a routing path exists
+ 
+ 	// user timer 
+ 	//DBR_DeadNeighbTimer dnt;	// timer for expiration of neighbor
+ 
+ };
+ 
+ class NeighbTable {
+ public:
+ 	NeighbTable(DBR_Agent *a); 
+ 	~NeighbTable();
+ 
+ 	void dump(void);
+ 	void ent_delete(const NeighbEnt *e);        	// delete an neighbor
+ 	NeighbEnt *ent_add(const NeighbEnt *e);     	// add an neighbor
+ 	NeighbEnt *ent_find_shadowest(MobileNode *mn);  // find the neighbor with minimal depth
+ 	void updateRouteFlag(nsaddr_t, int); 
+ 
+ private:
+ 	int num_ents;       // number of entries in use
+ 	int max_ents;       // capacity of the table
+ 	DBR_Agent *a_;       // agent owns the table
+ 	NeighbEnt **tab;    // neighbor table
+ };
+ 
+ #define	DBRH_DATA_GREEDY	0
+ #define	DBRH_DATA_RECOVER	1
+ #define	DBRH_BEACON		2
+ 
+ class hdr_dbr {
+ public:
+ 	static int offset_;		// offset of this header
+ 	static int& offset() { return offset_; }
+ 	static hdr_dbr* access(const Packet *p) {
+ 		return (hdr_dbr*)p->access(offset_); 
+ 	}
+ 
+ 	double x, y, z;	
+ 
+ 	int& packetID() { return packetID_; }
+ 	
+ 	int& valid() { return valid_; }
+ 	int& mode()  { return mode_; }
+ 	int& nhops() { return nhops_; }
+ 	nsaddr_t& prev_hop() { return prev_hop_; }
+ 	nsaddr_t& owner() { return owner_; }
+ 
+ 	double& depth() { return depth_; }
+ 
+ 	// get the header size 
+ 	int size() 
+ 	{ 	int sz;
+ 		sz = 4 * sizeof(int); 
+ 		sz += 3 * sizeof(double);
+ 		return sz;
+ 	}
+ 
+ private:
+ 	int packetID_;		// unique id for packet
+ 
+ 	int valid_;		// is this header in the packet?
+ 	int mode_;		// routing mode: greedy | recovery
+ 	int nhops_;		// max # of hops to broadcast
+ 				// in recovery mode
+ 	nsaddr_t prev_hop_;	// the sender
+ 	nsaddr_t owner_;	// from whom the sender got it
+ 
+ 	double depth_;		// the depth of last hop
+ };
+ 
+ class DBR_Agent : public Tap, public Agent {
+ 	friend class DBR_BeaconHandler;
+ 	friend class DBR_BeaconTimer;
+ 	friend class DBR_SendingTimer;
+ 
+ public:
+ 	DBR_Agent();
+ 	~DBR_Agent();
+ 
+ 	virtual int command(int argc, const char*const* argv);
+ 	virtual void recv(Packet *, Handler *);
+ 	virtual void recv2(Packet *, Handler *);
+ 
+ 	virtual void tap(const Packet *p);
+ 
+ 	void deadneighb_callback(NeighbEnt *ne); 
+ 	void beacon_callback(void);
+ 	void send_callback(void);
+ 	
+ 	//DBR_BeaconHandler bhdl;
+ 
+ protected:
+ 	Trace *traceagent;	// Trace agent 
+ 	PortClassifier *dmux;
+ 
+ 	int off_mac_;
+ 	int off_ll_;
+ 	int off_ip_;
+ 	int off_dbr_;		// offset of DBR packet header in pkt
+ 		
+ 	double bint_;		// beacon interval
+ 	double bdesync_;	// desynchronizing term
+ 
+ 	double latest_;		// latest time to send the packet
+ 
+ 	NsObject *ll;				// our link layer output
+ 	//NsObject *port_dmux;
+ 	MobileNode *mn_;			// MobileNode associated with the agent
+ 	NeighbTable *ntab_;			// neighbor entry table
+ 	DBR_BeaconTimer *beacon_timer_;		// beacon timer
+ 	DBR_SendingTimer *send_timer_;		// sending timer
+ 
+ 	PktCache *pc_;				// packet cache for broadcasting;
+ 	MyPacketQueue pq_;			// packet queue
+ 	int pkt_cnt_;				// counter for packets have been sent
+ 
+ 	inline void send_to_dmux(Packet *p, Handler *h) {
+ 		dmux->recv(p, h);
+ 	}
+ 
+ 	void forwardPacket(Packet *, int = 0);
+ 	void init(void);
+ 	void trace(char* fmt, ...);
+ 	Packet* makeBeacon(void);
+ 	void sendBeacon(void);
+ 	void beaconIn(Packet *);
+ 
+ 	void handlePktForward(Packet *p);
+ 	
+ };
+ 
+ #endif	/* _DBR_H_ */
diff -crBN ns-2.35/dbr/pkt_cache.cc ns-2.35-aquasim/dbr/pkt_cache.cc
*** ns-2.35/dbr/pkt_cache.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/dbr/pkt_cache.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,102 ----
+ #include <stdio.h>
+ #include "pkt_cache.h"
+ 
+ // Constructor
+ PktCache::
+ PktCache()
+ {
+ 	int i;
+ 
+ 	max_size_ = 1500;
+ 	size_ = 0;
+ 
+ 	pcache_ = new PacketID [1500];
+ 
+ 	//for (i = 0; i < 100; i++)
+ 	//	pcache_[i] = new Packet;
+ }
+ 
+ PktCache::
+ ~PktCache()
+ {
+ 	int i;
+ 
+ 	//for (i = 0; i < max_size_; i++)
+ 	//	delete pcache_[i];
+ 
+ 	delete[] pcache_;
+ }
+ 
+ int
+ PktCache::
+ accessPacket(PacketID p)
+ {
+ 	int i, j;
+ 	PacketID tmp;
+ 	
+ 	for (i = 0; i < size_; i++) {
+ 		if (pcache_[i] == p) {
+ 			// if the pkt is existing
+ 			// put it to the tail 
+ 			tmp = p;
+ 			for (j = i; j < size_ - 1; j++)
+ 				pcache_[j] = pcache_[j+1];
+ 			pcache_[size_-1] = tmp;
+ 
+ 			return 1;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void
+ PktCache::
+ addPacket(PacketID p)
+ {
+ 	if (size_ == max_size_) {
+ 		printf("Cache is full!\n");
+ 		return;
+ 	}
+ 
+ 	pcache_[size_] = p;
+ 	size_++;
+ 
+ 	return;
+ }
+ 
+ void
+ PktCache::
+ deletePacket(PacketID p)
+ {
+ }
+ 
+ void
+ PktCache::
+ dump(void)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < size_; i++)
+ 		fprintf(stderr, "[%d]: %d\n", i, pcache_[i]);
+ }
+ 
+ #if 0
+ // test main function
+ int main(void)
+ {
+ 	PktCache pc;
+ 	Packet p1, p2, p3;
+ 
+ 	pc.addPacket(&p1);
+ 	pc.addPacket(&p2);
+ 	pc.addPacket(&p3);
+ 
+ 	pc.dump();
+ 
+ 	pc.accessPacket(&p1);
+ 	pc.dump();
+ 
+ 	return 0;
+ }
+ #endif
diff -crBN ns-2.35/dbr/pkt_cache.h ns-2.35-aquasim/dbr/pkt_cache.h
*** ns-2.35/dbr/pkt_cache.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/dbr/pkt_cache.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,29 ----
+ #ifndef	_PKT_CACHE_H_
+ #define	_PKT_CACHE_H_
+ 
+ #include <packet.h>
+ 
+ typedef	int	PacketID;
+ 
+ class PktCache
+ {
+ public:
+ 	PktCache();
+ 	~PktCache();
+ 
+ 	int& size(void)
+ 	{ return size_; }
+ 
+ 	int accessPacket(PacketID p);
+ 	void addPacket(PacketID p);
+ 	void deletePacket(PacketID p);
+ 	void dump(void);
+ 
+ private:
+ 	PacketID *pcache_;			// packet cache
+ 	int	size_;					// cache size
+ 	int max_size_;				// max cache size
+ };
+ 
+ #endif
+ 
diff -crBN ns-2.35/dbr/pkt_queue.h ns-2.35-aquasim/dbr/pkt_queue.h
*** ns-2.35/dbr/pkt_queue.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/dbr/pkt_queue.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,18 ----
+ #include <deque>
+ 
+ class PacketQueue {
+ public:
+ 	PacketQueue();
+ 	~PacketQueue();
+ 
+ 	bool empty() { return dq_.empty(); }
+ 	int size() { return dq_.size(); }
+ 
+ 	void pop() { dq_.pop_front(); ); 
+ 	Packet* front() { return dq_.front(); };
+ 	void push(Packet* p);
+ 
+ private:
+ 	deque<Packet*> dq_;
+ }
+ 
diff -crBN ns-2.35/dbr/README ns-2.35-aquasim/dbr/README
*** ns-2.35/dbr/README	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/dbr/README	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,10 ----
+ [02-13-2008 12:00PM]
+ common/packet.h
+ 	Add packet header 
+ tcl/lib/ns-lib.tcl
+ 	Add DBR agent 
+ 	Create create-dbr-agent proc
+ tcl/lib/ns-agent.tcl
+ 	Set UWSink agent command
+ trace/cmu-trace.cc
+ 	Add PT_DBR
diff -crBN ns-2.35/linkstate/ls.h ns-2.35-aquasim/linkstate/ls.h
*** ns-2.35/linkstate/ls.h	2010-03-08 13:54:51.000000000 +0800
--- ns-2.35-aquasim/linkstate/ls.h	2016-09-02 23:13:08.000000000 +0800
***************
*** 134,140 ****
  		return ib.second ? ib.first : baseMap::end();
  	}
  
! 	void eraseAll() { erase(baseMap::begin(), baseMap::end()); }
  	T* findPtr(Key key) {
  		iterator it = baseMap::find(key);
  		return (it == baseMap::end()) ? (T *)NULL : &((*it).second);
--- 134,140 ----
  		return ib.second ? ib.first : baseMap::end();
  	}
  
! 	void eraseAll() { this->erase(baseMap::begin(), baseMap::end()); }
  	T* findPtr(Key key) {
  		iterator it = baseMap::find(key);
  		return (it == baseMap::end()) ? (T *)NULL : &((*it).second);
diff -crBN ns-2.35/mac/ll.cc ns-2.35-aquasim/mac/ll.cc
*** ns-2.35/mac/ll.cc	2010-03-08 13:54:51.000000000 +0800
--- ns-2.35-aquasim/mac/ll.cc	2016-09-02 23:25:38.000000000 +0800
***************
*** 199,208 ****
  			break;
  		}
  		/* Assuming arptable is present, send query */
! 		if (arptable_) {
  			tx = arptable_->arpresolve(dst, p, this);
  			break;
! 		}
  		//if (varp_) {
  		//tx = varp_->arpresolve(dst, p);
  		//break;
--- 199,211 ----
  			break;
  		}
  		/* Assuming arptable is present, send query */
! 		if (arptable_ && !ch->uw_flag()) {
  			tx = arptable_->arpresolve(dst, p, this);
  			break;
! 		} else {
!  			mac_->hdr_dst((char*)HDR_MAC(p), dst);
!  			break;
!  		}
  		//if (varp_) {
  		//tx = varp_->arpresolve(dst, p);
  		//break;
***************
*** 215,221 ****
  		int IPnh = (lanrouter_) ? lanrouter_->next_hop(p) : -1;
  		if (IPnh < 0)
  			mac_->hdr_dst((char*) HDR_MAC(p),macDA_);
! 		else if (varp_)
  			tx = varp_->arpresolve(IPnh, p);
  		else
  			mac_->hdr_dst((char*) HDR_MAC(p), IPnh);
--- 218,224 ----
  		int IPnh = (lanrouter_) ? lanrouter_->next_hop(p) : -1;
  		if (IPnh < 0)
  			mac_->hdr_dst((char*) HDR_MAC(p),macDA_);
! 		else if (varp_ && !ch->uw_flag())
  			tx = varp_->arpresolve(IPnh, p);
  		else
  			mac_->hdr_dst((char*) HDR_MAC(p), IPnh);
diff -crBN ns-2.35/Makefile.in ns-2.35-aquasim/Makefile.in
*** ns-2.35/Makefile.in	2011-10-24 00:29:54.000000000 +0800
--- ns-2.35-aquasim/Makefile.in	2016-09-02 23:27:21.000000000 +0800
***************
*** 333,338 ****
--- 333,365 ----
  	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
  	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
  	apps/pbc.o \
+     underwatersensor/uw_common/underwatersensornode.o \
+     underwatersensor/uw_common/uw_hash_table.o  \
+     underwatersensor/uw_common/uw_sink.o \
+     underwatersensor/uw_common/uw_sink_vbva.o  \
+     underwatersensor/uw_common/uw_poi_traffic.o \
+     underwatersensor/uw_routing/vectorbasedforward.o \
+     underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.o \
+     underwatersensor/uw_routing/uw_drouting/uw_drouting.o \
+     underwatersensor/uw_routing/uw_routing_buffer.o \
+     underwatersensor/uw_routing/vectorbasedvoidavoidance.o \
+     underwatersensor/uw_routing/static_routing/static_routing.o \
+     underwatersensor/uw_mac/underwaterpropagation.o  \
+     underwatersensor/uw_mac/underwaterchannel.o \
+     underwatersensor/uw_mac/underwaterphy.o  \
+     underwatersensor/uw_mac/underwatermac.o \
+     underwatersensor/uw_mac/broadcastmac.o \
+     underwatersensor/uw_mac/uwbuffer.o underwatersensor/uw_mac/rmac.o  \
+     underwatersensor/uw_mac/tmac.o \
+     underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.o underwatersensor/uw_mac/uwan-mac/uwan-mac.o \
+     underwatersensor/uw_mac/COPEMAC/copemac.o \
+     underwatersensor/uw_mac/FAMA/fama.o \
+     underwatersensor/uw_mac/slotted-fama/sfama.o \
+     underwatersensor/uw_mac/uwaloha/uwaloha.o \
+     underwatersensor/uw_mobility_pattern/uw_mobility_pattern.o \
+     underwatersensor/uw_mobility_pattern/uw_mobility_rwp.o \
+     underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.o \
+     dbr/dbr.o dbr/pkt_cache.o \
  	@V_STLOBJ@
  
  
***************
*** 524,529 ****
--- 551,557 ----
  	tcl/lib/ns-srcrt.tcl \
  	tcl/mcast/ns-lms.tcl \
  	tcl/lib/ns-qsnode.tcl \
+ 	tcl/lib/ns-underwatersensornode.tcl \
  	@V_NS_TCL_LIB_STL@
  
  $(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
diff -crBN ns-2.35/mobile/god.cc ns-2.35-aquasim/mobile/god.cc
*** ns-2.35/mobile/god.cc	2006-12-27 22:57:23.000000000 +0800
--- ns-2.35-aquasim/mobile/god.cc	2016-09-02 23:33:36.000000000 +0800
***************
*** 88,93 ****
--- 88,95 ----
  	num_send = 0;
  	active = false;
  	allowTostop = false;
+ 	// added by norbert
+ 	strcpy(f_name,"test.data");
  }
  
  
***************
*** 515,520 ****
--- 517,542 ----
  
  }
  
+ //added by  peng xie
+ double God::ConsumpedEnergy()
+ {
+ 	int i;
+ 	double sum=0.0;
+ 	FILE * fp;
+ 	if ((fp=fopen(f_name,"a"))==NULL){
+ 		printf("god can not open file\n");
+ 		return -1;
+ 	}
+ 	for (i=0; i<num_nodes; i++) {
+ 		if(!mb_node[i])printf("node pointer is null\n");
+ 		double s1=mb_node[i]->energy_model()->initialenergy();
+ 		double s2=mb_node[i]->energy_model()->energy();
+ 		sum=sum+(s1-s2);
+ 	}
+ 	fprintf(fp,"God : consumped_energy = %f\n", sum);
+ 	fclose(fp);
+ 	return sum;
+ }
  
  bool God::ExistSource()
  {
***************
*** 821,827 ****
  		  ComputeRoute();
  		  return TCL_OK;
  		}
! 
                  if(strcmp(argv[1], "dump") == 0) {
  		        Dump();
                          return TCL_OK;
--- 843,853 ----
  		  ComputeRoute();
  		  return TCL_OK;
  		}
! 		if(strcmp(argv[1], "compute_energy") == 0) {
! 			double s2=ConsumpedEnergy();
! 			printf("god: the energy consumped is %f\n",s2);
! 			return TCL_OK;
! 		}
                  if(strcmp(argv[1], "dump") == 0) {
  		        Dump();
                          return TCL_OK;
***************
*** 895,901 ****
  		  }
  		  return TCL_OK;
  	        }
! 
  	        if (strcasecmp(argv[1], "is_on_trees") == 0) {
  		  int node_id = atoi(argv[2]);
  
--- 921,932 ----
  		  }
  		  return TCL_OK;
  	        }
! 		if (strcasecmp(argv[1], "set_filename") == 0) {
! 			printf("GOD: the old file name is%s\n",f_name);
! 			strcpy(f_name,argv[2]);
! 			printf("GOD: the new file name is%s\n",f_name);
!  		  	return TCL_OK;
!  	        }
  	        if (strcasecmp(argv[1], "is_on_trees") == 0) {
  		  int node_id = atoi(argv[2]);
  
***************
*** 997,1002 ****
--- 1028,1044 ----
  
  	    return TCL_OK;
  	  }
+ 	 // added by Peng Xie to return the minimum num of hops between n1 and n2, -1 if there is no path between n1 and n2
+  	  if (strcasecmp(argv[1], "get_number_of_hop") == 0) {
+  			int n1 = atoi(argv[2]);
+  			int n2 = atoi(argv[3]);
+  		   	printf("ok, the n1=%d and n2=%d hop=%d\n",n1,n2,MIN_HOPS(n1,n2));
+  			if(MIN_HOPS(n1,n2)!=INFINITY) 
+  				tcl.resultf("%d",MIN_HOPS(n1,n2));
+  			else 
+  				tcl.resultf("%d",-1);
+  			return TCL_OK;
+  	  }
  
  
  	  // We can add source from tcl script or call AddSource directly.
diff -crBN ns-2.35/mobile/god.h ns-2.35-aquasim/mobile/god.h
*** ns-2.35/mobile/god.h	2006-02-21 23:20:19.000000000 +0800
--- ns-2.35-aquasim/mobile/god.h	2016-09-02 23:34:17.000000000 +0800
***************
*** 52,57 ****
--- 52,58 ----
  
  #include "node.h"
  #include "diffusion/hash_table.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
  
  
  // Added by Chalermek  12/1/99
***************
*** 154,160 ****
          int  *sink_table;
          int  *num_send;            // for each data type
          Data_Hash_Table dtab;
! 
          void DumpNodeStatus();
          void DumpNumSend();
          void CountNewData(int *attr);
--- 155,163 ----
          int  *sink_table;
          int  *num_send;            // for each data type
          Data_Hash_Table dtab;
!         
! 	char f_name[80];// added by peng xie to define the filename
! 	double ConsumpedEnergy(); // add by peng xie to compute energy consumped
          void DumpNodeStatus();
          void DumpNumSend();
          void CountNewData(int *attr);
diff -crBN ns-2.35/mobile/propagation.h ns-2.35-aquasim/mobile/propagation.h
*** ns-2.35/mobile/propagation.h	2005-02-04 04:15:00.000000000 +0800
--- ns-2.35-aquasim/mobile/propagation.h	2016-09-02 23:34:51.000000000 +0800
***************
*** 41,47 ****
  #define ns_propagation_h
  
  #define SPEED_OF_LIGHT	300000000		// 3 * 10^8 m/s
! #define PI		3.1415926535897
  
  
  #include <topography.h>
--- 41,49 ----
  #define ns_propagation_h
  
  #define SPEED_OF_LIGHT	300000000		// 3 * 10^8 m/s
! #ifndef PI
!  	#define PI		3.1415926535897
! #endif
  
  
  #include <topography.h>
diff -crBN ns-2.35/mobile/topography.cc ns-2.35-aquasim/mobile/topography.cc
*** ns-2.35/mobile/topography.cc	2003-12-24 01:36:34.000000000 +0800
--- ns-2.35-aquasim/mobile/topography.cc	2016-09-03 00:32:11.664000000 +0800
***************
*** 83,88 ****
--- 83,102 ----
  	return 0;
  }
  
+ //added by Peng Xie
+  
+ int
+ Topography::load_cubicgrid(int x, int y,int z, int res)
+ {
+  	/* No Reason to malloc a grid */
+  
+  	grid_resolution = res;	// default is 1 meter
+  	maxX = (double) x;
+  	maxY = (double) y;
+        maxZ = (double) z; 
+  	return 0;
+ }
+ 
  
  int
  Topography::load_demfile(const char *fname)
***************
*** 165,171 ****
  			if(load_flatgrid(atoi(argv[2]), atoi(argv[3]), atoi(argv[4])))
  				return TCL_ERROR;
  			return TCL_OK;
! 		}
! 	}
  	return TclObject::command(argc, argv);
  }
--- 179,195 ----
  			if(load_flatgrid(atoi(argv[2]), atoi(argv[3]), atoi(argv[4])))
  				return TCL_ERROR;
  			return TCL_OK;
! 		} else if(strcmp(argv[1], "load_cubicgrid") == 0) {
!  			if(load_cubicgrid(atoi(argv[2]), atoi(argv[3]),atoi(argv[4])))
!  				return TCL_ERROR;
!  			return TCL_OK;
!  		}
!  	} else if(argc == 6) {
!  		if(strcmp(argv[1], "load_cubicgrid") == 0) {
!  			if(load_cubicgrid(atoi(argv[2]), atoi(argv[3]), atoi(argv[4]),atoi(argv[5])))
!  		      	return TCL_ERROR;
!  			return TCL_OK;
!  		}
!   	}
  	return TclObject::command(argc, argv);
  }
diff -crBN ns-2.35/mobile/topography.h ns-2.35-aquasim/mobile/topography.h
*** ns-2.35/mobile/topography.h	2003-12-24 01:36:34.000000000 +0800
--- ns-2.35-aquasim/mobile/topography.h	2016-09-02 23:38:05.000000000 +0800
***************
*** 46,52 ****
  class Topography : public TclObject {
  
  public:
! 	Topography() { maxX = maxY = grid_resolution = 0.0; grid = 0; }
  
  	/* List-keeper */
  	void updateNodesList(class MobileNode *mn, double oldX);
--- 46,52 ----
  class Topography : public TclObject {
  
  public:
! 	Topography() { maxX = maxY = maxZ = grid_resolution = 0.0; grid = 0; }
  
  	/* List-keeper */
  	void updateNodesList(class MobileNode *mn, double oldX);
***************
*** 55,70 ****
--- 55,74 ----
  	double	upperX() { return maxX * grid_resolution; }
  	double	lowerY() { return 0.0; }
  	double	upperY() { return maxY * grid_resolution; }
+  	double	lowerZ() { return 0.0; }
+  	double	upperZ() { return maxZ * grid_resolution; }
  	double	resol() { return grid_resolution; }
  	double	height(double x, double y);
  
  private:
  	virtual int command(int argc, const char*const* argv);
  	int	load_flatgrid(int x, int y, int res = 1);
+ 	int	load_cubicgrid(int x, int y, int z,int res = 1);
  	int	load_demfile(const char *fname);
  
  	double	maxX;
  	double	maxY;
+ 	double  maxZ;// added by Peng Xie
  
  	double	grid_resolution;
  	int*	grid;
diff -crBN ns-2.35/sillyrouting/sillyrouting.cc ns-2.35-aquasim/sillyrouting/sillyrouting.cc
*** ns-2.35/sillyrouting/sillyrouting.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/sillyrouting/sillyrouting.cc	2012-01-31 23:53:14.000000000 +0800
***************
*** 0 ****
--- 1,147 ----
+ #include "sillyrouting.h"
+ 
+ 
+ 
+ static class SillyRoutingClass: public TclClass
+ {
+ public:
+ 	SillyRoutingClass():TclClass("Agent/SillyRouting"){}
+ 	TclObject *create(int argc, const char* const* argv)
+ 	{
+ 		return (new SillyRouting());
+ 	}
+ }class_sillyrouting;
+ 
+ 
+ 
+ SillyRouting::SillyRouting():Agent(PT_UWVB)
+ {
+ }
+ 
+ 
+ int SillyRouting::command(int argc, const char* const*argv)
+ {
+ 		if( argc== 2 )
+ 		{
+ 			if( strcasecmp(argv[1], "start") == 0 )
+ 			{
+ 				return TCL_OK;
+ 			}
+ 	
+ 		}
+ 		else if( argc==3 )
+ 		{
+ 			if (strcasecmp (argv[1], "addr") == 0) {
+ 	 			int temp;
+ 	 			temp = Address::instance().str2addr(argv[2]);
+ 	 			myaddr_ = temp;
+ 	 			return TCL_OK;
+       		}
+ 
+ 			TclObject *obj;
+ 			if ((obj = TclObject::lookup (argv[2])) == 0)
+ 				return TCL_ERROR;
+ 	
+ 			if (strcasecmp (argv[1], "tracetarget") == 0)
+ 			{
+ 				tracetarget = (Trace *) obj;
+ 				return TCL_OK;
+ 			}
+ 			
+ 			if (strcasecmp(argv[1], "add-ll") == 0) {
+ 				ll_ = (NsObject *) obj;
+ 				return TCL_OK;
+ 			}
+ 			
+ 			if (strcasecmp(argv[1], "on-node")==0) {
+ 				//   printf ("inside on node\n");
+ 				node = (UnderwaterSensorNode *)obj;
+ 				return TCL_OK;
+ 			}
+ 			
+ 			if (strcasecmp (argv[1], "node") == 0)
+ 			{
+ 				node_ = (MobileNode*) obj;
+ 				return TCL_OK;
+ 			}
+ 			
+ 			if (strcasecmp (argv[1], "port-dmux") == 0)
+ 			{
+ 				dmux_ = (PortClassifier*) obj;
+ 				return TCL_OK;
+ 			}
+ 		}
+ 	
+ 		return Agent::command( argc, argv);
+ 
+ }
+ 
+ 
+ 
+ void SillyRouting::recv(Packet* p, Handler* h)
+ {
+ 	hdr_cmn* cmh = HDR_CMN(p);
+ 	hdr_ip*  iph = HDR_IP(p);
+ 
+ 
+ 	if( iph->saddr() == myaddr_ ) {
+ 		if(cmh->num_forwards() > 0 ) {
+ 			//if there exists a loop, must drop the packet
+ 			drop(p, DROP_RTR_ROUTE_LOOP);
+ 			return;
+ 		}
+ 		else{
+ 			cmh->direction() = hdr_cmn::DOWN;
+ 			cmh->addr_type_ = NS_AF_INET;
+ 		}
+     }
+ 	cmh->num_forwards()++;
+ 
+ 	if( cmh->direction() == hdr_cmn::UP && 
+ 		(iph->daddr() == myaddr_ || iph->daddr()==(nsaddr_t)IP_BROADCAST ) ) {
+ 		dmux_->recv(p, (Handler*)0);
+ 	}
+ 	else {
+ 		cmh->direction() = hdr_cmn::DOWN;
+ 		cmh->addr_type_ = NS_AF_INET;
+ 		//send to ll layer directly to avoid ARP
+ 		ll_->recv(p);
+ 		//Scheduler::instance().schedule(ll_, p, 0.0);
+ 		//Scheduler::instance().schedule(target_, p, 0.0);	
+ 	}
+ 
+ 	return;
+ /*	if( cmh->direction() == hdr_cmn::UP &&
+         (iph->daddr()== myaddr_ || iph->daddr()==(nsaddr_t)IP_BROADCAST) )
+     {
+         dmux_->recv(p, (Handler*)0);
+         return;
+     }
+ */
+ 
+ 	//forward the pkt
+ 	/*
+ 	if( iph->daddr() == (nsaddr_t)IP_BROADCAST &&
+ 			iph->saddr() == myaddr_ )
+ 	{
+ 		cmh->next_hop() = IP_BROADCAST;
+ 		cmh->direction() = hdr_cmn::DOWN;
+ 		cmh->addr_type_ = NS_AF_INET;
+ 		Scheduler::instance().schedule( target_, p, BROAD_JITTER);
+ 		return;
+ 	}
+ 	*/
+ /*
+ 	//forward
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->addr_type_ = NS_AF_INET;
+ 	if( (u_int32_t)iph->daddr() == IP_BROADCAST )
+ 		cmh->next_hop() = IP_BROADCAST;
+ 	else
+ 		cmh->next_hop() = myaddr_-1;
+ 	Scheduler::instance().schedule(target_, p, 0.0);
+ */
+ }
+ 
+ 
+ 
diff -crBN ns-2.35/sillyrouting/sillyrouting.h ns-2.35-aquasim/sillyrouting/sillyrouting.h
*** ns-2.35/sillyrouting/sillyrouting.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/sillyrouting/sillyrouting.h	2012-01-31 23:53:14.000000000 +0800
***************
*** 0 ****
--- 1,52 ----
+ #ifndef __SILLYROUTING_H__
+ #define __SILLYROUTING_H__
+ 
+ #include <agent.h>
+ #include <packet.h>
+ #include <trace.h>
+ #include <random.h>
+ #include <classifier-port.h>
+ #include <address.h>
+ 
+ #include "config.h"
+ #include "scheduler.h"
+ #include "ip.h"
+ #include "queue.h"
+ #include "connector.h"
+ #include "cmu-trace.h"
+ #include "delay.h"
+ #include "arp.h"
+ #include "ll.h"
+ #include "mac.h"
+ #include "mobilenode.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "strings.h"
+ 
+ 
+ #ifndef BROAD_JITTER
+ #define BROAD_JITTER (Random::uniform()*0.25)
+ #endif
+ 
+ #ifndef ROUTER_PORT
+ #define ROUTER_PORT 255
+ #endif
+ 
+ 
+ class SillyRouting: public Agent{
+ private:
+ 	nsaddr_t	myaddr_;
+ protected:
+ 	PortClassifier* dmux_;	
+ 	Trace*			tracetarget;
+ 	MobileNode*     node_;
+ 	UnderwaterSensorNode* node;
+ 	NsObject*		ll_;
+ public:
+ 	SillyRouting();
+ 	int command(int, const char* const*);
+ 	void recv(Packet*, Handler*);
+ };
+ 
+ #endif 
+ 
+ 
diff -crBN ns-2.35/tcl/lib/ns-agent.tcl ns-2.35-aquasim/tcl/lib/ns-agent.tcl
*** ns-2.35/tcl/lib/ns-agent.tcl	2009-01-15 14:23:49.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-agent.tcl	2016-09-02 23:41:45.000000000 +0800
***************
*** 137,142 ****
--- 137,204 ----
  	$self ctrl-target [$tbf target]
  }
  
+ #add by Peng Xie
+  
+ Agent/UWSink instproc attach-vectorbasedforward {w1} {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   $rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   $rt set width $w1
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   #set demux [$node_ demux_]
+   #puts " [$entrance defaulttarget]"
+   #$rt  name
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+  
+ Agent/UWSink instproc attach-uwflooding { } {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   $rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+  
+ Agent/UWSink instproc attach-routing { } {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   #$rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+  
+ Agent/UW_VBVA_Sink instproc attach-routing { } {
+   $self instvar node_
+   set rt [$node_ set ragent_]
+   $rt on-node $node_
+   $self on-node $node_
+   #puts " Agent/UWsink:[$self set agent_port_]"
+   #set port [$self set agent_port_]
+   $rt port-dmux $self
+   #$rt set-port [$self set agent_port_]
+   set entrance [$node_  entry]
+   $self attach-rt-agent $entrance
+   #$self attach-rt-agent $rt
+ }
+ 
  #
  # A lot of agents want to store the maxttl locally.  However,
  # setting a class variable based on the Agent::ttl_ variable
diff -crBN ns-2.35/tcl/lib/ns-default.tcl ns-2.35-aquasim/tcl/lib/ns-default.tcl
*** ns-2.35/tcl/lib/ns-default.tcl	2010-07-04 06:45:45.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-default.tcl	2016-09-02 23:45:43.000000000 +0800
***************
*** 558,564 ****
  Node/MobileNode set Y_				0
  Node/MobileNode set Z_				0
  Node/MobileNode set speed_				0
! Node/MobileNode set position_update_interval_	0
  Node/MobileNode set bandwidth_			0	;# not used
  Node/MobileNode set delay_				0	;# not used
  Node/MobileNode set REGAGENT_PORT 0
--- 558,564 ----
  Node/MobileNode set Y_				0
  Node/MobileNode set Z_				0
  Node/MobileNode set speed_				0
! Node/MobileNode set position_update_interval_	1.0
  Node/MobileNode set bandwidth_			0	;# not used
  Node/MobileNode set delay_				0	;# not used
  Node/MobileNode set REGAGENT_PORT 0
***************
*** 1590,1592 ****
--- 1590,1689 ----
  
  Agent/MDART set macFailed_ true
  Agent/MDART set etxMetric_ true
+ 
+ Application/Traffic/UW_POI set maxpkts_ -1 ;# infinity
+ Application/Traffic/UW_POI set data_rate_ -1 ;# for checking error purpose
+ Application/Traffic/UW_POI set packetSize_ -1 ;# same as data_rate
+ # The following is added by Peng Xie
+ Node/MobileNode/UnderwaterSensorNode set  sinkStatus_ 0 
+ Node/MobileNode/UnderwaterSensorNode  set max_speed   0  
+ Node/MobileNode/UnderwaterSensorNode set min_speed    0  
+ Node/MobileNode/UnderwaterSensorNode set position_update_interval_  1.0 
+ Node/MobileNode/UnderwaterSensorNode set max_thought_time_ 3.0
+ 
+ #added by Peng Xie
+ Mac/UnderwaterMac/BroadcastMac set packetheader_size_ 8 ;# 40 bytes
+ Mac/UnderwaterMac/BroadcastMac set packet_size_ 0 ;# 
+ Mac/UnderwaterMac/RMac set PhaseOne_window_  3 ;# 2 second
+ Mac/UnderwaterMac/RMac set ND_window_  1 ;# 1 second
+ Mac/UnderwaterMac/RMac set ACKND_window_  1.5 ;# 1.5 second
+ Mac/UnderwaterMac/RMac set PhyOverhead_  8 ;# 8 bits 
+ Mac/UnderwaterMac/RMac set PhyOne_cycle_  1 ;# 8 bits 
+ Mac/UnderwaterMac/RMac set large_packet_size_  80   ;# 10 bytes 
+ Mac/UnderwaterMac/RMac set short_packet_size_  480  ;# 60 bytes
+ Mac/UnderwaterMac/RMac set IntervalPhase2Phase3 1  ;# 60 bytes
+ Mac/UnderwaterMac/RMac set PhaseTwo_window_  1
+ Mac/UnderwaterMac/RMac set duration_  0.1
+ Mac/UnderwaterMac/RMac set PeriodInterval_  1
+ Mac/UnderwaterMac/RMac set SIF_  0.00001
+ Mac/UnderwaterMac/RMac set ACKRevInterval_  0.08  
+ Mac/UnderwaterMac/TMac set PhaseOne_window_  3 ;# 2 second
+ Mac/UnderwaterMac/TMac set ND_window_  1 ;# 1 second
+ Mac/UnderwaterMac/TMac set ACKND_window_  1.5 ;# 1.5 second
+ Mac/UnderwaterMac/TMac set PhyOverhead_  8 ;# 8 bits 
+ Mac/UnderwaterMac/TMac set PhyOne_cycle_  1 ;# 8 bits 
+ Mac/UnderwaterMac/TMac set large_packet_size_  80   ;# 10 bytes 
+ Mac/UnderwaterMac/TMac set short_packet_size_  480  ;# 60 bytes
+ Mac/UnderwaterMac/TMac set IntervalPhase2Phase3 1  ;# 60 bytes
+ Mac/UnderwaterMac/TMac set PhaseTwo_window_  1
+ Mac/UnderwaterMac/TMac set duration_  0.1
+ Mac/UnderwaterMac/TMac set PeriodInterval_  1
+ Mac/UnderwaterMac/TMac set SIF_  0.00001
+ #Mac/UnderwaterMac/TMac set ACKRevInterval_  0.08  
+ Mac/UnderwaterMac/TMac set transmission_time_error_  0.001
+ Mac/UnderwaterMac/TMac set ContentionWindow_  0.1
+ Mac/UnderwaterMac/TMac set TransmissionRange_ 90
+ Mac/UnderwaterMac/UWANMac set AvgCyclePeriod 10
+ Mac/UnderwaterMac/UWANMac set StdCyclePeriod 1
+ Mac/UnderwaterMac/OTMAN set NDInterval 3
+ Mac/UnderwaterMac/OTMAN set DataAccuPeriod 1
+ Mac/UnderwaterMac/OTMAN set RevAckAccumTime 1
+ Mac/UnderwaterMac/OTMAN set DataAckAccumTime 1
+ Mac/UnderwaterMac/OTMAN set MajorBackupInterval 0.5
+ Mac/UnderwaterMac/OTMAN set MajorIntervalLB 2
+ Mac/UnderwaterMac/OTMAN set MajorIntervalUB 3
+ Mac/UnderwaterMac/OTMAN set GuardTime 0.01
+ Mac/UnderwaterMac/OTMAN set isParallel 1
+ 
+ Mac/UnderwaterMac/FAMA set MaxBurst 1
+ 
+ #Mac/UnderwaterMac/SFAMA set max_burst_ 1
+ #Mac/UnderwaterMac/SFAMA set guard_time_ 0.00001
+ #Mac/UnderwaterMac/SFAMA set max_backoff_slots_ 4
+ 
+ #added by peng xie
+ Phy/UnderwaterPhy set CPThresh_ 10.0
+ Phy/UnderwaterPhy set CSThresh_ 1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 3.652e-10
+ #Phy/UnderwaterPhy set bandwidth_ 2e6
+ Phy/UnderwaterPhy set Pt_ 0.28183815
+ Phy/UnderwaterPhy set freq_ 914e+6
+ Phy/UnderwaterPhy set L_ 1.0  
+ Phy/UnderwaterPhy set debug_ false
+ Phy/UnderwaterPhy set K_ 1.5
+ Phy/UnderwaterPhy set TurnOnEnergy 0.0
+ Phy/UnderwaterPhy set TurnOffEnergy 0.0
+ Phy/UnderwaterPhy set sync_hdr_len  0.0
+ Phy/UnderwaterPhy set fowarding_delay 0.0
+ Phy/UnderwaterPhy set bit_error_rate 0.0
+ 
+ #added by Peng Xie 
+ Agent/UWSink set data_rate_ 1.0 
+ Agent/UWSink set packetsize_ 50 ;#bytes
+ Agent/UWSink set random_ 0 
+ Agent/UWSink set passive 0 
+ Agent/UWSink set ActiveSense 0
+ Agent/UWSink set SenseInterval 30
+ #Agent/UWSink set activate_vbf  1
+ Agent/UW_VBVA_Sink set data_rate_ 1.0 
+ Agent/UW_VBVA_Sink set packetsize_ 50 ;#bytes
+ Agent/UW_VBVA_Sink set random_ 0 
+ Agent/UW_VBVA_Sink set passive 0 
+ Agent/Vectorbasedforward set width 100
+ Agent/Vectorbasedforward set control_packet_size 20
+ Agent/Vectorbasedforward set hop_by_hop_ 0
+ Agent/Vectorbasedforward set EnableRouting 1 
+ Agent/VectorbasedVoidAvoidance set width 100
+ Agent/VectorbasedVoidAvoidance set  control_packet_size 20  
+ Agent/uw_drouting set accessible_var_ true
+ 
diff -crBN ns-2.35/tcl/lib/ns-lib.tcl ns-2.35-aquasim/tcl/lib/ns-lib.tcl
*** ns-2.35/tcl/lib/ns-lib.tcl	2010-05-10 06:28:41.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-lib.tcl	2016-09-03 01:00:47.056000000 +0800
***************
*** 137,142 ****
--- 137,143 ----
  source ns-rtmodule.tcl
  source ns-hiernode.tcl
  source ns-mobilenode.tcl
+ source ns-underwatersensornode.tcl
  source ns-bsnode.tcl
  source ns-link.tcl
  source ns-source.tcl
***************
*** 624,629 ****
--- 625,633 ----
  		    DSDV {
  			    set ragent [$self create-dsdv-agent $node]
  		    }
+ 		    SillyRouting {
+ 			    set ragent [$self create-sillyrouting-agent $node]
+ 		    }
  		    DSR {
  			    $self at 0.0 "$node start-dsr"
  		    }
***************
*** 643,648 ****
--- 647,670 ----
  			    Simulator set IMEPFlag_ ON
  			    set ragent [$self create-tora-agent $node]
  		    }
+ 		    StaticRouting {
+ 			    set ragent [$self creat-staticrouting-agent $node] 
+ 		    }
+ 		    DBR { 
+ 		   	    set ragent [$self create-dbr-agent $node]
+ 	   	    }
+ 		    Vectorbasedforward {
+ 			set ragent [$self create-vectorbasedforward-agent $node]
+ 		    }
+ 	    	    VectorbasedVoidAvoidance {
+ 			set ragent [$self create-vectorbasedvoidavoidance-agent $node]
+ 		    }
+ 		    UWFlooding {
+ 			set ragent [$self create-uwflooding-agent $node]
+ 		    }
+ 		    uw_drouting {
+ 			set ragent [$self create-uw_drouting-agent $node]             
+ 		    }
  		    DIFFUSION/RATE {
  			    eval $node addr $args
  			    set ragent [$self create-diffusion-rate-agent $node]
***************
*** 703,709 ****
              $routingAgent_ == "DIFFUSION/PROB" ||
              $routingAgent_ == "FLOODING" ||
              $routingAgent_ == "OMNIMCAST" ||
! 	    $routingAgent_ == "Directed_Diffusion" } {
  		$ragent port-dmux [$node demux]
  		$node instvar ll_
  		$ragent add-ll $ll_(0)
--- 725,736 ----
              $routingAgent_ == "DIFFUSION/PROB" ||
              $routingAgent_ == "FLOODING" ||
              $routingAgent_ == "OMNIMCAST" ||
! 	    $routingAgent_ == "Directed_Diffusion" ||
! 	    $routingAgent_ == "DBR"|| 
! 	    $routingAgent_ == "Vectorbasedforward"||
! 	    $routingAgent_ == "VectorbasedVoidAvoidance"||
! 	    $routingAgent_ == "UWFlooding" ||
! 	    $routingAgent_ == "StaticRouting" } {
  		$ragent port-dmux [$node demux]
  		$node instvar ll_
  		$ragent add-ll $ll_(0)
***************
*** 776,787 ****
  }
  
  Simulator instproc create-node-instance args {
! 	$self instvar routingAgent_
  	# DSR is a special case
  	if {$routingAgent_ == "DSR"} {
  		set nodeclass [$self set-dsr-nodetype]
  	} else {
! 		set nodeclass Node/MobileNode
  	}
  	return [eval new $nodeclass $args]
  }
--- 803,821 ----
  }
  
  Simulator instproc create-node-instance args {
! 	$self instvar routingAgent_ propType_
  	# DSR is a special case
  	if {$routingAgent_ == "DSR"} {
  		set nodeclass [$self set-dsr-nodetype]
  	} else {
! 		#added by Peng Xie to create underwater sensor node 
! 		if {$propType_ == "Propagation/UnderwaterPropagation"} {
! 			# puts "propagation type is $propType_"
! 			set nodeclass Node/MobileNode/UnderwaterSensorNode
! 			# puts "after create the underwatersensor node..."
! 		} else { 
! 			set nodeclass Node/MobileNode
! 		}
  	}
  	return [eval new $nodeclass $args]
  }
***************
*** 824,829 ****
--- 858,934 ----
  }
  
  
+ Simulator instproc create-sillyrouting-agent { node } {
+ 	set ragent [new Agent/SillyRouting]
+ 	set addr [$node node-addr]
+ 	$ragent node $node
+ 	$ragent addr $addr
+ 
+ 	$node set ragent_ $ragent
+ 	return $ragent
+ }
+ 
+ # dbr @ hai
+ Simulator instproc create-dbr-agent { node } {
+ 	set ragent [new Agent/DBR]
+ 	$ragent node $node
+ 	$ragent start-dbr
+ 	$node set ragent_ $ragent
+ 	return $ragent
+ }
+ 
+ 
+ Simulator instproc creat-staticrouting-agent { node } {
+ 	set ragent [new Agent/StaticRouting]
+ 	set addr [$node node-addr]
+ 	$ragent node $node
+ 	$ragent addr $addr
+ 
+ 	$node set ragent_ $ragent
+ 	return $ragent
+ 
+ }
+ 
+ 
+ Simulator instproc create-vectorbasedforward-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/Vectorbasedforward]
+ 	# puts " I am in create vb before assign a ragent"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
+ Simulator instproc create-vectorbasedvoidavoidance-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/VectorbasedVoidAvoidance]
+ 	# puts " I am in create vb before assign a ragent"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
+ 
+ 
+ Simulator instproc create-uwflooding-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/UWFlooding]
+ 	# puts " I am in create vb before assign a ragent"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
+ Simulator instproc create-uw_drouting-agent { node } {
+ #        puts " I am in create vb"
+ 	set ragent [new Agent/uw_drouting [$node node-addr]]
+ 	# puts " I am in create vb before assign a ragent"
+        $self at 0.0 "$ragent start"
+         $node set ragent_ $ragent
+ 	#puts " I am in create vb after ragent $ragent"
+         return $ragent
+ }
+ 
  Simulator instproc create-dumb-agent { node } {
  	
  	# create a simple wireless agent
diff -crBN ns-2.35/tcl/lib/ns-packet.tcl ns-2.35-aquasim/tcl/lib/ns-packet.tcl
*** ns-2.35/tcl/lib/ns-packet.tcl	2011-10-15 06:11:08.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-packet.tcl	2016-09-02 23:54:49.000000000 +0800
***************
*** 176,181 ****
--- 176,191 ----
          MIP 	# Mobile IP, mobile/mip-reg.cc
  	Smac 	# Sensor-MAC
  	TORA 	# routing protocol for ad-hoc networks
+ 	UWVB      #underwatersensor
+ 	UWVBVA
+         uw_drouting
+ 	RMAC     
+ 	TMAC
+     	SFAMA
+ 	StaticRouting
+ 	UWANMac
+ 	OTMAN
+ 	UW_ALOHA
  	MDART 	# routing protocol for ad-hoc networks
  	# AOMDV patch
  	AOMDV
diff -crBN ns-2.35/tcl/lib/ns-underwatersensornode.tcl ns-2.35-aquasim/tcl/lib/ns-underwatersensornode.tcl
*** ns-2.35/tcl/lib/ns-underwatersensornode.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/tcl/lib/ns-underwatersensornode.tcl	2012-01-31 23:53:09.000000000 +0800
***************
*** 0 ****
--- 1,273 ----
+ # This program is copied from ns-mobilenode.tcl. I modified part of codes 
+ #specially for underwater sensor node
+ 
+ 
+ # The following setups up link layer, mac layer, network interface
+ # and physical layer structures for the mobile node.
+ #
+ Node/MobileNode/UnderwaterSensorNode instproc add-interface { channel pmodel lltype mactype \
+ 		qtype qlen iftype anttype topo inerrproc outerrproc fecproc} {
+ 	$self instvar arptable_ nifs_ netif_ mac_ ifq_ ll_ imep_ inerr_ outerr_ fec_
+ 	
+ 	set ns [Simulator instance]
+ 	set imepflag [$ns imep-support]
+ 	set t $nifs_
+ 	incr nifs_
+ 
+ 	set netif_($t)	[new $iftype]		;# interface
+ 	set mac_($t)	[new $mactype]		;# mac layer
+ 	set ifq_($t)	[new $qtype]		;# interface queue
+ 	set ll_($t)	[new $lltype]		;# link layer
+         set ant_($t)    [new $anttype]
+        
+ 
+         # puts "this is a underwater sensor node"
+ 	$ns mac-type $mactype
+ 	set inerr_($t) ""
+ 	if {$inerrproc != ""} {
+ 		set inerr_($t) [$inerrproc]
+ 	}
+ 	set outerr_($t) ""
+ 	if {$outerrproc != ""} {
+ 		set outerr_($t) [$outerrproc]
+ 	}
+ 	set fec_($t) ""
+ 	if {$fecproc != ""} {
+ 		set fec_($t) [$fecproc]
+ 	}
+ 
+ 	set namfp [$ns get-nam-traceall]
+         if {$imepflag == "ON" } {              
+ 		# IMEP layer
+ 		set imep_($t) [new Agent/IMEP [$self id]]
+ 		set imep $imep_($t)
+ 		set drpT [$self mobility-trace Drop "RTR"]
+ 		if { $namfp != "" } {
+ 			$drpT namattach $namfp
+ 		}
+ 		$imep drop-target $drpT
+ 		$ns at 0.[$self id] "$imep_($t) start"   ;# start beacon timer
+         }
+ 	#
+ 	# Local Variables
+ 	#
+ 	set nullAgent_ [$ns set nullAgent_]
+ 	set netif $netif_($t)
+ 	set mac $mac_($t)
+ 	set ifq $ifq_($t)
+ 	set ll $ll_($t)
+ 
+ 	set inerr $inerr_($t)
+ 	set outerr $outerr_($t)
+ 	set fec $fec_($t)
+ 
+ 	#
+ 	# Initialize ARP table only once.
+ 	#
+ 	if { $arptable_ == "" } {
+ 		set arptable_ [new ARPTable $self $mac]
+ 		# FOR backward compatibility sake, hack only
+ 		if {$imepflag != ""} {
+ 			set drpT [$self mobility-trace Drop "IFQ"]
+ 		} else {
+ 			set drpT [cmu-trace Drop "IFQ" $self]
+ 		}
+ 		$arptable_ drop-target $drpT
+ 		if { $namfp != "" } {
+ 			$drpT namattach $namfp
+ 		}
+         }
+ 	#
+ 	# Link Layer
+ 	#
+ 	$ll arptable $arptable_
+ 	$ll mac $mac
+ 
+ 	$ll down-target $ifq
+ 
+ 	if {$imepflag == "ON" } {
+ 		$imep recvtarget [$self entry]
+ 		$imep sendtarget $ll
+ 		$ll up-target $imep
+         } else {
+ 		
+                 $ll up-target [$self entry]
+                 #puts "ns-mobile: setup uptarget..."
+                # puts "the uptarget is [$self enrty]" 	
+ }
+ 	#
+ 	# Interface Queue
+ 	#
+ 	$ifq target $mac
+ 	$ifq set limit_ $qlen
+ 	if {$imepflag != ""} {
+ 		set drpT [$self mobility-trace Drop "IFQ"]
+ 	} else {
+ 		set drpT [cmu-trace Drop "IFQ" $self]
+         }
+ 	$ifq drop-target $drpT
+ 	if { $namfp != "" } {
+ 		$drpT namattach $namfp
+ 	}
+ 	#
+ 	# Mac Layer
+ 	#
+ 
+ 
+ 	$mac netif $netif
+ 	$mac up-target $ll
+         
+ 
+         #added by Peng Xie       
+ 
+  #       puts "before put on node\n"
+  
+           $mac node_on $self
+ 
+   #      puts "after put on node\n"
+ 
+ 	if {$outerr == "" && $fec == ""} {
+ 		$mac down-target $netif
+ 	} elseif {$outerr != "" && $fec == ""} {
+ 		$mac down-target $outerr
+ 		$outerr target $netif
+ 	} elseif {$outerr == "" && $fec != ""} {
+ 		$mac down-target $fec
+ 		$fec down-target $netif
+ 	} else {
+ 		$mac down-target $fec
+ 		$fec down-target $outerr
+ 		$err target $netif
+ 	}
+ 
+ 	set god_ [God instance]
+         if {$mactype == "Mac/802_11"} {
+ 		$mac nodes [$god_ num_nodes]
+ 	}
+        
+ 
+ 	#
+ 	# Network Interface
+ 	#
+ 	#if {$fec == ""} {
+         #		$netif up-target $mac
+ 	#} else {
+         #		$netif up-target $fec
+ 	#	$fec up-target $mac
+ 	#}
+ 
+ 	$netif channel $channel
+ 	if {$inerr == "" && $fec == ""} {
+ 		$netif up-target $mac
+ 	} elseif {$inerr != "" && $fec == ""} {
+ 		$netif up-target $inerr
+ 		$inerr target $mac
+ 	} elseif {$err == "" && $fec != ""} {
+ 		$netif up-target $fec
+ 		$fec up-target $mac
+ 	} else {
+ 		$netif up-target $inerr
+ 		$inerr target $fec
+ 		$fec up-target $mac
+ 	}
+ 
+ 	$netif propagation $pmodel	;# Propagation Model
+ 	$netif node $self		;# Bind node <---> interface
+ 
+        
+          #wireless phy doesn't need antenna anymore
+ 	 $netif antenna $ant_($t)
+         # puts " after put on antenna \n"   
+ 	#
+ 	# Physical Channel
+ 	#
+ 	$channel addif $netif
+ 	
+             
+ 
+         # List-based improvement
+ 	# For nodes talking to multiple channels this should
+ 	# be called multiple times for each channel
+ 	$channel add-node $self		
+ 
+ 	# let topo keep handle of channel
+ 	$topo channel $channel
+ 	# ============================================================
+ 
+ 	if { [Simulator set MacTrace_] == "ON" } {
+ 		#
+ 		# Trace RTS/CTS/ACK Packets
+ 		#
+ 		if {$imepflag != ""} {
+ 			set rcvT [$self mobility-trace Recv "MAC"]
+ 		} else {
+ 			set rcvT [cmu-trace Recv "MAC" $self]
+ 		}
+ 		$mac log-target $rcvT
+ 		if { $namfp != "" } {
+ 			$rcvT namattach $namfp
+ 		}
+ 		#
+ 		# Trace Sent Packets
+ 		#
+ 		if {$imepflag != ""} {
+ 			set sndT [$self mobility-trace Send "MAC"]
+ 		} else {
+ 			set sndT [cmu-trace Send "MAC" $self]
+ 		}
+ 		$sndT target [$mac down-target]
+ 		$mac down-target $sndT
+ 		if { $namfp != "" } {
+ 			$sndT namattach $namfp
+ 		}
+ 		#
+ 		# Trace Received Packets
+ 		#
+ 		if {$imepflag != ""} {
+ 			set rcvT [$self mobility-trace Recv "MAC"]
+ 		} else {
+ 			set rcvT [cmu-trace Recv "MAC" $self]
+ 		}
+ 		$rcvT target [$mac up-target]
+ 		$mac up-target $rcvT
+ 		if { $namfp != "" } {
+ 			$rcvT namattach $namfp
+ 		}
+ 		#
+ 		# Trace Dropped Packets
+ 		#
+ 		if {$imepflag != ""} {
+ 			set drpT [$self mobility-trace Drop "MAC"]
+ 		} else {
+ 			set drpT [cmu-trace Drop "MAC" $self]
+ 		}
+ 		$mac drop-target $drpT
+ 		if { $namfp != "" } {
+ 			$drpT namattach $namfp
+ 		}
+ 	} else {
+ 		$mac log-target [$ns set nullAgent_]
+ 		$mac drop-target [$ns set nullAgent_]
+ 	}
+ 
+ # change wrt Mike's code
+        if { [Simulator set EotTrace_] == "ON" } {
+                #
+                # Also trace end of transmission time for packets
+                #
+ 
+                if {$imepflag != ""} {
+                        set eotT [$self mobility-trace EOT "MAC"]
+                } else {
+                        set eoT [cmu-trace EOT "MAC" $self]
+                }
+                $mac eot-target $eotT
+        }
+ 
+ 
+ 
+ 	# ============================================================
+ 
+ 	$self addif $netif
+ }
+ 
diff -crBN ns-2.35/trace/cmu-trace.cc ns-2.35-aquasim/trace/cmu-trace.cc
*** ns-2.35/trace/cmu-trace.cc	2011-10-03 06:32:35.000000000 +0800
--- ns-2.35-aquasim/trace/cmu-trace.cc	2016-09-03 00:04:26.000000000 +0800
***************
*** 64,69 ****
--- 64,71 ----
  //</zheng: add for 802.15.4>
  
  #include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
+ #include "underwatersensor/uw_mac/underwaterchannel.h"
+ #include "underwatersensor/uw_mac/slotted-fama/sfama-pkt.h"
  
  
  PacketTracer::PacketTracer() : next_(0)
***************
*** 859,864 ****
--- 861,904 ----
  }
  
  void
+ CMUTrace::format_sfama(Packet* p, int offset)
+ {
+ 		hdr_SFAMA* SFAMAh = hdr_SFAMA::access(p);
+ 		
+ 		char packet_name[50];
+ 		
+ 		switch( SFAMAh->packet_type ) {
+ 		  case hdr_SFAMA::SFAMA_RTS:
+ 			strcpy(packet_name, "RTS");
+ 			break;
+ 		  case hdr_SFAMA::SFAMA_CTS:
+ 			strcpy(packet_name, "CTS");
+ 			break;
+ 		  case hdr_SFAMA::SFAMA_DATA:
+ 			strcpy(packet_name, "DATA");
+ 			break;
+ 		  case hdr_SFAMA::SFAMA_ACK:
+ 			strcpy(packet_name, "ACK");
+ 		  default:
+ 			break;
+ 		}
+ 		
+ 		if( pt_->tagged() ) {
+ 		   sprintf(pt_->buffer() + offset,
+ 			    "-SFAMA:n %s", packet_name);
+ 		  
+ 		} else if (newtrace_ ) {
+ 		  sprintf(pt_->buffer() + offset, 
+ 			"-P SFAMA -Pt %s", packet_name);
+ 		  
+ 		} else {
+ 		   sprintf(pt_->buffer() + offset, 
+ 			"[SFAMA %s]", packet_name);
+ 		  
+ 		}
+ }
+ 
+ void
  CMUTrace::format_aodv(Packet *p, int offset)
  {
          struct hdr_aodv *ah = HDR_AODV(p);
***************
*** 1191,1197 ****
  	//	return;
  
  	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
! 	char ptype[11];
  	strcpy(ptype,
  	((ch->ptype() == PT_MAC) ? (
  	  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
--- 1231,1237 ----
  	//	return;
  
  	struct hdr_mac802_11 *mh = HDR_MAC802_11(p);
! 	char ptype[50];
  	strcpy(ptype,
  	((ch->ptype() == PT_MAC) ? (
  	  (mh->dh_fc.fc_subtype == MAC_Subtype_RTS) ? "RTS"  :
***************
*** 1348,1396 ****
  	    }   
          }
  
! 	sprintf(pt_->nbuffer() ,
! 		"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
! 		op,
! 		Scheduler::instance().clock(),
! 		src_,                           // this node
! 		next_hop,
! 		ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
! 		ch->size(),
! 		pkt_color,
! 		ch->uid(),
! 		tracename);
  
! //<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
! if (Nam802_15_4::Nam_Status)
! {
! 	if ((strcmp(tracename, "AGT") != 0) || ((u_int32_t)(ih->daddr()) == IP_BROADCAST))		//<zheng: add: next_hop info not available at agent level>
  											//(doesn't really matter -- seems agent level has no effect on nam)
! 	if (next_hop == -1 && op == 'h') {
! 		// print extra fields for broadcast packets
  
! 		// bradius is calculated assuming 2-ray ground reflectlon
! 		// model using default settings of Phy/WirelessPhy and
! 		// Antenna/OmniAntenna
! 		if (bradius == 0.0) calculate_broadcast_parameters();
! 
! 		double radius = bradius*radius_scaling_factor_; 
! 
! 		// duration is calculated based on the radius and
! 		// the speed of light (299792458 m/s)
! 		double duration = (bradius/299792458.0)*duration_scaling_factor_;
! 		//<zheng: add -- the duration in 802.15.4 could be very small and rounded to 0.0>
! 		if (Nam802_15_4::Nam_Status)
! 		if (duration < 0.000000001)
! 			duration = 0.000000001;
! 		//</zheng: add>
! 		sprintf(pt_->nbuffer() + strlen(pt_->nbuffer()),
! 			" -R %.2f -D %.2f",
! 			radius,
! 			duration);
  	}
! }
! //</zheng>
  
  	offset = strlen(pt_->nbuffer());
  	pt_->namdump();
  }
--- 1388,1544 ----
  	    }   
          }
  
! 	if( op=='h' or op=='r' ) {
! 	
! 		sprintf(pt_->nbuffer() ,
! 			"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s -R %.6f",
! 			op,
! 			Scheduler::instance().clock(),
! 			src_,                           // this node
! 			next_hop,
! 			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
! 			ch->size(),
! 			pkt_color,
! 			ch->uid(),
! 			tracename,
! 			UnderwaterChannel::Transmit_distance()
! 			);
! 	}
! 	else {
! 		sprintf(pt_->nbuffer() ,
! 			"%c -t %.9f -s %d -d %d -p %s -e %d -c 2 -a %d -i %d -k %3s",
! 			op,
! 			Scheduler::instance().clock(),
! 			src_,                           // this node
! 			next_hop,
! 			ptype,			//<zheng: modify for 802.15.4>packet_info.name(ch->ptype()),
! 			ch->size(),
! 			pkt_color,
! 			ch->uid(),
! 			tracename);
! 	}
  
! 	//<zheng: ns 2.27 removed the following part, but we need it to control the broadcast radius>
! 	if (Nam802_15_4::Nam_Status)
! 	{
! 		if ((strcmp(tracename, "AGT") != 0) || ((u_int32_t)(ih->daddr()) == IP_BROADCAST))		//<zheng: add: next_hop info not available at agent level>
  											//(doesn't really matter -- seems agent level has no effect on nam)
! 		if (next_hop == -1 && op == 'h') {
! 			// print extra fields for broadcast packets
! 
! 			// bradius is calculated assuming 2-ray ground reflectlon
! 			// model using default settings of Phy/WirelessPhy and
! 			// Antenna/OmniAntenna
! 			if (bradius == 0.0) calculate_broadcast_parameters();
! 			
! 			double radius = bradius*radius_scaling_factor_; 
  
! 			// duration is calculated based on the radius and
! 			// the speed of light (299792458 m/s)
! 			double duration = (bradius/299792458.0)*duration_scaling_factor_;
! 			//<zheng: add -- the duration in 802.15.4 could be very small and rounded to 0.0>
! 			if (Nam802_15_4::Nam_Status)
! 				if (duration < 0.000000001)
! 					duration = 0.000000001;
! 			//</zheng: add>
! 			sprintf(pt_->nbuffer() + strlen(pt_->nbuffer()),
! 				" -R %.2f -D %.2f",
! 				radius,
! 				duration);
! 		}
  	}
! 	//</zheng>
! 	offset = strlen(pt_->nbuffer());
! 	pt_->namdump();
  
+ 	static int u_seq_id = 0;
+ 	u_seq_id++;
+ 	switch(op)
+ 	{
+ 		case 'h':
+ 			//forward packet
+ 			sprintf(pt_->nbuffer() ,
+ 				"v -t %.9f -e sim_annotation %.9f %d node %d sendout packet (%s) %d",
+ 				Scheduler::instance().clock(),
+ 				Scheduler::instance().clock(),
+ 				u_seq_id,
+ 				src_,
+ 				ptype,
+ 				ch->uid() );
+ 			/*
+ 			if( next_hop == -1 ) {
+ 				//broadcast packet
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d sendout packet %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					src_,
+ 					ch->uid() );
+ 				
+ 			}
+ 			else {
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d forward %s %d to %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					src_,
+ 					ptype,
+ 					ch->uid(),
+ 					next_hop );
+ 			}
+ 			*/
+ 			break;
+ 		case 'd':
+ 			//drop packet
+ 			sprintf(pt_->nbuffer() ,
+ 				"v -t %.9f -e sim_annotation %.9f %d node %d drop packet(%s) %d",
+ 				Scheduler::instance().clock(),
+ 				Scheduler::instance().clock(),
+ 				u_seq_id,
+ 				src_,                           // this node
+ 				ptype,
+ 				ch->uid());
+ 			break;
+ 		case 'r':
+ 			if( next_hop == -1 ) {
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d receive packet(%s) %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					node_->nodeid(),
+ 					ptype,
+ 					ch->uid() );
+ 				/*
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d receive broadcast %s %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					node_->nodeid(),
+ 					ptype,
+ 					ch->uid(),
+ 					);
+ 					*/
+ 			}
+ 			else {
+ 				sprintf(pt_->nbuffer() ,
+ 					"v -t %.9f -e sim_annotation %.9f %d node %d receive %s %d from %d",
+ 					Scheduler::instance().clock(),
+ 					Scheduler::instance().clock(),
+ 					u_seq_id,
+ 					next_hop,
+ 					ptype,
+ 					ch->uid(),
+ 					src_ );
+ 			}
+ 			break;
+ 
+ 		default:
+ 			break;
+ 	}
  	offset = strlen(pt_->nbuffer());
  	pt_->namdump();
  }
***************
*** 1456,1461 ****
--- 1604,1632 ----
  		case PT_GAF:
  		case PT_PING:
  			break;
+ 		case PT_DBR:
+ 			break;
+               	case PT_UW_DROUTING:
+ 			break;
+ 		case PT_UWVB:
+ 			break;
+         	case PT_UWVBVA:
+             		break;
+         	case PT_RMAC:
+ 			break; 
+         	case PT_TMAC:
+ 			break;
+ 		
+         	case PT_UWAN_SYNC:
+         	case PT_UWAN_HELLO:
+         	case PT_UWAN_ML:
+ 			break;
+         	case PT_OTMAN:
+ 			break;
+         	case PT_UW_SROUTE:
+             		break;
+         	case PT_SFAMA:
+ 			format_sfama(p, offset);
  		default:
  
  			if(pktTrc_ && pktTrc_->format_unknow(p, offset, pt_, newtrace_))
***************
*** 1586,1593 ****
  	bradius = pow(P_t*G_r*G_t*pow(h,4.0)/(P_r*L), 0.25);
  	//<zheng: add for 802.15.4>
  	//the above calculation is not accurate for short distance
! 	double PI,freq,lambda,crossover_dist;
! 	PI = 3.14159265359;
  	tcl.evalc("Phy/WirelessPhy set freq_");
  	freq = atof(tcl.result());
  	lambda = 3.0e8/freq;
--- 1757,1765 ----
  	bradius = pow(P_t*G_r*G_t*pow(h,4.0)/(P_r*L), 0.25);
  	//<zheng: add for 802.15.4>
  	//the above calculation is not accurate for short distance
! 	//double PI,freq,lambda,crossover_dist;
! 	//PI = 3.14159265359;
! 	double freq,lambda,crossover_dist;
  	tcl.evalc("Phy/WirelessPhy set freq_");
  	freq = atof(tcl.result());
  	lambda = 3.0e8/freq;
diff -crBN ns-2.35/trace/cmu-trace.h ns-2.35-aquasim/trace/cmu-trace.h
*** ns-2.35/trace/cmu-trace.h	2010-05-10 06:28:41.000000000 +0800
--- ns-2.35-aquasim/trace/cmu-trace.h	2016-09-03 00:04:59.000000000 +0800
***************
*** 161,167 ****
          void    format_aodv(Packet *p, int offset);
  	void    format_aomdv(Packet *p, int offset);
  	void    format_mdart(Packet *p, int offset);
! 
  	// This holds all the tracers added at run-time
  	static PacketTracer *pktTrc_;
  
--- 161,167 ----
          void    format_aodv(Packet *p, int offset);
  	void    format_aomdv(Packet *p, int offset);
  	void    format_mdart(Packet *p, int offset);
! 	void	format_sfama(Packet* p, int offset);
  	// This holds all the tracers added at run-time
  	static PacketTracer *pktTrc_;
  
diff -crBN ns-2.35/underwatersensor/uw_common/underwatersensornode.cc ns-2.35-aquasim/underwatersensor/uw_common/underwatersensornode.cc
*** ns-2.35/underwatersensor/uw_common/underwatersensornode.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/underwatersensornode.cc	2016-09-03 00:29:49.804000000 +0800
***************
*** 0 ****
--- 1,367 ----
+ #include <math.h>
+ #include <stdlib.h>
+ #include "connector.h"
+ #include "delay.h"
+ #include "packet.h"
+ #include "random.h"
+ #include "trace.h"
+ #include "address.h"
+ #include "arp.h"
+ #include "topography.h"
+ #include "ll.h"
+ #include "mac.h"
+ #include "underwatersensor/uw_mac/underwaterpropagation.h"
+ #include "underwatersensornode.h"
+ #include "phy.h"
+ #include "wired-phy.h"
+ #include "god.h"
+ 
+ 
+ static class UnderwaterSensorNodeClass : public TclClass {
+ public:
+ 	UnderwaterSensorNodeClass() : TclClass("Node/MobileNode/UnderwaterSensorNode") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new UnderwaterSensorNode);
+ 	}
+ } class_underwatersensornode;
+ 
+ 
+ 
+ void
+ UnderwaterPositionHandler::handle(Event*)
+ {
+ 	Scheduler& s = Scheduler::instance();
+ 
+ 
+ #if 0
+ 	fprintf(stderr, "*** POSITION HANDLER for node %d (time: %f) ***\n",
+ 		node->address(), s.clock());
+ #endif
+ 	/*
+ 	* Update current location
+ 	*/
+ 
+ 	//	printf("*** POSITION HANDLER for node %d (time: %f) ***\n", node->address(), s.clock()); // added by Peng Xie
+ 	if( node->UWMP_ != NULL )
+ 		node->UWMP_->update_position();
+ 	else{
+ 		node->update_position();
+ 		//node->random_destination();
+ 	}
+ 
+ 	/*
+ 	* Choose a new random speed and direction
+ 	*/
+ #ifdef DEBUG
+ 	fprintf(stderr, "%d - %s: calling random_destination()\n",
+ 		node->address_, __PRETTY_FUNCTION__);
+ #endif
+ 	//	node->random_destination();
+ 	node->check_position();
+ 	s.schedule(&node->uw_pos_handle_, &node->uw_pos_intr_,
+ 		node->position_update_interval_);
+ }
+ 
+ 
+ 
+ /* ======================================================================
+ Underwater Sensor Node 
+ ====================================================================== */
+ 
+ UnderwaterSensorNode::UnderwaterSensorNode(void): 
+ MobileNode(),uw_pos_handle_(this)
+ {
+ 
+ 	sinkStatus_=0;  // add by Peng Xie
+ 	failure_status_=0;// add by peng xie
+ 	failure_status_pro_=0;//added by peng xie AND ZHENG
+ 	failure_pro_=0.0; // add by peng xie
+ 	trans_status=IDL;
+ 	T_=0;
+ 	setHopStatus=0;
+ 	next_hop=-10;        
+ 	position_update_interval_ = 1.0;
+ 	max_thought_time_ = 0.0;  //by default, node does not stop after arrive at the new way point
+ 	UWMP_ = NULL;
+ 
+ 	bind("sinkStatus_", &sinkStatus_);
+ 	bind("position_update_interval_", &position_update_interval_);
+ 	bind("max_speed", &max_speed);
+ 	bind("min_speed", &min_speed);
+ 	bind("max_thought_time_", &max_thought_time_);
+ 	
+ }
+ 
+ 
+ UnderwaterSensorNode::~UnderwaterSensorNode()
+ {
+ 	delete UWMP_;
+ }
+ 
+ 
+ void 
+ UnderwaterSensorNode::start()
+ {
+ 	Scheduler& s = Scheduler::instance();
+ 
+ 	//printf("underwatersensornode: start\n");
+ 	if(random_motion_ == 0) {
+ 		//printf("underwatersensornode: before log_movement\n");
+ 		log_movement();
+ 		return;
+ 	}
+ 
+ 	assert(initialized());
+ 
+ 	//printf("underwatersensornode: before random_position\n");
+ 
+ 	random_position();
+ #ifdef DEBUG
+ 	fprintf(stderr, "%d - %s: calling random_destination()\n",
+ 		address_, __PRETTY_FUNCTION__);
+ #endif
+ 	random_destination();
+ 
+ 	s.schedule(&uw_pos_handle_, &uw_pos_intr_, position_update_interval_);
+ }
+ 
+ 
+ int
+ UnderwaterSensorNode::command(int argc, const char*const* argv)
+ {
+ 	Tcl& tcl = Tcl::instance();
+ 
+ 	if(argc==2){
+ 		if(strcmp(argv[1],"start")==0){
+ 			start();
+ 			return TCL_OK;
+ 		}
+ 		if(strcmp(argv[1],"move")==0){
+ 			move();   //random walk
+ 			return TCL_OK;
+ 		}
+ 		if(strcmp(argv[1],"failure-status")==0){
+ 			tcl.resultf("%d",failure_status());
+ 			return TCL_OK;
+ 		}
+ 		else if(strcmp(argv[1], "start-mobility-pattern")==0){
+ 	  		//start the position update process
+ 			Scheduler& s = Scheduler::instance();
+ 			UWMP_->init();
+ 			s.schedule(&uw_pos_handle_, &uw_pos_intr_, 0.00001);
+ 			return TCL_OK;
+ 		}
+ 	}
+ 	else if(argc == 3) {
+ 
+ 		// added by peng xie
+ 		if(strcmp(argv[1], "set-cx") == 0) {
+ 			CX_=atof(argv[2]);
+ 			return TCL_OK;
+ 		}else if(strcmp(argv[1], "set-cy") == 0){
+ 			CY_=atof(argv[2]);
+ 			return TCL_OK;
+ 		}else if(strcmp(argv[1], "set-cz")==0){
+ 			CZ_=atof(argv[2]);
+ 			return TCL_OK;   
+ 			return TCL_OK;
+ 		}else if(strcmp(argv[1], "setSpeed") == 0){
+ 			speed_=atof(argv[2]);
+ 			return TCL_OK;
+ 		}else if(strcmp(argv[1], "random-motion") == 0){
+ 			random_motion_=atoi(argv[2]);
+ 			return TCL_OK;
+ 		}else if(strcmp(argv[1], "set-mobilitypattern")==0){
+ 	     	//bind the mobility models
+ 			bindMobilePattern(argv[2]);
+ 			return TCL_OK;
+ 	    }else if(strcmp(argv[1], "setPositionUpdateInterval") == 0){
+ 			position_update_interval_=atof(argv[2]);
+ 			return TCL_OK;
+ 		} else if(strcmp(argv[1], "set-failure_status") == 0){
+ 			failure_status_=atoi(argv[2]);
+ 			// printf("underwaternode (%d) set the status %d at %f\n",address_,failure_status_,NOW);
+ 			return TCL_OK;
+ 		}
+ 		else if(strcmp(argv[1], "set-failure_status_pro") == 0){
+ 			failure_status_pro_=atof(argv[2]);
+ 			generateFailure();   
+ 			return TCL_OK;
+ 		} else if(strcmp(argv[1], "set-failure_pro") == 0){
+ 			failure_pro_=atof(argv[2]);
+ 			return TCL_OK;
+ 			//end of peng Xie's addition 
+ 		} else  if (strcmp(argv[1], "set_next_hop") == 0) {
+ 			setHopStatus=1;
+ 			next_hop=atoi(argv[2]);
+ 			return TCL_OK;
+ 		}
+ 		else if(strcmp(argv[1],"topography")==0){
+ 			T_=(Topography*) TclObject::lookup(argv[2]);
+ 			if(T_==0) return TCL_ERROR; 
+ 			//I am not sure if I can do this 
+ 			MobileNode::command(argc, argv);            
+ 			return TCL_OK;
+ 		}
+ 	}
+ 
+ 	return MobileNode::command(argc, argv);
+ }
+ 
+ 
+ //added by peng xie
+ void 
+ UnderwaterSensorNode::move()
+ {
+ 	Scheduler& s = Scheduler::instance();
+ 	//	printf("underwatersensornode: ?????????????????the move\n");
+ 	//	if(random_motion_ == 0) {
+ 	//log_movement();
+ 	//return;
+ 	//}
+ 
+ 	//assert(initialized());
+ 
+ 	//	random_position(z);
+ #ifdef DEBUG
+ 	fprintf(stderr, "%d - %s: calling random_destination()\n",
+ 		address_, __PRETTY_FUNCTION__);
+ #endif
+ 	random_destination();
+ 	s.schedule(&uw_pos_handle_, &uw_pos_intr_, position_update_interval_);
+ }
+ 
+ 
+ 
+ void 
+ UnderwaterSensorNode::random_position()
+ {
+ 	//  printf("underwatersensornode:  in the random_position\n");
+ 	if (T_ == 0) {
+ 		fprintf(stderr, "No TOPOLOGY assigned\n");
+ 		exit(1);
+ 	}
+ 
+ 	X_ = Random::uniform() * T_->upperX();
+ 	Y_ = Random::uniform() * T_->upperY();
+ 	Z_ = Random::uniform() * T_->upperZ();
+ 	//original one	Z_ = T_->height(X_, Y_);
+ 	// Z_ =z;
+ 	position_update_time_ = 0.0;
+ }
+ 
+ 
+ 
+ void 
+ UnderwaterSensorNode::generateFailure()
+ {
+ 	double error_pro=Random::uniform();
+ 	if(error_pro<failure_status_pro_) failure_status_=1;
+ 
+ 
+ }
+ 
+ void 
+ UnderwaterSensorNode::check_position()
+ {
+ 	if((X_==destX_)||(Y_==destY_)) {
+ 		random_speed();
+ 		random_destination();
+ 		//    printf("vectorbased:set new des and speed+++++\n");
+ 	}
+ 	else {
+ 		log_movement();
+ 	}
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ void
+ UnderwaterSensorNode::random_speed()
+ {
+ 
+ 	speed_ = (Random::uniform() * (max_speed-min_speed))+min_speed;
+ 	//	printf("underwatersensornode: ?????????????????the max_speed%f min %f speed  %f interval%f\n",max_speed,min_speed,speed_,position_update_interval_);
+ }
+ 
+ void
+ UnderwaterSensorNode
+ ::random_destination()
+ {
+ 	//printf("mobilenode: ?????????????????the randmo_destionation\n");
+ 	if (T_ == 0) {
+ 		fprintf(stderr, "No TOPOLOGY assigned\n");
+ 		exit(1);
+ 	}
+ 
+ 	random_speed();
+ #ifdef DEBUG
+ 	fprintf(stderr, "%d - %s: calling set_destination()\n",
+ 		address_, __FUNCTION__);
+ #endif
+ 	(void) set_destination(Random::uniform() * T_->upperX(),
+ 		Random::uniform() * T_->upperY(),
+ 		speed_);
+ }
+ 
+ 
+ 
+ 
+ double
+ UnderwaterSensorNode::propdelay(UnderwaterSensorNode *m)
+ {
+ 	//printf("underwatersensornode: ?????????????????the properdelay\n");
+ 	return distance(m) / SPEED_OF_SOUND_IN_WATER;
+ }
+ 
+ 
+ 
+ 
+ int
+ UnderwaterSensorNode::setSinkStatus()
+ {
+ 	//	printf("underwatersensornode: I change it to 1\n");
+ 	sinkStatus_=1;
+ 	return 0; 
+ }
+ 
+ 
+ 
+ int
+ UnderwaterSensorNode::clearSinkStatus()
+ {
+ 	//	printf("underwatersensornode: I change it to 1\n");
+ 	sinkStatus_=0;
+ 	return 0; 
+ }
+ 
+ 
+ void
+ UnderwaterSensorNode::bindMobilePattern(const char* PatternName)
+ {
+ 	//add mobility pattern here
+ 	MobilityPatternType mpt_ = mpt_names.getTypeByName(PatternName);
+ 	switch( mpt_ )
+ 	{
+ 		case MPT_KINEMATIC:
+ 			UWMP_ = new UW_Kinematic(this);
+ 			break;
+ 		case MPT_RWP:
+ 			UWMP_ = new UW_RWP(this);
+ 			break;
+ 		default:
+ 			/*
+ 			 *i.e., mpt_ is MPT_NTYPE
+ 			 *UnderwaterPositionHandler will proccess this case
+ 			 */		
+ 			;
+ 	}
+ 	
+ }
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_common/underwatersensornode.h ns-2.35-aquasim/underwatersensor/uw_common/underwatersensornode.h
*** ns-2.35/underwatersensor/uw_common/underwatersensornode.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/underwatersensornode.h	2016-09-03 00:29:38.448000000 +0800
***************
*** 0 ****
--- 1,207 ----
+ 
+ 
+ #ifndef __ns_underwatersensornode_h__
+ #define __ns_underwatersensornode_h__
+ 
+ #include "object.h"
+ #include "trace.h"
+ #include "lib/bsd-list.h"
+ #include "phy.h"
+ #include "topography.h"
+ #include "arp.h"
+ #include "node.h"
+ #include "gridkeeper.h" // I am not sure if it is useful in our case
+ #include "energy-model.h"
+ #include "location.h"
+ #include "underwatersensor/uw_mobility_pattern/mobility_pattern_allinone.h"
+ 
+ enum TransmissionStatus {SLEEP,IDL,SEND,RECV, NStatus};
+ #include "underwatersensor/uw_mac/underwaterphy.h"
+ 
+ class GridKeeper; // think it later
+ 
+  //NStatus is used to get the number of elements in this enums
+ 
+ 
+ 
+ #if COMMENT_ONLY
+ -----------------------
+ |			|
+ |	Upper Layers	|
+ |			|
+ -----------------------
+ |		    |
+ |		    |
+ -------	 -------
+ |	|	|	|
+ |  LL	|	|  LL	|
+ |	|	|	|
+ -------	 -------
+ |		    |
+ |		    |
+ -------	 -------
+ |	|	|	|
+ | Queue	|	| Queue	|
+ |	|	|	|
+ -------	 -------
+ |		    |
+ |		    |
+ -------	 -------
+ |	|	|	|
+ |  Mac	|	|  Mac	|
+ |	|	|	|
+ -------	 -------
+ |		    |
+ |		    |
+ -------	 -------	 -----------------------
+ |	|	|	|	|			|
+ | Netif	| <---	| Netif | <---	|	Mobile Node	|
+ |	|	|	|	|			|
+ -------	 -------	 -----------------------
+ |		    |
+ |		    |
+ -----------------------
+ |			|
+ |	Channel(s) 	|
+ |			|
+ -----------------------
+ #endif
+ 
+ 
+ class UnderwaterSensorNode;
+ 
+ class UnderwaterPositionHandler : public Handler {
+ public:
+ 	UnderwaterPositionHandler(UnderwaterSensorNode* n) : node(n) {}
+ 	void handle(Event*);
+ private:
+ 	UnderwaterSensorNode *node;
+ };
+ 
+ 
+ class UnderwaterSensorNode : public MobileNode 
+ {
+ 	friend class UnderwaterPositionHandler;
+ 	friend class UWMobilityPattern; 	//added by Yibo
+ 	friend class UW_Kinematic;		
+ 	friend class UW_RWP;
+ public:
+ 
+ 	UnderwaterSensorNode();
+ 	~UnderwaterSensorNode();
+ 	virtual int command(int argc, const char*const* argv);
+ 	double propdelay(UnderwaterSensorNode*);
+ 	void	move();
+ 	void start();
+ 	int clearSinkStatus();// added by peng xie
+ 	int setSinkStatus();// added by peng xie
+ 	void check_position();	
+ 
+ 	// added by peng Xie m
+ 	inline double CX() { return CX_; }
+ 	inline double CY() { return CY_; }
+ 	inline double CZ() { return CZ_; }
+ 	inline int sinkStatus(){return sinkStatus_;}
+ 	inline int failure_status(){return failure_status_;}
+ 	inline double failure_pro(){return failure_pro_;}
+ 	inline double failure_status_pro(){return failure_status_pro_;}
+ 	
+ 	inline void SetTransmissionStatus(enum TransmissionStatus status) {
+ 		trans_status = status;
+ 	}
+ 	
+ 	//set status considering state transition
+ 	/*
+ 	inline double SetTransmissionStatus(enum TransmissionStatus status, UnderwaterPhy* phy){
+ 		//compare the pre_trans, current_status, and i
+ 		//then decide the transition time
+ 		double transit_time = 0.0;
+ 		if( trans_status == IDL ) {
+ 			if( NOW-status_change_time() >= phy->getTransitTime(trans_status, status)  ) {
+ 				transit_time = phy->getTransitTime(trans_status, status);
+ 			}
+ 			else {
+ 			
+ 			}
+ 		}
+ 		
+ 		if( status != trans_status ) {
+ 			pre_trans_status = trans_status;
+ 			status_change_time_ = NOW;
+ 			trans_status = status;
+ 		}
+ 		trans_status = status;
+ 	}
+ 	*/
+ 	
+ 	inline void SetCarrierSense(bool f){
+ 		carrier_sense=f;
+ 		carrier_id=f;
+ 	}
+ 	inline enum TransmissionStatus TransmissionStatus(){return trans_status;}
+ 	inline bool CarrierSense(){return carrier_sense;}
+ 	inline bool CarrierId(){return carrier_id;}
+ 	inline void ResetCarrierSense(){ carrier_sense=false;}
+ 	inline void ResetCarrierId(){carrier_id=false;}
+ 	
+ 	inline enum TransmissionStatus PreTransStatus() { return pre_trans_status; }
+ 	inline double& status_change_time() { return status_change_time(); }
+ 
+ 	double CX_;
+ 	double CY_;
+ 	double CZ_;
+ 	int sinkStatus_;
+ 	int failure_status_;// 1 if node fails, 0 otherwise
+ 	int setHopStatus; // used by test-rmac.tcl. add by peng xie
+ 	int next_hop;// used by test-rmac.tcl. add by peng xie
+ 
+ 	enum  TransmissionStatus trans_status;
+ 	enum  TransmissionStatus pre_trans_status; //the previous status
+ 	double status_change_time_;  //the time when changing pre_trans_status to trans_status
+ 	
+ 	//add by peng xie, 1  indicates the node is in failure state, 0 normal state
+ 	bool 	carrier_sense;
+ 	bool 	carrier_id;
+ 	double 	failure_pro_;
+ 	// add by peng xie to indicate the error probability of receiving packets
+ 	//   int destination_status; 
+ 	double 	failure_status_pro_;
+ 	// add by peng xie& zheng  to indicate the probability to set the failure status of this node
+ 	//   int destination_status; 
+ 	UnderwaterPositionHandler uw_pos_handle_;
+ 	Event uw_pos_intr_; 
+ 
+ protected:
+ 
+ 	double max_speed;
+ 	double min_speed;
+ 	void random_speed();
+ 	void random_destination();
+ 	void generateFailure();
+ 	UWMobilityPattern * UWMP_;	//added by Yibo to implement mobility model
+ 	void bindMobilePattern(const char* PatternName);
+ 
+ private:
+ 	inline int initialized(){
+ 		return (T_ &&
+ 			X_ >= T_->lowerX() && X_ <= T_->upperX() &&
+ 			Y_ >= T_->lowerY() && Y_ <= T_->upperY() &&
+ 			Z_ >= T_->lowerZ() && Z_ <= T_->upperZ() );  //Z_ is added by Yibo
+ 
+ 	}
+ 	void	random_position();
+ 	void	bound_position();
+ 	int		random_motion_;	// is mobile
+ 	double  max_thought_time_;  //for underwater random waypoint model
+ 
+ 	Topography* T_;
+ 
+ };
+ 
+ #endif // ns_underwatersensornode_h
+ 
+ 
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_common/uw_hash_table.cc ns-2.35-aquasim/underwatersensor/uw_common/uw_hash_table.cc
*** ns-2.35/underwatersensor/uw_common/uw_hash_table.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/uw_hash_table.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,36 ----
+ 
+ #include "tclcl.h"
+ #include "uw_hash_table.h"
+ 
+ 
+ 
+ void UW_Hash_Table::PutInHash(int addr)
+ {
+   bool exist=false;
+   int index=0;
+   for (int i=0;i<current_index;i++){
+     if(table[i].node==addr) {
+       index=i;
+       exist=true;
+     }
+   }
+ 
+   if(exist) table[index].num++;     
+   else {
+     table[current_index].node=addr;
+     table[current_index].num=1;
+     current_index++;
+   }
+ }
+ 
+ int 
+ UW_Hash_Table::node(int index)
+ {
+   return table[index].node;
+ }
+ 
+ int 
+ UW_Hash_Table::number(int index)
+ {
+   return table[index].num;
+ }
diff -crBN ns-2.35/underwatersensor/uw_common/uw_hash_table.h ns-2.35-aquasim/underwatersensor/uw_common/uw_hash_table.h
*** ns-2.35/underwatersensor/uw_common/uw_hash_table.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/uw_hash_table.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,38 ----
+ 
+ 
+ #ifndef ns_uw_hash_table_h
+ #define ns_uw_hash_table_h
+ 
+ #include "config.h"
+ #include "tclcl.h"
+ 
+ #define TABLE_SIZE 20
+ 
+ struct value_record{
+   int node;
+   int num;
+ };
+ 
+ 
+ class UW_Hash_Table {
+  public:
+   UW_Hash_Table()
+ {
+   current_index=0;
+ for (int i=0;i<TABLE_SIZE;i++)
+ {
+ table[i].node=-1;
+  table[i].num=-1;
+   }  
+ }
+ 
+   int current_index;
+   void PutInHash(int addr);
+ int  node(int);
+ int  number(int);
+   value_record table[TABLE_SIZE];
+ };
+ 
+ 
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_common/uw_poi_traffic.cc ns-2.35-aquasim/underwatersensor/uw_common/uw_poi_traffic.cc
*** ns-2.35/underwatersensor/uw_common/uw_poi_traffic.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/uw_poi_traffic.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,75 ----
+ /*
+  * This is a traffic generator. 
+  * The traffic pattern follows Poisson Process
+  * author: Yibo Zhu (yibo.zhu@engr.uconn.edu)
+  */
+ 
+ 
+ #include <stdlib.h>
+  
+ #include "random.h"
+ #include "trafgen.h"
+ #include "ranvar.h"
+ #include <agent.h>
+ 
+ 
+ class UW_Poi_Traffic : public TrafficGenerator {
+ public:
+ 	UW_Poi_Traffic();
+ 	virtual void init();
+ 	virtual double next_interval(int &size);
+ 	
+ protected:
+ 	int	maxpkts_;  //negative number means infinity
+ 	int seqno_;
+ 	double data_rate_; /*initialize it as negative number to 
+ 					 *check if it's set by user*/
+ };
+ 
+ UW_Poi_Traffic::UW_Poi_Traffic(): maxpkts_(-1), 
+ 	seqno_(0), data_rate_(-1)
+ {
+ 	size_ = 1;
+ 	bind("maxpkts_", &maxpkts_);
+ 	bind("packetSize_", &size_);
+ 	bind("data_rate_", &data_rate_);
+ 	
+ }
+ 
+ void UW_Poi_Traffic::init()
+ {
+ 	if( !(data_rate_>0 && size_>0) ) {
+ 		fprintf(stderr, "Must set data_rate_ and packetSize_ before using UW_Poi_Traffic");
+ 		exit(1);
+ 	}
+ 	Random::seed_heuristically();
+ 	if( agent_ ) {
+ 		agent_->set_pkttype(PT_UW_MESSAGE);
+ 	}
+ }
+ 
+ 
+ double UW_Poi_Traffic::next_interval(int &size)
+ {
+ 	double R=Random::uniform();
+ 	double lambda_=data_rate_;
+ 	double t = -log(R)/lambda_;
+ 	
+ 	if( (maxpkts_ < 0) || ( (maxpkts_ >= 0) && (++seqno_ < maxpkts_)) )
+ 		return(t);
+ 	else
+ 		return(-1);  //with -1, timeout() will stop function
+ }
+ 
+ 
+ static class UW_POI_TrafficClass : public TclClass {
+  public:
+ 	UW_POI_TrafficClass() : TclClass("Application/Traffic/UW_POI") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new UW_Poi_Traffic());
+ 	}
+ } class_uw_poi_traffic;
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_common/uw_sink.cc ns-2.35-aquasim/underwatersensor/uw_common/uw_sink.cc
*** ns-2.35/underwatersensor/uw_common/uw_sink.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/uw_sink.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,850 ----
+ 
+ /********************************************************************/
+ /* sink for underwater                                              */
+ /********************************************************************/
+ 
+ 
+ #include <stdlib.h>
+ #include <tcl.h>
+ #include <stdio.h>
+ 
+ #include "uw_sink.h"
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "random.h"
+ 
+ 
+ #define REPORT_PERIOD     2
+ #define INTEREST_PERIOD   2
+ 
+ bool operator<(const sense_area_elem&  e1, const sense_area_elem& e2)
+ {
+ 	return (e1.sense_x<e2.sense_x)&&(e1.sense_y<e2.sense_y)
+ 		&&(e1.sense_z<e2.sense_z)&&(e1.sense_r<e2.sense_r);
+ }
+ 
+ void SenseArea::insert(double x, double y, double z, double r)
+ {
+ 	AreaSet.insert( sense_area_elem(x,y,z,r));
+ }
+ 
+ bool SenseArea::IsInSenseArea(double nx, double ny, double nz)
+ {
+ 	double delta_x, delta_y, delta_z, distance;
+ 	set<sense_area_elem>::iterator pos = AreaSet.begin();
+ 	while( pos != AreaSet.end() ) {
+ 		delta_x = nx - (*pos).sense_x;
+ 		delta_y = ny - (*pos).sense_y;
+ 		delta_z = nz - (*pos).sense_z;
+ 
+ 		distance = sqrt(delta_x*delta_x+delta_y*delta_y+delta_z*delta_z);
+ 		if( distance < (*pos).sense_r )
+ 			return true;
+ 		pos++;
+ 	}
+ 	return false;
+ }
+ 
+ 
+ void UWReport_Timer::expire(Event *) {
+ 	a_->report();
+ }
+ 
+ 
+ void UWSink_Timer::expire(Event *) {
+ 	a_->timeout(0);
+ }
+ 
+ void UWPeriodic_Timer::expire(Event *) {
+ 	a_->bcast_interest();
+ }
+ static class UWSinkClass : public TclClass {
+ public:
+ 	UWSinkClass() : TclClass("Agent/UWSink") {}
+ 	TclObject* create(int , const char*const* ) {
+ 		return(new UWSinkAgent());
+ 	}
+ } class_uwsink;
+ 
+ int UWSinkAgent::pkt_id_ = 0;
+ 
+ UWSinkAgent::UWSinkAgent() : Agent(PT_UWVB),running_(0), random_(0), sink_timer_(this), periodic_timer_(this),
+ report_timer_(this)
+ {
+ 	// set option first.
+ 
+ 	APP_DUP_ = true; // allow duplication 
+ 
+ 	periodic_ = false; //just send out interest once
+ 	// always_max_rate_ = false; //?
+ 
+ 	// Bind Tcl and C++ Variables
+ 
+ 
+ 	// bind("num_send",&num_send);
+ 	//bind("num_recv",&num_recv);
+ 	// bind("maxpkts_", &maxpkts_);
+ 
+ 	// Initialize variables.
+ 
+ 	maxpkts_ = 1000;
+ 	pk_count=0;
+ 	num_recv=0;
+ 	num_send=0;
+ 	//  RecvPerSec=0;
+ 
+ 	strcpy(f_name,"test.data");
+ 
+ 	target_x=0;
+ 	target_y=0;
+ 	target_z=0;
+ 	target_id.addr_=0;
+ 	target_id.port_=0; 
+ 
+ 
+ 
+ 	passive=0;
+ 	cum_delay=0.0;
+ 
+ 	ActiveSense = 0;
+ 
+ 
+ 	// bind("data_type_", &data_type_);
+ 	bind_time("data_rate_", &data_rate_);
+ 	bind("packetsize_", &packetsize_);
+ 	bind("random_", &random_);
+ 	bind("passive",&passive);
+ 	bind("ActiveSense", &ActiveSense);
+ 	bind("SenseInterval", &SenseInterval);
+ 	// bind("num_recv", &num_recv);
+ 	// bind("num_send", &num_send);
+ 	// bind("cum_delay", &cum_delay);
+ 
+ 
+ 	/* 
+ 	size_=64;
+ 	interval_=1;
+ 
+ 	random_=0;
+ 	*/
+ 
+ 	data_counter = 0;
+ 
+ 
+ 	//simple_report_rate = ORIGINAL;
+ 
+ 	last_arrival_time = -1.0;
+ }
+ 
+ void UWSinkAgent::start()
+ {
+ 	running_ = 1;
+ 	interval_=1.0/data_rate_;
+ 	random_=0;	
+ 	sendpkt();
+ 	sink_timer_.resched(interval_);
+ }
+ 
+ void UWSinkAgent::exponential_start()
+ {
+ 	random_=2;
+ 	running_ = 1;	
+ 	generateInterval();
+ 	sink_timer_.resched(interval_);
+ }
+ 
+ 
+ void 
+ UWSinkAgent::generateInterval()
+ {
+ 	double R=Random::uniform();
+ 	double lambda=data_rate_;
+ 	interval_=-log(R)/lambda;
+ 	// printf("\nuwsink: !!!!!!!!generateInterval the  inetrval is %f\n",interval_);
+ 	return; 
+ }
+ 
+ 
+ void UWSinkAgent::stop()
+ {
+ 	if (running_) {
+ 		running_ = 0;
+ 	}
+ 
+ 	if (periodic_ == true) {
+ 		periodic_ = false;
+ 		periodic_timer_.force_cancel();
+ 	}
+ }
+ 
+ 
+ void UWSinkAgent::report()
+ {
+ 	printf("SK %d:  at time %lf\n", here_.addr_, NOW);
+ 	report_timer_.resched(REPORT_PERIOD);
+ 	// RecvPerSec = 0;
+ }
+ 
+ 
+ void UWSinkAgent::timeout(int)
+ {
+ 	if (running_) {
+ 		sendpkt();
+ 		double t = interval_;
+ 		if (random_==1)
+ 			/* add some zero-mean white noise */
+ 			t += interval_ * Random::uniform(-0.5, 0.5);
+ 		if(random_==2) {
+ 			generateInterval();
+ 			t=interval_;
+ 
+ 		}
+ 		sink_timer_.resched(t);
+ 	}
+ }
+ 
+ 
+ void UWSinkAgent::sendpkt()
+ {
+ 	if( ActiveSense ) {
+ 		node->update_position();
+ 		if( !SenseAreaSet.IsInSenseArea(node->X(), node->Y(), node->Z()) ) {
+ 			//detect frequently
+ 			interval_ = 1;
+ 			return;
+ 		}
+ 		else {
+ 			interval_ = SenseInterval;
+ 		}
+ 	}
+ 
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	hdr_ip* iph = HDR_IP(pkt);
+ 	hdr_cmn*  cmh = HDR_CMN(pkt);
+ 
+ 
+ 	cmh->ptype()=PT_UWVB;
+ 	cmh->size() = packetsize_;
+ 	cmh->uid() = pkt_id_++;
+ 	vbh->mess_type = DATA;
+ 	vbh->pk_num = pk_count;
+ 	vbh->ts_=NOW;
+ 	pk_count++;
+ 
+ 	iph->src_=here_;
+ 	iph->dst_.addr_=here_.addr_;
+ 	iph->dst_.port_=255;
+ 
+ 	vbh->sender_id = here_;
+ 	// vbh->data_type = data_type_;
+ 	vbh->forward_agent_id = here_; 
+ 
+ 	vbh->target_id=target_id;
+ 	vbh->range=range_;
+ 
+ 
+ 	vbh->info.tx=target_x;
+ 	vbh->info.ty=target_y; 
+ 	vbh->info.tz=target_z;
+ 
+ 	vbh->info.fx=node->CX();
+ 	vbh->info.fy=node->CY();
+ 	vbh->info.fz=node->CZ();
+ 
+ 	vbh->info.ox=node->CX();
+ 	vbh->info.oy=node->CY(); 
+ 	vbh->info.oz=node->CZ();
+ 
+ 	vbh->info.dx=0;
+ 	vbh->info.dy=0; 
+ 	vbh->info.dz=0;
+ 
+ 	/*     
+ 	vbh->original_source.x=vbh->info.fx;
+ 	vbh->original_source.y=vbh->info.fy;
+ 	vbh->original_source.z=vbh->info.fz;
+ 	*/
+ 
+ 	//printf("uw_sink:source(%d,%d) send packet %d at %lf : the coordinates of target is (%lf,%lf,%lf) and range=%lf and my position (%f,%f,%f) and cx is(%f,%f,%f)  type is %d\n", vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num, NOW, vbh->info.tx=target_x,vbh->info.ty=target_y, vbh->info.tz=target_z,vbh->range,node->X(),node->Y(),node->Z(),node->CX(),node->CY(),node->CZ(),vbh->mess_type);
+ 
+ 
+ 
+ 
+ 	num_send++;
+ 	//   vbh->attr[0] = data_type_;
+ 
+ 
+ 	if (target_==NULL)  printf("The target_ is empty\n");
+ 	else { 
+ 
+ 		// printf("The target_ is not  empty\n");
+ 		send(pkt, 0);
+ 	}
+ 	// printf("I exit the sendpk \n");
+ }
+ 
+ 
+ void UWSinkAgent::data_ready()
+ {
+ 
+ 	// printf("I am in the sendpk1 \n");
+ 	if (pk_count >=  maxpkts_) {
+ 		running_ = 0;
+ 		return;
+ 
+ 	}
+ 	// printf("I am in the sendpk2 \n");
+ 	Packet* pkt = create_packet();
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	hdr_ip* iph = HDR_IP(pkt);
+ 	//hdr_cmn*  cmh = HDR_CMN(pkt);
+ 
+ 
+ 	vbh->mess_type = DATA_READY;
+ 	vbh->pk_num = pk_count;
+ 
+ 	pk_count++;
+ 
+ 
+ 	iph->src_=here_;
+ 	iph->dst_.addr_=here_.addr_;
+ 	iph->dst_.port_=255;
+ 
+ 
+ 	vbh->sender_id = here_;
+ 	//      vbh->data_type = data_type_;
+ 	vbh->forward_agent_id = here_; 
+ 
+ 	vbh->target_id=target_id;
+ 	vbh->range=range_;
+ 	vbh->ts_=NOW;
+ 
+ 	printf("uw_sink:source(%d,%d)(%f,%f,%f) send data ready packet %d at %lf : the target is (%d,%d)\n", vbh->sender_id.addr_,vbh->sender_id.port_,node->X(),node->Y(),node->Z(),vbh->pk_num, NOW, vbh->target_id.addr_,vbh->target_id.port_);
+ 
+ 
+ 	// Send the packet
+ 	// printf("Source %s send packet ( %x,%d) at %lf.\n", name(), 
+ 	// vbh->sender_id, vbh->pk_num, NOW);
+ 
+ 
+ 	//  num_send++;
+ 	//      vbh->attr[0] = data_type_;
+ 
+ 
+ 
+ 
+ 	if (target_==NULL)  printf("The target_ is empty\n");
+ 	else {
+ 		// printf("The target_ is not  empty\n");
+ 		send(pkt, 0);
+ 	}
+ 	// printf("I exit the sendpk \n");
+ }
+ 
+ 
+ 
+ void UWSinkAgent::source_deny(ns_addr_t id, double x, double y, double z)
+ {
+ 
+ 
+ 	Packet* pkt = create_packet();
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	hdr_ip* iph = HDR_IP(pkt);
+ 
+ 	// Set message type, packet number and sender ID
+ 	vbh->mess_type = SOURCE_DENY;
+ 	vbh->pk_num = pk_count;
+ 	pk_count++;
+ 
+ 
+ 	iph->src_=here_;
+ 	iph->dst_.addr_=here_.addr_;
+ 	iph->dst_.port_=255;
+ 
+ 	vbh->sender_id = here_;	
+ 	//      vbh->data_type = data_type_;
+ 	vbh->forward_agent_id = here_; 
+ 
+ 	vbh->target_id=id;
+ 
+ 
+ 
+ 	vbh->info.tx=x;
+ 	vbh->info.ty=y; 
+ 	vbh->info.tz=z;
+ 	vbh->range=range_;
+ 	vbh->ts_=NOW;
+ 
+ 
+ 	// Send the packet
+ 
+ 	vbh->info.ox=node->X();
+ 	vbh->info.oy=node->Y(); 
+ 	vbh->info.oz=node->Z();
+ 
+ 	/* 
+ 	vbh->original_source.x=vbh->info.ox;
+ 	vbh->original_source.y=vbh->info.oy;
+ 	vbh->original_source.z=vbh->info.oz;
+ 	*/
+ 
+ 	vbh->info.dx=0;
+ 	vbh->info.dy=0; 
+ 	vbh->info.dz=0;
+ 
+ 
+ 
+ 	printf("uw_sink:source(%d,%d) send source-deny packet %d at %lf : the target is (%d,%d)\n", vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num, NOW, vbh->target_id.addr_,vbh->target_id.port_);
+ 
+ 	send(pkt, 0);	
+ 
+ }
+ 
+ 
+ 
+ void UWSinkAgent::bcast_interest()
+ {
+ 
+ 	Packet* pkt = create_packet();
+ 	// printf("uw_sink: the address of thenew packet is%d\n",pkt);
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	hdr_ip* iph = HDR_IP(pkt);
+ 
+ 	// Set message type, packet number and sender ID
+ 
+ 
+ 
+ 	iph->src_=here_;
+ 	iph->dst_.addr_=here_.addr_;
+ 	iph->dst_.port_=255;
+ 
+ 	vbh->mess_type = INTEREST;
+ 	vbh->pk_num = pk_count;
+ 	pk_count++;
+ 	vbh->sender_id = here_;	
+ 	// vbh->data_type = data_type_;
+ 	vbh->forward_agent_id = here_; 
+ 
+ 	vbh->target_id=target_id;
+ 
+ 	vbh->info.tx=target_x;
+ 	vbh->info.ty=target_y; 
+ 	vbh->info.tz=target_z;
+ 	vbh->range=range_;
+ 	vbh->ts_=NOW;
+ 
+ 
+ 	// Send the packet
+ 
+ 	vbh->info.ox=node->X();
+ 	vbh->info.oy=node->Y(); 
+ 	vbh->info.oz=node->Z();
+ 
+ 	/*
+ 	vbh->original_source.x=vbh->info.ox;
+ 	vbh->original_source.y=vbh->info.oy;
+ 	vbh->original_source.z=vbh->info.oz;
+ 	*/
+ 
+ 	vbh->info.dx=0;
+ 	vbh->info.dy=0; 
+ 	vbh->info.dz=0;
+ 
+ 
+ 
+ 	printf("uw_sink:source(%d,%d) send interest packet %d at %lf : the target is (%d,%d) coordinate is (%f,%f,%f)\n", vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num, NOW, vbh->target_id.addr_,vbh->target_id.port_,vbh->info.tx,vbh->info.ty, vbh->info.tz);
+ 
+ 
+ 
+ 	// printf("Sink %s send packet (%x, %d) at %f to %x.\n", 
+ 	//    name_, dfh->sender_id,
+ 	//     dfh->pk_num, 
+ 	//     NOW,
+ 	//     iph->dst_);
+ 	// printf("uw_sink:I am in the sendpk before send\n") ;
+ 
+ 	send(pkt, 0);	 
+ 
+ 	if (periodic_ == true)
+ 		periodic_timer_.resched(INTEREST_PERIOD);
+ }
+ 
+ 
+ /*
+ void UWSinkAgent::data_ready()
+ {
+ 
+ // Create a new packet
+ Packet* pkt = create_packet();
+ 
+ // Access the Sink header for the new packet:
+ hdr_uwvb* vbh = HDR_UWVB(pkt);
+ // hdr_ip* iph = HDR_IP(pkt);
+ 
+ // Set message type, packet number and sender ID
+ vbh->mess_type = DATA_READY;
+ vbh->pk_num = pk_count;
+ pk_count++;
+ vbh->sender_id = here_;	
+ vbh->data_type = data_type_;
+ vbh->forward_agent_id = here_; 
+ 
+ 
+ send(pkt, 0);
+ 
+ }
+ */
+ 
+ 
+ 
+ void UWSinkAgent::Terminate () 
+ {
+ 	FILE * fp;
+ 	if ((fp=fopen(f_name,"a"))==NULL){
+ 		printf("SINK %d can not open file\n", here_.addr_);
+ 		return;
+ 	}
+ 
+ #ifdef DEBUG_OUTPUT
+ 	printf("SINK(%d): terminates (send %d, recv %d, cum_delay %f)\n", 
+ 		here_.addr_, num_send, num_recv, cum_delay);
+ #endif
+ 	fprintf(fp,"SINK(%d) : num_send = %d, num_recv = %d, cum_delay = %f\n",
+ 		here_.addr_, num_send, num_recv, cum_delay);
+ 
+ 	printf("SINK %d : terminates (send %d, recv %d, cum_delay %f)\n", 
+ 		here_.addr_, num_send, num_recv, cum_delay);
+ 	int index=DataTable.current_index;
+ 
+ 	for(int i=0;i<index;i++){
+ 		//fprintf(fp,"SINK(%d) : send_id = %d, num_recv = %d\n", 
+ 		//	here_.addr_, DataTable.node(i), DataTable.number(i));
+ 		printf("SINK(%d) : send_id = %d, num_recv = %d\n", 
+ 			here_.addr_, DataTable.node(i), DataTable.number(i));
+ 	}
+ 
+ 	fclose(fp);
+ 	running_=0;
+ }
+ 
+ 
+ int UWSinkAgent::command(int argc, const char*const* argv)
+ {
+ 	Tcl& tcl = Tcl::instance();
+ 	if (argc == 2) {
+ 
+ 		if (strcmp(argv[1], "enable-duplicate") == 0) {
+ 			APP_DUP_ = true;
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "disable-duplicate") == 0) {
+ 			APP_DUP_ = false;
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "always-max-rate") == 0) {
+ 			//      always_max_rate_ = true;
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "terminate") == 0) {
+ 			Terminate();
+ 			return TCL_OK; 
+ 
+ 		}
+ 
+ 		if (strcmp(argv[1], "announce") == 0) {
+ 			bcast_interest();
+ 			// report_timer_.resched(REPORT_PERIOD);
+ 
+ 			return (TCL_OK);
+ 		}
+ 
+ 		if (strcmp(argv[1], "ready") == 0) {
+ 			//    God::instance()->data_pkt_size = size_;
+ 			data_ready();
+ 			return (TCL_OK);
+ 		}
+ 
+ 		if (strcmp(argv[1], "send") == 0) {
+ 			printf("before I am going into sendpk\n");
+ 			sendpkt();   
+ 			return (TCL_OK);
+ 		}
+ 
+ 		if (strcmp(argv[1], "cbr-start") == 0) {
+ 			start();
+ 			return (TCL_OK);
+ 		}
+ 
+ 		if (strcmp(argv[1], "exp-start") == 0) {
+ 			exponential_start();
+ 			return (TCL_OK);
+ 		}
+ 
+ 		if (strcmp(argv[1], "stop") == 0) {
+ 			stop();
+ 			report_timer_.force_cancel();
+ 			return (TCL_OK);
+ 		}
+ 
+ 	}
+ 
+ 	if (argc == 3) {
+ 
+ 		if (strcmp(argv[1], "setTargetAddress") == 0) {
+ 			target_id.addr_=atoi(argv[2]);
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "set-target-x") == 0) {
+ 			target_x=atoi(argv[2]);
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "set-target-y") == 0) {
+ 			target_y=atoi(argv[2]);
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "set-target-z") == 0) {
+ 			target_z=atoi(argv[2]);
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "set-range") == 0) {
+ 			// printf("I am set range part\n"); 
+ 			range_=atoi(argv[2]);
+ 
+ 			return TCL_OK;
+ 		}
+ 		if (strcmp(argv[1], "set-packetsize") == 0) {
+ 			// printf("I am set range part\n"); 
+ 			packetsize_=atoi(argv[2]);
+ 
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcmp(argv[1], "set-filename") == 0) {
+ 			// printf("I am set the filename to %s \n",argv[2]);
+ 			// printf("Old filename is %s \n",f_name); 
+ 			strcpy(f_name,argv[2]);
+ 			//  printf("Now  the filename is %s \n",f_name); 
+ 			return TCL_OK;
+ 		}
+ 		/*
+ 		if (strcmp(argv[1], "data-type") == 0) {
+ 		data_type_ = atoi(argv[2]);
+ 		return (TCL_OK);
+ 		}
+ 		*/ 
+ 
+ 		if (strcmp(argv[1], "on-node") == 0) {    
+ 			node= (UnderwaterSensorNode*) tcl.lookup(argv[2]); 
+ 			if(node==NULL)printf("uw_sink: node is empty\n"); 
+ 			return TCL_OK;
+ 		}
+ 		if (strcmp(argv[1], "attach-rt-agent") == 0) {
+ 			//    printf("uw_sink:attach-rt-agent is called \n");
+ 			TclObject *obj;
+ 
+ 			if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 				fprintf(stderr, "VSink node Node:: lookup  failed\n");
+ 				return TCL_ERROR;
+ 			}
+ 			target_ = (NsObject *) obj;
+ 			return TCL_OK;
+ 		}
+ 	}
+ 
+ 	if( argc == 6 ) {
+ 		if ( strcmp(argv[1], "set-sense-area") == 0 ) {
+ 			SenseAreaSet.insert(atof(argv[2]), atof(argv[3]), atof(argv[4]), atof(argv[5]));
+ 			return TCL_OK;
+ 		}
+ 	}
+ 	return (Agent::command(argc, argv));
+ }
+ 
+ 
+ void UWSinkAgent::recv(Packet* pkt, Handler*)
+ {
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 
+ 
+ 	// printf("SK %d recv (%x, %x, %d) %s size %d at time %lf\n", here_.addr_, 
+ 	// (dfh->sender_id).addr_, (dfh->sender_id).port_,
+ 	// dfh->pk_num, MsgStr[dfh->mess_type], cmh->size(), NOW);
+ 
+ 	/*
+ 	if (data_type_ != vbh->data_type) {
+ 	printf("SINK: Hey, What are you doing? I am not a sink for %d. I'm a sink for %d. \n", vbh->data_type, data_type_);
+ 	Packet::free(pkt);
+ 	return;
+ 	}
+ 	*/
+ 
+ 	// printf("UWSink: I get the packet  \n");
+ 	switch(vbh->mess_type) {
+ 		/*
+ 		case DATA_REQUEST :
+ 
+ 		if (always_max_rate_ == false)
+ 		simple_report_rate = vbh->report_rate;
+ 
+ 		if (!running_) start();
+ 
+ 		//      printf("I got a data request for data rate %d at %lf. Will send it right away.\n",
+ 		//	     simple_report_rate, NOW);
+ 
+ 		break;
+ 
+ 
+ 		case DATA_STOP :
+ 
+ 		if (running_) stop();
+ 		break;
+ 		*/
+ 	case DATA_READY :
+ 		printf("UWSink (id:%d)(%f,%f,%f): I get the data ready packet no.%d  \n",here_.addr_,node->CX(),node->CY(),node->CZ(), vbh->pk_num);
+ 
+ 		if(node->sinkStatus()){
+ 			passive=1;
+ 			// num_recv++;    
+ 			target_x=node->X()-node->CX();
+ 			target_y=node->Y()-node->CY();
+ 			target_z=node->Z()-node->CZ(); 
+ 			last_arrival_time = NOW;
+ 			target_id=vbh->sender_id;
+ 			bcast_interest();
+ 		}
+ 		else{
+ 
+ 			target_x=0;
+ 			target_y=0;
+ 			target_z=0; 
+ 			target_id=vbh->sender_id;
+ 			start();
+ 
+ 		}
+ 		break;
+ 
+ 
+ 
+ 
+ 
+ 	case INTEREST:
+ 
+ 		num_recv++;    
+ 		target_id=vbh->sender_id;
+ 		target_x=vbh->info.ox;
+ 		target_y=vbh->info.oy;
+ 		target_z=vbh->info.oz;
+ 		running_=1;
+ 
+ 		start();
+ 
+ 		break;
+ 
+ 	case DATA :
+ 	case TARGET_DISCOVERY:
+ 		{    //printf("uw_sink: the source is out of scope %d\n",passive);
+ 
+ 			if(!passive){
+ 				if(IsDeviation()) 
+ 				{
+ 					printf("uw_sink: the source is out of scope\n");
+ 					double x=node->X()-node->CX();
+ 					double y=node->Y()-node->CY();
+ 					double z=node->Z()-node->CZ(); 
+ 					ns_addr_t id=vbh->sender_id;
+ 					source_deny(id,x,y,z);
+ 					bcast_interest();   
+ 				}
+ 			}
+ 
+ 			printf("UWSink (id:%d): I get the packet data no.%d from %d \n",here_.addr_, vbh->pk_num,vbh->forward_agent_id.addr_);       
+ 			cum_delay = cum_delay + (NOW - vbh->ts_);
+ 			num_recv++;
+ 			// RecvPerSec++;
+ 			//      God::instance()->IncrRecv();
+ 
+ 			//        int* sender_addr=new int[1];
+ 			// sender_addr[0]=vbh->sender_id.addr_;
+ 
+ 			int sender_addr=vbh->sender_id.addr_;
+ 
+ 			DataTable.PutInHash(sender_addr);
+ 
+ 			if (last_arrival_time > 0.0) {
+ 				printf("SK %d: Num_Recv %d, InterArrival %lf\n", here_.addr_, 
+ 					num_recv, (NOW)-last_arrival_time);
+ 			}
+ 
+ 			last_arrival_time = NOW;
+ 
+ 			break;
+ 		}  
+ 	default:
+ 
+ 		break;
+ 	}
+ 
+ 	Packet::free(pkt);
+ }
+ 
+ 
+ bool UWSinkAgent::IsDeviation(){
+ 	double dx=node->CX()-node->X();
+ 	double dy=node->CY()-node->Y();
+ 	double dz=node->CZ()-node->Z();
+ 	if(sqrt((dx*dx)+(dy*dy)+(dz*dz))<range_) return false;
+ 	return true;
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ void UWSinkAgent::reset()
+ {
+ }
+ 
+ 
+ void UWSinkAgent:: set_addr(ns_addr_t address)
+ {
+ 	here_=address;
+ }
+ 
+ 
+ int UWSinkAgent:: get_pk_count()
+ {
+ 	return pk_count;
+ }
+ 
+ 
+ void UWSinkAgent:: incr_pk_count()
+ {
+ 	pk_count++;
+ }  
+ 
+ Packet * UWSinkAgent:: create_packet()
+ {
+ 	Packet *pkt = allocpkt();
+ 
+ 	if (pkt==NULL) return NULL;
+ 
+ 	hdr_cmn*  cmh = HDR_CMN(pkt);
+ 
+ 	cmh->size() = 0;  // the control packet size is determined by the vbf header
+ 	cmh->ptype()=PT_UWVB;
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	vbh->ts_ = NOW; 
+ 	return pkt;
+ }
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_common/uw_sink.h ns-2.35-aquasim/underwatersensor/uw_common/uw_sink.h
*** ns-2.35/underwatersensor/uw_common/uw_sink.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/uw_sink.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,189 ----
+ 
+ #ifndef ns_uw_sink_h
+ #define ns_uw_sink_h
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "packet.h"
+ #include "ip.h"
+ #include "uw_hash_table.h"
+ #include "underwatersensornode.h"
+ #include "underwatersensor/uw_routing/vectorbasedforward.h"
+ 
+ #include <set>
+ using namespace std;
+ 
+ 
+ 
+ class UWSinkAgent;
+ 
+ // Timer for packet rate
+ 
+ class UWSink_Timer : public TimerHandler {
+  public:
+ 	UWSink_Timer(UWSinkAgent *a) : TimerHandler() { a_ = a; }
+  protected:
+ 	virtual void expire(Event *e);
+ 	UWSinkAgent *a_;
+ };
+ 
+ 
+ // For periodic report of avg and var pkt received.
+ 
+ class UWReport_Timer : public TimerHandler {
+  public:
+ 	UWReport_Timer(UWSinkAgent *a) : TimerHandler() { a_ = a; }
+  protected:
+ 	virtual void expire(Event *e);
+ 	UWSinkAgent *a_;
+ };
+ 
+ 
+ // Timer for periodic interest
+ 
+ class UWPeriodic_Timer : public TimerHandler {
+  public:
+ 	UWPeriodic_Timer(UWSinkAgent *a) : TimerHandler() { a_ = a; }
+  protected:
+ 	virtual void expire(Event *e);
+ 	UWSinkAgent *a_;
+ };
+ 
+ struct sense_area_elem{
+ 	double sense_x;
+ 	double sense_y;
+ 	double sense_z;
+ 	double sense_r;
+ 	sense_area_elem(double x, double y, double z, double r) {
+ 		sense_x = x;
+ 		sense_y = y;
+ 		sense_z = z;
+ 		sense_r = r;
+ 	}
+ 
+ 	friend bool operator<(const sense_area_elem&  e1, const sense_area_elem& e2);
+ };
+ 
+ class SenseArea{
+ private:
+ 	set<sense_area_elem> AreaSet;
+ public:
+ 	bool IsInSenseArea(double nx, double ny, double nz);
+ 	void insert(double x, double y, double z, double r);
+ };
+ 
+ 
+ // Class SinkAgent as source and sink for directed diffusion
+ 
+ class UWSinkAgent : public Agent {
+ 
+  public:
+   UWSinkAgent();
+   int command(int argc, const char*const* argv);
+   virtual void timeout(int);
+ 
+   void report();
+   void recv(Packet*, Handler*);
+   void reset();
+   void set_addr(ns_addr_t);
+   int get_pk_count();
+   void incr_pk_count();
+   Packet *create_packet();
+ 
+  protected:
+   bool APP_DUP_;
+   bool periodic_;
+   static int pkt_id_;  
+   //bool always_max_rate_;
+   int pk_count;
+ //  unsigned int data_type_;
+   int num_recv;
+   int num_send;
+   // int RecvPerSec; //? what's this for
+ 
+   /*used ti indicate if the sink is active, send out interest first or 
+ passive, it gets the data ready and then sends out the interest. 1 is passive 
+ and 0 is active.*/
+   
+   int passive;
+ 
+ 	double target_x;
+ 	double target_y;
+ 	double target_z;
+ 	double range_;
+ 
+ 	
+ 	int ActiveSense;
+ 	SenseArea SenseAreaSet;
+ 	double SenseInterval;
+  
+   ns_addr_t target_id;
+   
+   char   f_name[80];
+ 
+   //the monitoring area. nodes within this area will send
+   double sense_x;
+   double sense_y;
+   double sense_z;
+   double sense_r;
+ 
+   UnderwaterSensorNode* node;
+  
+   double cum_delay;
+   double last_arrival_time;
+ 
+   UW_Hash_Table  DataTable;
+ 
+   bool IsDeviation();
+   void Terminate();
+   void bcast_interest();
+   void source_deny(ns_addr_t,double,double,double);
+   void data_ready();
+   void start();
+   void generateInterval();
+   void exponential_start();
+   void stop();
+   virtual void sendpkt();
+ 
+ 
+   int running_;
+   int random_;   //1 is random; 2 is exponential distribution
+   int maxpkts_;
+  
+  
+   double interval_; // interval to send data pkt
+   double explore_interval;
+   double data_interval;
+   double  data_rate_;
+ 
+   int packetsize_;  // # of bytes in the packet
+   int explore_rate;
+   int data_counter;
+   int  explore_counter;
+   int explore_status;
+  
+   //int simple_report_rate;
+     //  int data_counter;
+  
+   UWSink_Timer sink_timer_;
+   UWPeriodic_Timer periodic_timer_;
+   UWReport_Timer report_timer_;
+ 
+   friend class UWPeriodic_Timer;
+ };
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_common/uw_sink_vbva.cc ns-2.35-aquasim/underwatersensor/uw_common/uw_sink_vbva.cc
*** ns-2.35/underwatersensor/uw_common/uw_sink_vbva.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/uw_sink_vbva.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,739 ----
+ #include <stdlib.h>
+ #include <tcl.h>
+ #include <stdio.h>
+ 
+ #include "uw_sink_vbva.h"
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "random.h"
+ 
+ 
+ #define REPORT_PERIOD     2
+ #define INTEREST_PERIOD   2
+ 
+ 
+ void UW_VBVA_Report_Timer::expire(Event *) {
+   a_->report();
+ }
+ 
+ 
+ void UW_VBVA_Sink_Timer::expire(Event *) {
+   a_->timeout(0);
+ }
+ 
+ void UW_VBVA_Periodic_Timer::expire(Event *) {
+   a_->bcast_interest();
+ }
+ 
+ static class UW_VBVA_SinkClass : public TclClass {
+ public:
+   UW_VBVA_SinkClass() : TclClass("Agent/UW_VBVA_Sink") {}
+   TclObject* create(int , const char*const* ) {
+     return(new UW_VBVA_SinkAgent());
+   }
+ } class_uw_vbva_sink;
+ 
+ 
+ int UW_VBVA_SinkAgent::pkt_id_ = 0;
+ 
+ UW_VBVA_SinkAgent::UW_VBVA_SinkAgent() : Agent(PT_UWVB), 
+   running_(0), random_(0), sink_timer_(this), periodic_timer_(this),
+   report_timer_(this)
+ {
+  
+   APP_DUP_ = true; // allow duplication 
+ 
+   periodic_ = false; //just send out interest once
+   
+ 
+   maxpkts_ = 1000;
+   pk_count=0;
+   num_recv=0;
+   num_send=0;
+ 
+ 
+   strcpy(f_name,"test.data");
+ 
+   target_x=0;
+   target_y=0;
+   target_z=0;
+   target_id.addr_=0;
+   target_id.port_=0; 
+ 
+ 
+ 
+   passive=0;
+   cum_delay=0.0;
+ 
+   bind_time("data_rate_", &data_rate_);
+   bind("packetsize_", &packetsize_);
+   bind("random_", &random_);
+   bind("passive",&passive);
+   
+   data_counter = 0;
+   
+   last_arrival_time = -1.0;
+ }
+ 
+ void UW_VBVA_SinkAgent::start()
+ {
+ 	running_ = 1;
+         interval_=1.0/data_rate_;
+         random_=0;	
+ 	sendpkt();
+ 	sink_timer_.resched(interval_);
+ }
+ 
+ void UW_VBVA_SinkAgent::exponential_start()
+ {
+         random_=2;
+ 	running_ = 1;	
+ 	generateInterval();
+ 	sink_timer_.resched(interval_);
+ }
+ 
+ void 
+ UW_VBVA_SinkAgent::generateInterval()
+ {
+    double R=Random::uniform();
+    double lambda=data_rate_;
+     interval_=-log(R)/lambda;
+     // printf("\nuwsink: !!!!!!!!generateInterval the  inetrval is %f\n",interval_);
+     return; 
+ }
+ 
+ void UW_VBVA_SinkAgent::stop()
+ {
+   if (running_) {
+ 	running_ = 0;
+   }
+   
+   if (periodic_ == true) {
+     periodic_ = false;
+     periodic_timer_.force_cancel();
+   }
+ }
+ 
+ 
+ void UW_VBVA_SinkAgent::report()
+ {
+   printf("SK %d:  at time %lf\n", here_.addr_,  NOW);
+   report_timer_.resched(REPORT_PERIOD);
+   // RecvPerSec = 0;
+ }
+ 
+ 
+ void UW_VBVA_SinkAgent::timeout(int)
+ {
+ 	if (running_) {
+ 		sendpkt();
+ 		double t = interval_;
+ 		if (random_==1)
+ 			/* add some zero-mean white noise */
+ 			t += interval_ * Random::uniform(-0.5, 0.5);
+                 if(random_==2) {
+ 		  generateInterval();
+                          t=interval_;
+                          
+ 		}
+ 		  sink_timer_.resched(t);
+ 	}
+ }
+ 
+ 
+ void UW_VBVA_SinkAgent::sendpkt()
+ {
+  
+      Packet* pkt = Packet::alloc();
+       hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+        hdr_ip* iph = HDR_IP(pkt);
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+      
+ 
+       cmh->ptype()=PT_UWVB;
+       cmh->size() = packetsize_*8;
+       cmh->uid() = pkt_id_++;
+       vbh->mess_type = DATA;
+       vbh->pk_num = pk_count;
+       vbh->ts_=NOW;
+       pk_count++;
+ 
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+ 
+       vbh->sender_id = here_;
+       // vbh->data_type = data_type_;
+       vbh->forward_agent_id = here_; 
+ 
+       vbh->target_id=target_id;
+       vbh->range=range_;
+ 
+ 
+     vbh->info.tx=target_x;
+     vbh->info.ty=target_y; 
+     vbh->info.tz=target_z;
+      
+     vbh->info.fx=node->CX();
+     vbh->info.fy=node->CY();
+     vbh->info.fz=node->CZ();
+ 
+      vbh->info.ox=node->CX();
+      vbh->info.oy=node->CY(); 
+      vbh->info.oz=node->CZ();
+ 
+      vbh->info.dx=0;
+      vbh->info.dy=0; 
+      vbh->info.dz=0;
+ 
+      /*     
+      vbh->original_source.x=vbh->info.fx;
+      vbh->original_source.y=vbh->info.fy;
+      vbh->original_source.z=vbh->info.fz;
+      */
+      
+       printf("uw_sink:source(%d,%d) send packet %d at %lf : the coordinates of target is (%lf,%lf,%lf) and range=%lf and my position (%f,%f,%f) and cx is(%f,%f,%f)  type is %d\n", vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num, NOW, vbh->info.tx=target_x,vbh->info.ty=target_y, vbh->info.tz=target_z,vbh->range,node->X(),node->Y(),node->Z(),node->CX(),node->CY(),node->CZ(),vbh->mess_type);
+      
+ 
+ 
+    
+       num_send++;
+       //   vbh->attr[0] = data_type_;
+   
+      
+       if (target_==NULL)  printf("The target_ is empty\n");
+ 	 else { 
+ 	   printf("The target_ is not  empty\n");
+          send(pkt, 0);
+          }
+         printf("I exit the sendpk\n"); 
+ 
+ 
+ }
+ 
+ 
+ 
+ void UW_VBVA_SinkAgent::data_ready()
+ {
+   
+   // printf("I am in the sendpk1 \n");
+       if (pk_count >=  maxpkts_) {
+         running_ = 0;
+         return;
+           
+      }
+       // printf("I am in the sendpk2 \n");
+        Packet* pkt = create_packet();
+       hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+       hdr_ip* iph = HDR_IP(pkt);
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+ 
+     
+       vbh->mess_type = DATA_READY;
+       vbh->pk_num = pk_count;
+ 
+       pk_count++;
+ 
+       
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+ 
+ 
+       vbh->sender_id = here_;
+       //      vbh->data_type = data_type_;
+       vbh->forward_agent_id = here_; 
+ 
+       vbh->target_id=target_id;
+       vbh->range=range_;
+       vbh->ts_=NOW;
+       
+       printf("uw_sink:source(%d,%d)(%f,%f,%f) send data ready packet %d at %lf : the target is (%d,%d)\n", vbh->sender_id.addr_,vbh->sender_id.port_,node->X(),node->Y(),node->Z(),vbh->pk_num, NOW, vbh->target_id.addr_,vbh->target_id.port_);
+ 
+ 
+       // Send the packet
+       // printf("Source %s send packet ( %x,%d) at %lf.\n", name(), 
+       // vbh->sender_id, vbh->pk_num, NOW);
+ 
+ 
+       //  num_send++;
+       //      vbh->attr[0] = data_type_;
+   
+      
+ 
+      
+       if (target_==NULL)  printf("The target_ is empty\n");
+ 	 else {
+ 	   printf("The target_ is not  empty\n");
+          send(pkt, 0);
+          }
+ 	 // printf("I exit the sendpk \n");
+ }
+ 
+ 
+ 
+ 
+ void UW_VBVA_SinkAgent::source_deny(ns_addr_t id, double x, double y, double z)
+ {
+    
+ 
+       Packet* pkt = create_packet();
+       hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+       hdr_ip* iph = HDR_IP(pkt);
+ 
+       // Set message type, packet number and sender ID
+       vbh->mess_type = SOURCE_DENY;
+       vbh->pk_num = pk_count;
+       pk_count++;
+ 
+ 
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+       
+       vbh->sender_id = here_;	
+       //      vbh->data_type = data_type_;
+       vbh->forward_agent_id = here_; 
+ 
+       vbh->target_id=id;
+     
+ 
+      
+       vbh->info.tx=x;
+       vbh->info.ty=y; 
+       vbh->info.tz=z;
+       vbh->range=range_;
+       vbh->ts_=NOW;
+      
+ 
+       // Send the packet
+ 
+       vbh->info.ox=node->X();
+       vbh->info.oy=node->Y(); 
+       vbh->info.oz=node->Z();
+ 
+       /* 
+       vbh->original_source.x=vbh->info.ox;
+       vbh->original_source.y=vbh->info.oy;
+       vbh->original_source.z=vbh->info.oz;
+       */
+ 
+       vbh->info.dx=0;
+       vbh->info.dy=0; 
+       vbh->info.dz=0;
+ 
+       
+ 
+   printf("uw_sink:source(%d,%d) send source-deny packet %d at %lf : the target is (%d,%d)\n", vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num, NOW, vbh->target_id.addr_,vbh->target_id.port_);
+ 
+          send(pkt, 0);	
+       
+       
+ }
+ 
+ 
+ 
+ void UW_VBVA_SinkAgent::bcast_interest()
+ {
+   
+       Packet* pkt = create_packet();
+      
+       hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+       hdr_ip* iph = HDR_IP(pkt);
+ 
+       // Set message type, packet number and sender ID
+       
+ 
+ 
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+ 
+        vbh->mess_type = INTEREST;
+       vbh->pk_num = pk_count;
+       pk_count++;
+       vbh->sender_id = here_;	
+       // vbh->data_type = data_type_;
+       vbh->forward_agent_id = here_; 
+ 
+       vbh->target_id=target_id;
+        
+       vbh->info.tx=target_x;
+       vbh->info.ty=target_y; 
+       vbh->info.tz=target_z;
+       vbh->range=range_;
+       vbh->ts_=NOW;
+      
+ 
+       // Send the packet
+ 
+       vbh->info.ox=node->X();
+       vbh->info.oy=node->Y(); 
+       vbh->info.oz=node->Z();
+       vbh->info.dx=0;
+       vbh->info.dy=0; 
+       vbh->info.dz=0;
+ 
+ 
+ 
+   printf("uw_sink:source(%d,%d) send interest packet %d at %lf : the target is (%d,%d) coordinate is (%f,%f,%f)\n", vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num, NOW, vbh->target_id.addr_,vbh->target_id.port_,vbh->info.tx,vbh->info.ty, vbh->info.tz);
+ 
+       
+ 
+       // printf("Sink %s send packet (%x, %d) at %f to %x.\n", 
+       //    name_, dfh->sender_id,
+       //     dfh->pk_num, 
+       //     NOW,
+       //     iph->dst_);
+       // printf("uw_sink:I am in the sendpk before send\n") ;
+    
+          send(pkt, 0);	 
+ 
+      if (periodic_ == true)
+      periodic_timer_.resched(INTEREST_PERIOD);
+ }
+ 
+ 
+ 
+ 
+ void UW_VBVA_SinkAgent::Terminate () 
+ {
+    FILE * fp;
+   if ((fp=fopen(f_name,"a"))==NULL){
+   printf("SINK %d can not open file\n", here_.addr_);
+    return;
+   }
+ 
+ #ifdef DEBUG_OUTPUT
+   printf("SINK(%d): terminates (send %d, recv %d, cum_delay %f)\n", 
+ 	 here_.addr_, num_send, num_recv, cum_delay);
+ #endif
+ fprintf(fp,"SINK(%d) : num_send = %d, num_recv = %d, cum_delay = %f\n",
+ 	 here_.addr_, num_send, num_recv, cum_delay);
+ 
+ printf("SINK %d : terminates (send %d, recv %d, cum_delay %f)\n", 
+ 	 here_.addr_, num_send, num_recv, cum_delay);
+  int index=DataTable.current_index;
+ 
+  for(int i=0;i<index;i++){
+ fprintf(fp,"SINK(%d) : send_id = %d, num_recv = %d\n", 
+ 	 here_.addr_, DataTable.node(i), DataTable.number(i));
+ printf("SINK(%d) : send_id = %d, num_recv = %d\n", 
+ 	 here_.addr_, DataTable.node(i), DataTable.number(i));
+  }
+  
+  fclose(fp);
+  running_=0;
+ }
+ 
+ 
+ int UW_VBVA_SinkAgent::command(int argc, const char*const* argv)
+ {
+  Tcl& tcl = Tcl::instance();
+   if (argc == 2) {
+ 
+     if (strcmp(argv[1], "enable-duplicate") == 0) {
+       APP_DUP_ = true;
+       return TCL_OK;
+     }
+ 
+     if (strcmp(argv[1], "disable-duplicate") == 0) {
+       APP_DUP_ = false;
+       return TCL_OK;
+     }
+ 
+     if (strcmp(argv[1], "always-max-rate") == 0) {
+       //      always_max_rate_ = true;
+       return TCL_OK;
+     }
+ 
+     if (strcmp(argv[1], "terminate") == 0) {
+       Terminate();
+       return TCL_OK; 
+ 
+     }
+ 
+     if (strcmp(argv[1], "announce") == 0) {
+       bcast_interest();
+       // report_timer_.resched(REPORT_PERIOD);
+ 
+       return (TCL_OK);
+     }
+ 
+     if (strcmp(argv[1], "ready") == 0) {
+       //    God::instance()->data_pkt_size = size_;
+       data_ready();
+       return (TCL_OK);
+     }
+ 
+     if (strcmp(argv[1], "send") == 0) {
+       printf("before I am going into sendpk\n");
+       sendpkt();   
+       return (TCL_OK);
+     }
+ 
+     if (strcmp(argv[1], "cbr-start") == 0) {
+        start();
+        return (TCL_OK);
+     }
+  
+     if (strcmp(argv[1], "exp-start") == 0) {
+        exponential_start();
+        return (TCL_OK);
+     }
+   
+     if (strcmp(argv[1], "stop") == 0) {
+ 	stop();
+         report_timer_.force_cancel();
+ 	return (TCL_OK);
+     }
+ 
+   }
+ 
+   if (argc == 3) {
+ 
+  if (strcmp(argv[1], "setTargetAddress") == 0) {
+       target_id.addr_=atoi(argv[2]);
+       return TCL_OK;
+     }
+ 
+  if (strcmp(argv[1], "set-target-x") == 0) {
+       target_x=atoi(argv[2]);
+       return TCL_OK;
+     }
+ 
+  if (strcmp(argv[1], "set-target-y") == 0) {
+       target_y=atoi(argv[2]);
+       return TCL_OK;
+     }
+ 
+  if (strcmp(argv[1], "set-target-z") == 0) {
+       target_z=atoi(argv[2]);
+       return TCL_OK;
+     }
+ 
+  if (strcmp(argv[1], "set-range") == 0) {
+    // printf("I am set range part\n"); 
+         range_=atoi(argv[2]);
+     
+       return TCL_OK;
+     }
+  if (strcmp(argv[1], "set-packetsize") == 0) {
+    // printf("I am set range part\n"); 
+         packetsize_=atoi(argv[2]);
+     
+       return TCL_OK;
+     }
+ 
+  if (strcmp(argv[1], "set-filename") == 0) {
+      // printf("I am set the filename to %s \n",argv[2]);
+     // printf("Old filename is %s \n",f_name); 
+     strcpy(f_name,argv[2]);
+     //  printf("Now  the filename is %s \n",f_name); 
+       return TCL_OK;
+     }
+ /*
+     if (strcmp(argv[1], "data-type") == 0) {
+       data_type_ = atoi(argv[2]);
+       return (TCL_OK);
+     }
+ */ 
+ 
+  if (strcmp(argv[1], "on-node") == 0) {    
+    node= (UnderwaterSensorNode*) tcl.lookup(argv[2]); 
+    if(node==NULL)printf("uw_sink: node is empty\n"); 
+       return TCL_OK;
+  }
+   if (strcmp(argv[1], "attach-rt-agent") == 0) {
+     //    printf("uw_sink:attach-rt-agent is called \n");
+       TclObject *obj;
+ 
+       if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 	fprintf(stderr, "VSink node Node:: lookup  failed\n");
+ 	return TCL_ERROR;
+       }
+       target_ = (NsObject *) obj;
+       return TCL_OK;
+     }
+ }
+   return (Agent::command(argc, argv));
+ }
+ 
+ 
+ void UW_VBVA_SinkAgent::recv(Packet* pkt, Handler*)
+ {
+     hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+ 
+   
+     // printf("SK %d recv (%x, %x, %d) %s size %d at time %lf\n", here_.addr_, 
+     // (dfh->sender_id).addr_, (dfh->sender_id).port_,
+     // dfh->pk_num, MsgStr[dfh->mess_type], cmh->size(), NOW);
+   
+ /*
+       if (data_type_ != vbh->data_type) {
+       printf("SINK: Hey, What are you doing? I am not a sink for %d. I'm a sink for %d. \n", vbh->data_type, data_type_);
+     Packet::free(pkt);
+     return;
+     }
+ */
+ 
+   // printf("UWSink (%d): I get the packet  \n", here_.addr_);
+   switch(vbh->mess_type) {
+     /*
+     case DATA_REQUEST :
+            
+       if (always_max_rate_ == false)
+ 	simple_report_rate = vbh->report_rate;
+      
+       if (!running_) start();
+ 
+       //      printf("I got a data request for data rate %d at %lf. Will send it right away.\n",
+       //	     simple_report_rate, NOW);
+       
+       break;
+       
+     
+     case DATA_STOP :
+ 
+       if (running_) stop();
+       break;
+     */
+     case DATA_READY :
+  printf("UWSink (id:%d)(%f,%f,%f): I get the data ready packet no.%d  \n",here_.addr_,node->CX(),node->CY(),node->CZ(), vbh->pk_num);
+  
+  if(node->sinkStatus()){
+     passive=1;
+     // num_recv++;    
+     target_x=node->X()-node->CX();
+     target_y=node->Y()-node->CY();
+     target_z=node->Z()-node->CZ(); 
+     last_arrival_time = NOW;
+     target_id=vbh->sender_id;
+     bcast_interest();
+  }
+  else{
+ 
+     target_x=0;
+     target_y=0;
+     target_z=0; 
+     target_id=vbh->sender_id;
+     start();
+ 
+  }
+   break;
+ 
+   case INTEREST:
+     
+     num_recv++;    
+     target_id=vbh->sender_id;
+     target_x=vbh->info.ox;
+     target_y=vbh->info.oy;
+     target_z=vbh->info.oz;
+     running_=1;
+     
+         start();
+     
+     break;
+ 
+   case DATA :
+   case TARGET_DISCOVERY:
+ {    //printf("uw_sink: the source is out of scope %d\n",passive);
+     
+       if(!passive){
+       if(IsDeviation()) 
+ 	{
+          printf("uw_sink: the source is out of scope\n");
+     double x=node->X()-node->CX();
+     double y=node->Y()-node->CY();
+     double z=node->Z()-node->CZ(); 
+     ns_addr_t id=vbh->sender_id;
+     source_deny(id,x,y,z);
+     bcast_interest();   
+ 	}
+       }
+      
+      printf("UWSink (id:%d): I get the packet data no.%d from %d \n",here_.addr_, vbh->pk_num,vbh->forward_agent_id.addr_);       
+       cum_delay = cum_delay + (NOW - vbh->ts_);
+       num_recv++;
+       // RecvPerSec++;
+       //      God::instance()->IncrRecv();
+  
+       //        int* sender_addr=new int[1];
+       // sender_addr[0]=vbh->sender_id.addr_;
+ 
+ 	  int sender_addr=vbh->sender_id.addr_;
+ 
+ 	   DataTable.PutInHash(sender_addr);
+ 	 
+       if (last_arrival_time > 0.0) {
+ 	printf("SK %d: Num_Recv %d, InterArrival %lf\n", here_.addr_, 
+ 	       num_recv, (NOW)-last_arrival_time);
+       }
+     
+     last_arrival_time = NOW;
+ 
+     break;
+ }  
+     default:
+ 
+      break;
+     }
+ 
+   Packet::free(pkt);
+ }
+ 
+ 
+ bool UW_VBVA_SinkAgent::IsDeviation(){
+   double dx=node->CX()-node->X();
+   double dy=node->CY()-node->Y();
+   double dz=node->CZ()-node->Z();
+   if(sqrt((dx*dx)+(dy*dy)+(dz*dz))<range_) return false;
+   return true;
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ void UW_VBVA_SinkAgent::reset()
+ {
+ }
+ 
+ 
+ void UW_VBVA_SinkAgent:: set_addr(ns_addr_t address)
+ {
+   here_=address;
+ }
+ 
+ 
+ int UW_VBVA_SinkAgent:: get_pk_count()
+ {
+   return pk_count;
+ }
+ 
+ 
+ void UW_VBVA_SinkAgent:: incr_pk_count()
+ {
+   pk_count++;
+ }
+ 
+ 
+ Packet * UW_VBVA_SinkAgent:: create_packet()
+ {
+   Packet *pkt = allocpkt();
+ 
+   if (pkt==NULL) return NULL;
+ 
+   hdr_cmn*  cmh = HDR_CMN(pkt);
+ 
+   cmh->size() = 36;
+   cmh->ptype()=PT_UWVBVA;
+    hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+    vbh->ts_ = NOW; 
+   return pkt;
+ }
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_common/uw_sink_vbva.h ns-2.35-aquasim/underwatersensor/uw_common/uw_sink_vbva.h
*** ns-2.35/underwatersensor/uw_common/uw_sink_vbva.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_common/uw_sink_vbva.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,144 ----
+ #ifndef ns_uw_sink_vbva_h
+ #define ns_uw_sink_vbva_h
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "packet.h"
+ #include "ip.h"
+ #include "uw_hash_table.h"
+ #include "underwatersensornode.h"
+ #include "underwatersensor/uw_routing/vectorbasedvoidavoidance.h"
+ 
+ class UW_VBVA_SinkAgent;
+ 
+ // Timer for packet rate
+ 
+ class UW_VBVA_Sink_Timer : public TimerHandler {
+  public:
+ 	UW_VBVA_Sink_Timer(UW_VBVA_SinkAgent *a) : TimerHandler() { a_ = a; }
+  protected:
+ 	virtual void expire(Event *e);
+ 	UW_VBVA_SinkAgent *a_;
+ };
+ 
+ 
+ // For periodic report of avg and var pkt received.
+ 
+ class UW_VBVA_Report_Timer : public TimerHandler {
+  public:
+ 	UW_VBVA_Report_Timer(UW_VBVA_SinkAgent *a) : TimerHandler() { a_ = a; }
+  protected:
+ 	virtual void expire(Event *e);
+ 	UW_VBVA_SinkAgent *a_;
+ };
+ 
+ 
+ // Timer for periodic interest
+ 
+ class UW_VBVA_Periodic_Timer : public TimerHandler {
+  public:
+     UW_VBVA_Periodic_Timer(UW_VBVA_SinkAgent *a) : TimerHandler() { a_ = a; }
+  protected:
+ 	virtual void expire(Event *e);
+ 	UW_VBVA_SinkAgent *a_;
+ };
+ 
+ 
+ // Class SinkAgent as source and sink for directed diffusion
+ 
+ class UW_VBVA_SinkAgent : public Agent {
+ 
+  public:
+   UW_VBVA_SinkAgent();
+   int command(int argc, const char*const* argv);
+   virtual void timeout(int);
+ 
+   void report();
+   void recv(Packet*, Handler*);
+   void reset();
+   void set_addr(ns_addr_t);
+   int get_pk_count();
+   void incr_pk_count();
+   Packet *create_packet();
+ 
+  protected:
+   static int pkt_id_;
+   bool APP_DUP_;
+   bool periodic_;
+   //bool always_max_rate_;
+   int pk_count;
+   //  unsigned int data_type_;
+   int num_recv;
+   int num_send;
+   //  int RecvPerSec; //? what's this for
+ 
+   /*used ti indicate if the sink is active, send out interest first or 
+ passive, it gets the data ready and then sends out the interest. 1 is passive 
+ and 0 is active.*/
+   
+   int passive;
+ 
+ 
+  
+   ns_addr_t target_id;
+   double target_x;
+   double target_y;
+   double target_z;
+   double range_;
+   char   f_name[80];
+ 
+   UnderwaterSensorNode* node;
+  
+   double cum_delay;
+   double last_arrival_time;
+ 
+   UW_Hash_Table DataTable;
+   bool IsDeviation();
+   void Terminate();
+   void bcast_interest();
+   void source_deny(ns_addr_t,double,double,double);
+   void data_ready();
+   void start();
+    void generateInterval();
+   void exponential_start();
+   void stop();
+   virtual void sendpkt();
+ 
+   int running_;
+   int random_;
+   int maxpkts_;
+ 
+   double interval_; // interval to send data pkt
+   double explore_interval;
+   double data_interval;
+   double  data_rate_;
+   
+ 
+  int packetsize_;  // # of bytes in the packet
+   int explore_rate;
+   int data_counter;
+   int  explore_counter;
+   int explore_status;
+ 
+   
+   UW_VBVA_Sink_Timer sink_timer_;
+   UW_VBVA_Periodic_Timer periodic_timer_;
+   UW_VBVA_Report_Timer report_timer_;
+   friend class UW_VBVA_Periodic_Timer;
+ };
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/broadcastmac.cc ns-2.35-aquasim/underwatersensor/uw_mac/broadcastmac.cc
*** ns-2.35/underwatersensor/uw_mac/broadcastmac.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/broadcastmac.cc	2016-09-03 00:35:41.880000000 +0800
***************
*** 0 ****
--- 1,216 ----
+ #include "packet.h"
+ #include "random.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "mac.h"
+ #include "broadcastmac.h"
+ #include "underwaterphy.h"
+ 
+ 
+ StatusHandler:: StatusHandler(BroadcastMac*  p):mac_(p){}
+ 
+ void StatusHandler::handle(Event* e)
+ { 
+ 	mac_->StatusProcess(e); 
+ }
+ 
+ CallbackHandler:: CallbackHandler(BroadcastMac*  p):mac_(p){}
+ 
+ void CallbackHandler::handle(Event* e)
+ { 
+ 	mac_->CallbackProcess(e); 
+ }
+ 
+ 
+ BackoffHandler::BackoffHandler(BroadcastMac* p):mac_(p){counter=0;}
+ 
+ void BackoffHandler::handle(Event* e)
+ { 
+ 	counter++;
+ 	if(counter<MAXIMUMCOUNTER)
+ 		mac_->TxProcess((Packet*)e);
+ 	else 
+ 	{
+ 		clear();
+ 		printf("backoffhandler: too many backoffs\n");
+ 		mac_->CallbackProcess(e);
+ 		mac_->DropPacket((Packet*) e);
+ 	}
+ }
+ 
+ void BackoffHandler::clear()
+ { 
+ 	counter=0;
+ }
+ 
+ 
+ 
+ /* ======================================================================
+ Broadcast MAC for  underwater sensor
+ ====================================================================== */
+ static class BroadcastMacClass : public TclClass {
+ public:
+ 	BroadcastMacClass():TclClass("Mac/UnderwaterMac/BroadcastMac") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new BroadcastMac());
+ 	}
+ }class_broadcastmac;
+ 
+ 
+ BroadcastMac::BroadcastMac() : UnderwaterMac(),status_handler(this),backoff_handler(this),callback_handler(this)
+ {
+ 	bind("packetheader_size_",&packetheader_size_); 
+ 	bind("packet_size_", &packet_size_);
+ }
+ 
+ /*
+ this program is used to handle the received packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ BroadcastMac::RecvProcess(Packet* pkt){
+ 	char* mh=(char*)pkt->access(hdr_mac::offset_);
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+ 	assert(initialized());
+ 	int dst=this->hdr_dst(mh);
+ 	
+ 	//get a packet from modem, remove the sync hdr from txtime first
+ 	//cmh->txtime() -= getSyncHdrLen();
+ 
+ 	if (cmh->error()) 
+ 	{
+ //		printf("broadcast:node %d  gets a corrupted packet at  %f\n",index_,NOW);
+ 		if(drop_) drop_->recv(pkt,"Error/Collision");
+ 		else Packet::free(pkt);
+ 		return;
+ 	}
+ 
+ 	if(dst==(int)MAC_BROADCAST || dst == index_ ){
+ 		if( packet_size_ ==0 ) {
+ 			cmh->size() -= packetheader_size_;
+ 		}
+ 		uptarget_->recv(pkt, this);
+ 		return;
+ 	}
+ 
+ //	printf("underwaterbroadcastmac: this is neither broadcast nor my packet, just drop it\n");
+ 	Packet::free(pkt);
+ 	return;
+ }
+ 
+ 
+ void 
+ BroadcastMac::DropPacket(Packet* pkt)
+ {
+ //	printf("broadcast:node %d  gets a stucked packet at  %f\n",index_,NOW);
+ 	if(drop_) drop_->recv(pkt,"Stucked");
+ 	else Packet::free(pkt);
+ 	return;
+ }
+ 
+ 
+ /*
+ this program is used to handle the transmitted packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ 
+ void 
+ BroadcastMac::TxProcess(Packet* pkt){
+ 
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 	hdr_mac* mach = hdr_mac::access(pkt);
+ 	
+ 	mach->macDA() = (int)MAC_BROADCAST;
+ 	mach->macSA() = index_;
+ 
+ 	assert(initialized());
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+ 
+ 	if( packet_size_ != 0 )
+ 		cmh->size() = packet_size_;
+ 	else
+ 		cmh->size()+=(packetheader_size_);
+ 
+ 
+ 
+ 	cmh->txtime()=getTxTime(pkt);
+ 
+ 	Scheduler& s=Scheduler::instance();
+ 	switch( n->TransmissionStatus() )
+ 	{
+ 	case SLEEP:
+ 		Poweron();
+ 	case IDL:
+ 		n->SetTransmissionStatus(SEND);
+ 		cmh->direction()=hdr_cmn::DOWN; 
+ 		cmh->addr_type()=NS_AF_ILINK;
+ 		//add the sync hdr
+ 		sendDown(pkt);
+ 		backoff_handler.clear();
+ 		s.schedule(&status_handler,&status_event,cmh->txtime());
+ 		return;
+ 	case RECV:
+ 		{
+ 			double backoff=Random::uniform()*BACKOFF;
+ 			s.schedule(&backoff_handler,(Event*) pkt,backoff);
+ 		}
+ 		return;
+ 	case SEND:
+ 		Packet::free(pkt);
+ 		return;
+ 	default:
+ 		/*
+ 		* all cases have been processed above, so simply return
+ 		*/
+ 		return;			
+ 	}
+ 
+ }
+ 
+ 
+ void 
+ BroadcastMac::CallbackProcess(Event* callback_event)
+ {
+ 	callback_->handle(callback_event);
+ 	return;
+ }
+ 
+ 
+ void 
+ BroadcastMac::StatusProcess(Event* p)
+ {
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	if(SLEEP==n->TransmissionStatus()){
+ 		Scheduler& s=Scheduler::instance();
+ 		s.schedule(&callback_handler,&callback_event,CALLBACK_DELAY);
+ 		return;
+ 	}
+ 	n->SetTransmissionStatus(IDL);
+ 	Scheduler& s=Scheduler::instance();
+ 	s.schedule(&callback_handler,&callback_event,CALLBACK_DELAY);
+ 	return;
+ }
+ 
+ 
+ 
+ int
+ BroadcastMac::command(int argc, const char*const* argv)
+ {
+ 	if(argc == 3) {
+ 		if (strcmp(argv[1], "node_on") == 0) {
+ 			Node* n1=(Node*) TclObject::lookup(argv[2]);
+ 			if (!n1) return TCL_ERROR;
+ 			node_ =n1; 
+ 			return TCL_OK;
+ 		}
+ 	}
+ 
+ 	return UnderwaterMac::command(argc, argv);
+ }
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/broadcastmac.h ns-2.35-aquasim/underwatersensor/uw_mac/broadcastmac.h
*** ns-2.35/underwatersensor/uw_mac/broadcastmac.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/broadcastmac.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,81 ----
+ #ifndef ns_broadcastmac_h
+ #define ns_broadcastmac_h
+ 
+ #include "underwatermac.h"
+ 
+ 
+ 
+ #define BACKOFF  0.1 // the maximum time period for backoff
+ #define MAXIMUMCOUNTER 4 // the maximum number of backoff
+ #define CALLBACK_DELAY 0.0001 // the interval between two consecutive sendings
+ 
+ 
+ class BroadcastMac;
+ 
+ class StatusHandler: public Handler{
+  public:
+   StatusHandler(BroadcastMac*);
+   void handle(Event*);
+  private:
+   BroadcastMac* mac_;
+ };
+ 
+ 
+ class CallbackHandler: public Handler{
+  public:
+   CallbackHandler(BroadcastMac*);
+   void handle(Event*);
+  private:
+   BroadcastMac* mac_;
+ };
+ 
+ 
+ 
+ class BackoffHandler: public Handler{
+  public:
+   BackoffHandler(BroadcastMac*);
+   void handle(Event*);
+   void clear();
+  private:
+   int counter;
+   BroadcastMac* mac_;
+ };
+ 
+ class BroadcastMac: public UnderwaterMac {
+    
+ public:
+         BroadcastMac();
+      
+       	int  command(int argc, const char*const* argv);
+         int packetheader_size_; //# of bytes in the header 
+ 		int packet_size_;  //to test the optimized length of packet
+ 
+         Event backoff_event;
+         Event status_event;
+         Event callback_event;
+ 
+         StatusHandler status_handler;
+         BackoffHandler backoff_handler; 
+         CallbackHandler callback_handler;
+ 
+         //Node* node(void) const {return node_;}
+         // to process the incomming packet
+         virtual  void RecvProcess(Packet*);
+         void StatusProcess(Event*);
+         void CallbackProcess(Event*);
+         void DropPacket(Packet*);
+ 
+        // to process the outgoing packet
+         virtual  void TxProcess(Packet*);
+ 
+ protected:        
+ 	inline int initialized() {
+ 	return  UnderwaterMac::initialized();
+ 	}
+  private:
+         friend class StatusHandler;
+         friend class BackoffHandler;
+ };
+ 
+ #endif /* __broadcastmac_h__ */
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/COPEMAC/copemac.cc ns-2.35-aquasim/underwatersensor/uw_mac/COPEMAC/copemac.cc
*** ns-2.35/underwatersensor/uw_mac/COPEMAC/copemac.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/COPEMAC/copemac.cc	2016-09-03 00:43:03.236000000 +0800
***************
*** 0 ****
--- 1,1382 ----
+ #include "copemac.h"
+ #include "underwatersensor/uw_routing/vectorbasedforward.h"
+ 
+ int hdr_otman::offset_;
+ static class OTMAN_HeaderClass: public PacketHeaderClass{
+ public:
+ 	OTMAN_HeaderClass():PacketHeaderClass("PacketHeader/OTMAN",sizeof(hdr_otman))
+ 	{
+ 		bind_offset(&hdr_otman::offset_);
+ 	}
+ }class_otman_hdr;
+ 
+ static class OTMANClass : public TclClass {
+ public:
+ 	OTMANClass():TclClass("Mac/UnderwaterMac/OTMAN") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new OTMAN());
+ 	}
+ }class_otman;
+ 
+ 
+ 
+ 
+ void OTMAN_CallbackHandler::handle(Event* e)
+ {
+ 	mac_->CallbackProcess(e);
+ }
+ 
+ void OTMAN_StatusHandler::handle(Event *e)
+ {
+ 	mac_->StatusProcess(e);
+ }
+ 
+ 
+ void OTMAN_SendDelayHandler::handle(Event *e)
+ {
+ 	mac_->SendPkt( (Packet*)e );
+ }
+ 
+ 
+ void OTMAN_BackoffHandler::handle(Event* e)
+ {
+ 	counter++;
+ 	if(counter < MAXIMUMCOUNTER) {
+ 		mac_->TxProcess(pkt_);
+ 		pkt_ = NULL;
+ 	}
+ 	else 
+ 	{
+ 		clear();
+ 		printf("backoffhandler: too many backoffs\n");
+ 		if( mac_->drop_ )
+ 			mac_->drop_->recv(pkt_, "Backoff too many times");		
+ 		else
+ 			Packet::free(pkt_);
+ 	}
+ }
+ 
+ void OTMAN_BackoffHandler::clear()
+ {
+ 	counter = 0;
+ }
+ 
+ void OTMAN_NDProcess_Initor::expire(Event* e)
+ {
+ 	mac_->CtrlPktQ_.insert(mac_->makeND(), Random::uniform(mac_->NDWin));
+ 	mac_->ndreply_initor.resched(mac_->NDWin + 0.9); //1.0 is delay
+ 	MaxTimes_ --;
+ 	if( MaxTimes_ > 0 ) {
+ 		resched(mac_->NDInterval_);
+ 	}
+ }
+ 
+ void OTMAN_NDReply_Initor::expire(Event *e)
+ {
+ 	Packet* nd_reply = mac_->makeNDReply();
+ 	if( nd_reply != NULL ) {
+ 		mac_->CtrlPktQ_.insert(nd_reply, Random::uniform(mac_->NDReplyWin));
+ 		//mac_->PreSendPkt(nd_reply, Random::uniform(mac_->NDReplyWin));
+ 	}
+ }
+ 
+ 
+ void OTMAN_DataSendTimer::expire(Event* e)
+ {
+ 	resched(mac_->DataAccuPeriod+Random::uniform(2.0));
+ 	mac_->startHandShake();
+ }
+ 
+ void OTMAN_RevAckAccumTimer::expire(Event* e)
+ {
+ 	if( mac_->PendingRevs.size() != 0 ) {
+ 		Packet* tmp = mac_->makeMultiRevAck();
+ 		//mac_->PreSendPkt();
+ 		mac_->CtrlPktQ_.insert(tmp, 
+ 			mac_->RevQ_.getValidStartTime(HDR_CMN(tmp)->txtime()));
+ 		mac_->PendingRevs.clear();
+ 	}
+ }
+ 
+ void OTMAN_DataAckAccumTimer::expire(Event *e)
+ {
+ 	Packet* tmp = mac_->makeDataAck();
+ 	//mac_->PreSendPkt(mac_->makeDataAck());
+ 	mac_->CtrlPktQ_.insert(tmp, 
+ 			mac_->RevQ_.getValidStartTime(HDR_CMN(tmp)->txtime()));
+ 	mac_->PendingDataAcks.clear();
+ }
+ 
+ void OTMAN_InitiatorTimer::expire(Event *e)
+ {
+ 	mac_->start();
+ }
+ 
+ 
+ void PktWareHouse::insert2PktQs(Packet* pkt)
+ {
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 	PktElem* temp = new PktElem(pkt);
+ 
+ 	CachedPktNum_ ++;
+ 	if( Queues[cmh->next_hop()].head == NULL ) {
+ 		Queues[cmh->next_hop()].tail = temp;
+ 		Queues[cmh->next_hop()].head = temp;
+ 	} 
+ 	else {
+ 		Queues[cmh->next_hop()].tail->next_ = temp;
+ 		Queues[cmh->next_hop()].tail = temp;
+ 	}
+ }
+ 
+ bool PktWareHouse::deletePkt(nsaddr_t Recver, int SeqNum)
+ {
+ 
+ 	PktElem* pos = Queues[Recver].head;
+ 	PktElem* pre_pos = NULL;
+ 
+ 	while ( pos != NULL ) {
+ 		if( HDR_CMN(pos->pkt_)->uid() == SeqNum ) {
+ 			if( pre_pos == NULL ) {
+ 				Queues[Recver].head = pos->next_;
+ 			}
+ 			else {
+ 				pre_pos->next_ = pos->next_;
+ 			}
+ 
+ 			Packet::free(pos->pkt_);
+ 			pos->pkt_ == NULL;
+ 			delete pos;
+ 			CachedPktNum_ --;
+ 			return true;
+ 		}
+ 		pre_pos = pos;
+ 		pos = pos->next_;
+ 	}
+ 	
+ 	return false;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /**********************RevQueues******************************************/
+ RevElem::RevElem(){
+ 	send_timer = NULL;
+ 	next = NULL;
+ }
+ 
+ 
+ RevElem::RevElem(int RevID_, Time StartTime_, Time EndTime_, 
+ 				 nsaddr_t Reservor_, RevType rev_type_):
+ 	StartTime(StartTime_), EndTime(EndTime_), 
+ 		Reservor(Reservor_), rev_type(rev_type_), RevID(RevID_)
+ {
+ 	send_timer = NULL;
+ 	next = NULL;
+ }
+ 
+ 
+ RevElem::~RevElem()
+ {
+ 	if( send_timer != NULL ) {
+ 		if( send_timer->status() == TIMER_PENDING ) {
+ 			send_timer->cancel();
+ 		}
+ 		delete send_timer;
+ 		send_timer = NULL;
+ 	}
+ }
+ 
+ 
+ PktSendTimer::~PktSendTimer()
+ {
+ 	if( pkt_ != NULL )
+ 		Packet::free(pkt_);
+ }
+ 
+ void PktSendTimer::expire(Event *e)
+ {
+ 	mac_->PreSendPkt(pkt_);
+ 	pkt_ = NULL;
+ 
+ }
+ 
+ 
+ RevQueues::RevQueues(OTMAN* mac): mac_(mac)
+ {
+ 	Head_ = NULL;
+ }
+ 
+ 
+ RevQueues::~RevQueues()
+ {
+ 	RevElem* tmp = NULL;
+ 
+ 	while( Head_ != NULL ) {
+ 		tmp = Head_;
+ 		Head_ = Head_->next;
+ 		delete tmp;
+ 	}
+ }
+ 
+ void RevQueues::clearExpired(Time ExpireTime)
+ {
+ 	RevElem* tmp = NULL;
+ 
+ 	while( Head_ != NULL && Head_->EndTime < ExpireTime + BACKOFF_DELAY_ERROR ) {
+ 		tmp = Head_;
+ 		Head_ = Head_->next;
+ 		delete tmp;
+ 	}
+ }
+ 
+ 
+ bool RevQueues::push(int RevID, Time StartTime, Time EndTime, 
+ 					 nsaddr_t Reservor, RevType rev_type, Packet *pkt)
+ {
+ 	clearExpired(NOW);
+ 
+ 	//insert 
+ 
+ 	RevElem* tmp = new RevElem(RevID, StartTime, EndTime, Reservor, rev_type);
+ 	
+ 	if( pkt != NULL ) {
+ 		tmp->send_timer = new PktSendTimer(mac_, pkt);
+ 	}
+ 
+ 	if( Head_ == NULL ) {
+ 		Head_ = tmp;
+ 		return true;
+ 	}
+ 
+ 	RevElem* pre_pos = Head_;
+ 	RevElem* pos = Head_->next;
+ 	
+ 	while( pos != NULL ) {
+ 		if( pos->EndTime < EndTime ) {
+ 			pre_pos = pos;
+ 			pos = pos->next;
+ 		}
+ 		else {
+ 			break;
+ 		}
+ 	}
+ 
+ 	pre_pos->next = tmp;
+ 	tmp->next = pos;
+ 	return true;
+ }
+ 
+ 
+ bool RevQueues::checkAvailability(Time StartTime, Time EndTime, RevType rev_type)
+ {
+ 	//recheck the code here.
+ 	clearExpired(NOW);
+ 
+ 	RevElem* pos = Head_;
+ 
+ 	while( pos != NULL ) {
+ 		if( ((pos->StartTime > StartTime) && (pos->StartTime < EndTime) )
+ 			|| ( (pos->EndTime > StartTime)&&(pos->EndTime<EndTime) ) ) {
+ 			return false;
+ 		}
+ 
+ 		pos = pos->next;
+ 	}
+ 	return true;
+ }
+ 
+ 
+ 
+ void RevQueues::deleteRev(int RevID)
+ {
+ 	RevElem* pos = Head_;
+ 	
+ 	if( Head_->RevID == RevID ) {
+ 		Head_ = Head_->next;
+ 		delete pos;
+ 		return;
+ 	}
+ 
+ 	pos = Head_->next;
+ 	RevElem* pre_pos = Head_;
+ 
+ 	while( pos != NULL ) {
+ 		if( pos->RevID == RevID ) {
+ 			pre_pos->next = pos->next;
+ 			
+ 			delete pos;
+ 			return;
+ 		}
+ 		pre_pos = pos;
+ 		pos = pos->next;
+ 	}
+ 	
+ }
+ 
+ 
+ void RevQueues::updateStatus(int RevID, RevType new_type)
+ {
+ 	RevElem* pos = Head_;
+ 	Time send_time;
+ 	
+ 	while( pos != NULL ) {
+ 		if( pos->RevID == RevID ) {
+ 			pos->rev_type = new_type;
+ 			send_time = pos->StartTime - NOW + mac_->GuardTime/2;
+ 			if( send_time < 0.0 ) {
+ 				printf("handshake takes too long time, cancel sending\n");
+ 				deleteRev(RevID);
+ 				return;
+ 			}
+ 
+ 			if( pos->send_timer != NULL && send_time > 0.0) {
+ 
+ 				pos->send_timer->resched(send_time);
+ 
+ 			}
+ 			return;
+ 		}
+ 		pos = pos->next;
+ 	}
+ }
+ 
+ void RevQueues::printRevQueue()
+ {
+ 	RevElem* pos = Head_;
+ 	char file_name[30];
+ 	strcpy(file_name, "schedule_");
+ 	file_name[strlen(file_name)+1] = '\0';
+ 	file_name[strlen(file_name)] = char(mac_->index_+'0');
+ 	FILE* stream = fopen(file_name, "a");
+ 
+ 	while( pos != NULL ) {
+ 		fprintf(stream, "node(%d): %d[%f:%f] type:%d\t", pos->Reservor, 
+ 			pos->RevID, pos->StartTime, pos->EndTime, pos->rev_type);
+ 		pos = pos->next;
+ 	}
+ 	fprintf(stream, "\n");
+ 	fclose(stream);
+ 
+ 
+ }
+ 
+ Time RevQueues::getValidStartTime(Time Interval, Time SinceTime)
+ {
+ 	Time now = SinceTime;
+ 	RevElem* pos = Head_;
+ 	RevElem* pre_pos = NULL;
+ 	Time Lowerbound, Upperbound;
+ 	
+ 
+ 	while( pos!=NULL && pos->StartTime < now ) {
+ 		pre_pos = pos;
+ 		pos = pos->next;
+ 	}
+ 
+ 	Lowerbound = now;
+ 
+ 	if( pos == NULL ) {
+ 		return SinceTime + 0.0001 - NOW;
+ 	}
+ 	else {
+ 		Upperbound = pos->StartTime;
+ 	}
+ 
+ 	while( Upperbound - Lowerbound < Interval ) {
+ 		pre_pos = pos;
+ 		pos = pos->next;
+ 		Lowerbound = pre_pos->EndTime;
+ 		if( pos == NULL )
+ 			break;
+ 		Upperbound = pos->StartTime;
+ 	}
+ 
+ 	return Lowerbound + 0.0001 - NOW;
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /**********************OTMAN*************************************/
+ int OTMAN::RevID = 0;
+ OTMAN::OTMAN(): UnderwaterMac(), callback_handler(this), 
+ 			status_handler(this), senddelay_handler(this),
+ 			backoff_handler(this), nd_process_initor(this),
+ 			ndreply_initor(this),
+ 			DataSendTimer(this), RevAckAccumTimer(this),
+ 			DataAckAccumTimer(this), InitiatorTimer(this),
+ 			PrintTimer(this), NDInterval_(6),
+ 			DataAccuPeriod(10), 
+ 			RevAckAccumTime_(1), DataAckAccumTime_(1),
+ 			 RevQ_(this), next_hop(0),neighbor_id(0),
+ 			MajorIntervalLB(2),/* MajorIntervalUB(3),IntervalStep(0.1),*/
+ 			DataStartTime(15), GuardTime(0.01),
+ 			NDWin(2.0), NDReplyWin(2.0), AckTimeOut(10),
+ 			CtrlPktQ_(this),PktSize(200), isParallel(1)
+ 			
+ {
+ 	bind("NDInterval", &NDInterval_);
+ 	bind("DataAccuPeriod", &DataAccuPeriod);  //the reservation period
+ 	bind("RevAckAccumTime", &RevAckAccumTime_);
+ 	bind("DataAckAccumTime", &DataAckAccumTime_);
+ 
+ 	//bind("MajorBackupInterval", &MajorBackupInterval);
+ 	bind("MajorIntervalLB", &MajorIntervalLB);
+ 	/*bind("MajorIntervalUB", &MajorIntervalUB);*/
+ 	bind("GuardTime", &GuardTime);
+ 	bind("isParallel", &isParallel);
+ 
+ 	nd_process_initor.resched(0.002 );  //start the nd process
+ 	InitiatorTimer.resched(0.001);
+ 	
+ 	
+ }
+ 
+ void OTMAN::start()
+ {
+ 	((UnderwaterSensorNode*) node_)->SetTransmissionStatus(IDL);
+ 	
+ 	DataStartTime = 3*NDInterval_ + 7;
+ 	Time MaxRTT = 2*1000/1500.0;
+ 	AckTimeOut = RevAckAccumTime_ + DataAckAccumTime_ + 2*MaxRTT + 5; //5 is time error
+ 	DataSendTimer.resched(DataStartTime+Random::uniform());
+ 	//PrintTimer.resched(100.0);
+ 	//Random::seed_heuristically();
+ }
+ 
+ int OTMAN::command(int argc, const char *const *argv)
+ {
+ 	if(argc == 3) {
+         if (strcmp(argv[1], "node_on") == 0) {
+ 			Node* n1=(Node*) TclObject::lookup(argv[2]);
+ 			if (!n1) return TCL_ERROR;
+ 			node_ =n1; 
+ 			return TCL_OK;
+ 		}
+ 	}
+ 
+ 	return UnderwaterMac::command(argc, argv);
+ }
+ 
+ 
+ 
+ void OTMAN::TxProcess(Packet* pkt)
+ {
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 
+ 	cmh->size() = PktSize;
+ 	cmh->txtime()=
+ 			(cmh->size()*encoding_efficiency_)*8/bit_rate_;
+ 	//cmh->next_hop() = ((UnderwaterSensorNode*)node_)->next_hop; //for purpose of test
+ 
+ 	if( prop_delays.size() == 0 ) {
+ 		printf("node %d doesn't have neighbor.\n", index_);
+ 		Packet::free(pkt);
+ 		return;
+ 	}
+ 
+ 	cmh->error()=0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	mh->macDA() = cmh->next_hop();
+ 	mh->macSA() = index_;
+ 
+ 	//insert packet into packet warehouse
+ 	PktWH_.insert2PktQs(pkt);
+ 	/*if( DataSendTimer.status() == TIMER_IDLE ) {
+ 		DataSendTimer.resched(DataAccuPeriod+Random::uniform());
+ 	}*/
+ 	Scheduler::instance().schedule(&callback_handler, 
+ 						&callback_event, OTMAN_CALLBACK_DELAY);
+ }
+ 
+ 
+ void OTMAN::RecvProcess(Packet* pkt)
+ {
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	int dst = mh->macDA();
+ 	//int src = mh->macSA();
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 	
+     if( cmh->error() ) 
+     {
+      	//printf("broadcast:node %d  gets a corrupted packet at  %f\n",index_,NOW);
+      	if(drop_)
+ 			drop_->recv(pkt,"Error/Collision");
+      	else
+ 			Packet::free(pkt);
+ 
+      	return;
+     }
+ 
+ 	if( dst == index_ || (u_int32_t)dst == MAC_BROADCAST ) {
+ 	
+ 		if( cmh->ptype() == PT_OTMAN ) {
+ 			hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 			switch( hdr_o->packet_type ) {
+ 				case OTMAN_ND:
+ 					processND(pkt);
+ 					break;
+ 				case OTMAN_ND_REPLY:
+ 					processNDReply(pkt);
+ 					break;
+ 				case MULTI_REV:
+ 					processMultiRev(pkt);
+ 					break;
+ 				case MULTI_REV_ACK:
+ 					processMultiRevAck(pkt);
+ 					break;
+ 				case MULTI_DATA_ACK:
+ 					processDataAck(pkt);
+ 					break;
+ 				default:
+ 					;
+ 			}
+ 		}
+ 		else {
+ 			//DATA Packet
+ 			
+ 			printf("RECV Data Pkt\n");
+ 			RecordDataPkt(pkt);
+ 			sendUp(pkt);   //record the data received.!!!!
+ 			//Packet::free(pkt);
+ 			printResult();
+ 			return;
+ 		}
+ 	}
+ 	
+ 	Packet::free(pkt);
+ }
+ 
+ void OTMAN::PreSendPkt(Packet* pkt, Time delay)
+ {
+ 	if( delay < 0 )
+ 		delay = delay;
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	Scheduler& s=Scheduler::instance();
+ 	s.schedule(&senddelay_handler, (Event*)pkt, delay);
+ }
+ 
+ 
+ void OTMAN::SendPkt(Packet *pkt)
+ {
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+ 	cmh->txtime()=(cmh->size()*encoding_efficiency_)/bit_rate_;
+ 
+ 
+ 	double txtime=cmh->txtime();
+ 	Scheduler& s=Scheduler::instance();
+ 
+ 	switch( n->TransmissionStatus() ) {
+ 		case SLEEP:
+ 			Poweron();
+ 		case IDL:
+ 
+ 			n->SetTransmissionStatus(SEND); 
+ 			cmh->timestamp() = NOW;
+ 			cmh->direction() = hdr_cmn::DOWN;
+ 			sendDown(pkt);
+ 			backoff_handler.clear();
+ 			s.schedule(&status_handler,&status_event,txtime);
+ 			break;
+ 
+ 		case RECV:
+ 			/*printf("node %d backoff at %f\n", index_, NOW);
+ 			if( backoff_handler.pkt_ == NULL ) {
+ 				backoff_handler.pkt_ = pkt;
+ 				s.schedule(&backoff_handler, &backoff_event,
+ 					0.01+Random::uniform()*OTMAN_BACKOFF_TIME);
+ 			}
+ 			else {*/
+ 				Packet::free(pkt);
+ 			/*}*/
+ 			break;
+ 			
+ 		default:
+ 			//status is SEND
+ 			printf("node%d send data too fast\n",index_);
+ 			Packet::free(pkt);
+ 
+ 	}
+ 
+ 	return;
+ 
+ }
+ 
+ 
+ 
+ Packet* OTMAN::makeND()
+ {
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	hdr_o->packet_type = OTMAN_ND;
+ 	//hdr_o->hdr.ndh.send_time_ = NOW;
+ 
+ 	cmh->size() = hdr_o->size();
+     cmh->next_hop() = MAC_BROADCAST; 
+     cmh->direction()=hdr_cmn::DOWN; 
+     cmh->addr_type()=NS_AF_ILINK;
+     cmh->ptype() = PT_OTMAN;
+ 
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	mh->macDA() = MAC_BROADCAST;
+ 	mh->macSA() = index_;
+ 
+ 	//fill the neighbors that this node already knows the delay
+ 	uint data_size = sizeof(uint)+ sizeof(nsaddr_t)*prop_delays.size();
+ 	pkt->allocdata( data_size);
+ 	//cmh->size() += data_size;
+ 
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+     *(uint*)walk = prop_delays.size();
+     walk += sizeof(uint);
+ 
+ 	for( map<nsaddr_t, Time>::iterator pos=prop_delays.begin();
+          pos != prop_delays.end(); pos++)
+     {
+ 		*((nsaddr_t*)walk) = pos->first;
+         walk += sizeof(nsaddr_t);
+     }
+ 
+ 	return pkt;
+ }
+ 
+ 
+ void OTMAN::processND(Packet* pkt)
+ {
+ 	//hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	//printf("node %d recve ND from node %d\n", index_, mh->macSA());
+ 
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+ 	uint node_num_ = *((uint*)walk);
+     walk += sizeof(uint);
+ 
+ 	for( uint i=0; i<node_num_; i++) {
+ 		
+ 		if( index_ == *((nsaddr_t*)walk) ) {
+ 			return;
+ 		}
+ 		walk += sizeof(nsaddr_t);
+ 	}
+ 
+ 	PendingND[mh->macSA()].nd_sendtime = cmh->timestamp();
+ 	PendingND[mh->macSA()].nd_recvtime = NOW - cmh->txtime();
+ 
+ 
+ 	return;
+ }
+ 
+ 
+ Packet* OTMAN::makeNDReply()
+ {
+ 	if( PendingND.size() == 0 ) {
+ 		printf("no pending nd at node %d\n", index_);
+ 		return NULL;
+ 	}
+ 
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	hdr_o->packet_type = OTMAN_ND_REPLY;
+ 	//hdr_o->hdr.nd_reply_h.nd_send_time_ = nd_depart_neighbor_time[NDSender];
+ 	//hdr_o->hdr.nd_reply_h.delay_at_receiver = NOW - nd_receive_time[NDSender];
+ 	
+ 	cmh->size() = hdr_o->size();
+     cmh->next_hop() = MAC_BROADCAST; 
+     cmh->direction()=hdr_cmn::DOWN; 
+     cmh->addr_type()=NS_AF_ILINK;
+     cmh->ptype() = PT_OTMAN;
+ 
+ 	uint data_size = sizeof(uint) + (2*sizeof(Time)+sizeof(nsaddr_t))*PendingND.size();
+ 	pkt->allocdata( data_size);
+ 	//cmh->size() += data_size;
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+ 	*(uint*)walk = PendingND.size();
+ 	walk += sizeof(uint);
+ 	for( map<nsaddr_t, NDRecord>::iterator pos = PendingND.begin();
+ 		pos != PendingND.end(); pos++) {
+ 			*(nsaddr_t*)walk = pos->first;
+ 			walk += sizeof(nsaddr_t);
+ 			*(Time*)walk = pos->second.nd_sendtime;
+ 			walk += sizeof(Time);
+ 			*(Time*)walk = pos->second.nd_recvtime;
+ 			walk += sizeof(Time);
+ 	}
+ 
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	mh->macDA() = cmh->next_hop();
+ 	mh->macSA() = index_;
+ 
+ 	processNDReply(pkt);
+ 
+ 	return pkt;
+ }
+ 
+ 
+ void OTMAN::processNDReply(Packet* pkt)
+ {
+ 	//hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	printf("node %d recve ND reply from node %d at %f\n", index_, mh->macSA(), NOW);
+ 
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+ 	uint rec_num = *(uint*)walk;
+ 	walk += sizeof(uint);
+ 
+ 	NDRecord tmp;
+ 	for( uint i=0; i<rec_num; i++) {
+ 		if( (*(nsaddr_t*)walk) == index_ ) {
+ 			walk += sizeof(nsaddr_t);
+ 			tmp.nd_sendtime = *(Time*)walk;
+ 			walk += sizeof(Time);
+ 			tmp.nd_recvtime = *(Time*)walk;
+ 			walk += sizeof(Time);
+ 			prop_delays[mh->macSA()] = ((NOW-tmp.nd_sendtime) -
+ 				(cmh->timestamp()-tmp.nd_recvtime-cmh->txtime()))/2.0;
+ 			break;
+ 		}
+ 		walk += sizeof(nsaddr_t);
+ 		walk += sizeof(Time)*2;
+ 	}
+ }
+ 
+ 
+ 
+ void OTMAN::startHandShake()
+ {
+ 	/*if( !PktWH_.IsEmpty() ) {*/
+ 		Packet* pkt = makeMultiRev();
+ 		if( pkt == NULL )
+ 			return;
+ 
+ 		CtrlPktQ_.insert(pkt, RevQ_.getValidStartTime(HDR_CMN(pkt)->txtime()) );
+ 		//PreSendPkt(pkt, Random::uniform()*OTMAN_REV_DELAY);	
+ 	/*}*/
+ }
+ 
+ //int OTMAN::round2Slot(Time time)
+ //{
+ //	return int( (time-NOW)/TimeSlotLen_ );
+ //}
+ //
+ //Time OTMAN::Slot2Time(int SlotNum, Time BaseTime)
+ //{
+ //	return BaseTime+SlotNum*TimeSlotLen_;
+ //}
+ //
+ //Time OTMAN::round2RecverSlotBegin(Time time, nsaddr_t recver)
+ //{
+ //	//return int( (time-NOW)
+ //	int SlotNum = int((time+prop_delays[recver])/TimeSlotLen_);
+ //	if( time+ prop_delays[recver] - SlotNum*TimeSlotLen_  > 0.00001 )
+ //		SlotNum++;
+ //	return SlotNum*TimeSlotLen_ - prop_delays[recver];
+ //}
+ 
+ Packet* OTMAN::makeMultiRev()
+ {
+ 	//RevQ_.printRevQueue();
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	hdr_o->packet_type = MULTI_REV;	
+ 	
+     cmh->next_hop() = MAC_BROADCAST; 
+     cmh->direction()=hdr_cmn::DOWN; 
+     cmh->addr_type()=NS_AF_ILINK;
+     cmh->ptype() = PT_OTMAN;
+ 
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	mh->macDA() = MAC_BROADCAST;
+ 	mh->macSA() = index_;
+ 
+ 	uint rev_num = 0;
+ 	map<nsaddr_t, PktList>::iterator pos;
+ 	for( pos = PktWH_.Queues.begin();
+ 			pos != PktWH_.Queues.end(); pos++ )
+ 	{
+ 		if( pos->second.head != NULL ) {
+ 			rev_num ++;		
+ 		}
+ 	}
+ 
+ 	if( rev_num == 0 ) {
+ 		Packet::free(pkt);
+ 		return NULL;
+ 	}
+ 	/*
+ 	 * The format of entry in multi-rev is
+ 	 *		nsaddr_t requestor; 
+ 	 *		Time	PktLen;
+ 	 *		int		MajorRevID;
+ 	 *		Time	MajorStartTime;
+ 	 *		int		BackupRevID;
+ 	 *		Time	BackupStartTime;
+ 	 */
+ 	//fill the neighbors to which this node already knows the delay
+ 	uint ithneighbor = neighbor_id%rev_num;
+ 	if( !isParallel ) {
+ 		rev_num = 1;
+ 	}
+ 
+ 	pkt->allocdata( sizeof(uint)+ sizeof(Time)+
+ 					(sizeof(nsaddr_t)+sizeof(Time)*3+sizeof(int)*2)*rev_num);
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+     *(uint*)walk = rev_num;
+     walk += sizeof(uint);
+ 	*(Time*)walk = NOW;   //record the time when filling the packet
+ 	walk += sizeof(Time);
+ 
+ 	
+ 	PktElem* tmp;
+ 	uint i=0;
+ 	for( pos = PktWH_.Queues.begin();
+ 			pos != PktWH_.Queues.end(); pos++ )
+ 	{
+ 		if( (!isParallel) && (i<ithneighbor) ) {
+ 			i++;
+ 			continue;
+ 		}
+ 
+ 		if( pos->second.head != NULL ) {
+ 
+ 			*((nsaddr_t*)walk) = pos->first;
+ 			walk += sizeof(nsaddr_t);
+ 			tmp = pos->second.head;
+ 
+ 			Packet* TmpPkt = pos->second.head->pkt_->copy();
+ 
+ 			Time MajorInterval, BackupInterval;  //both refer to the start time of the interval
+ 			Time PktLen_ = 
+ 				HDR_CMN(TmpPkt)->txtime() +GuardTime; //guardtime is used to avoid collision
+ 
+ 			//Time LowerInterval = MajorIntervalLB;
+ 			//Time UpperInterval = MajorIntervalUB;
+ 			//get major interval 
+ 			//Time SinceTime= round2RecverSlotBegin(NOW, pos->first);
+ 			MajorInterval = RevQ_.getValidStartTime(PktLen_, NOW+MajorIntervalLB);
+ 			/*do{
+ 				counter++;
+ 				if( counter == 100 ) {
+ 					UpperInterval += IntervalStep;
+ 					counter = 0;
+ 				}
+ 				MajorInterval =	Random::uniform(LowerInterval,
+ 												UpperInterval);
+ 			}while(!RevQ_.checkAvailability(NOW+MajorInterval,
+ 				NOW+MajorInterval+PktLen_, PRE_REV) );*/
+ 
+ 
+ 			//get backup send interval
+ 			BackupInterval = RevQ_.getValidStartTime(PktLen_, NOW+MajorInterval + PktLen_);
+ 			/*Time tmpInterval = MajorBackupInterval;
+ 			do{
+ 				counter++;
+ 				if( counter == 100 ) {
+ 					tmpInterval += IntervalStep;
+ 					counter = 0;
+ 				}
+ 				BackupInterval = MajorInterval+PktLen_ + 
+ 								 Random::uniform(tmpInterval);
+ 			}while( !RevQ_.checkAvailability(NOW+BackupInterval, 
+ 								NOW+BackupInterval+PktLen_, PRE_REV) );*/
+ 
+ 			RevID++;
+ 			RevQ_.push(RevID, NOW+MajorInterval, NOW+MajorInterval+PktLen_,
+ 						index_, PRE_REV, TmpPkt->copy());
+ 			
+ 			*(Time*)walk = PktLen_;   //already includes GuardTime
+ 			walk += sizeof(Time);
+ 			*(int*)walk = RevID;
+ 			walk += sizeof(int);
+ 			*(Time*)walk = MajorInterval;
+ 			walk += sizeof(Time);
+ 
+ 			RevID++;
+ 			RevQ_.push(RevID, NOW+BackupInterval, 
+ 				NOW+BackupInterval+PktLen_, index_, PRE_REV, TmpPkt);
+ 			*(int*)walk = RevID;
+ 			walk += sizeof(int);
+ 			*(Time*)walk = BackupInterval;   //this is the backup time slot. One of the 10 slots after major slot
+ 			walk += sizeof(Time); 
+ 
+ 
+ 			//remove the packet from PacketWH_ and insert it into 
+ 			//AckWaitingList
+ 			pos->second.head = tmp->next_;
+ 			insertAckWaitingList(tmp->pkt_->copy(), AckTimeOut); 
+ 			PktWH_.deletePkt(pos->first, HDR_CMN(tmp->pkt_)->uid());
+ 
+ 			if( !isParallel ) {
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	//node id use 8 bits, first time slot use 10bits, backup time slot use 4 bits 
+ 	
+ 	cmh->size() = (4+(8+8+8+8))*rev_num/8;
+ 
+ 	neighbor_id = (neighbor_id+1)%prop_delays.size();
+ 	//RevQ_.printRevQueue();
+ 	return pkt;
+ }
+ 
+ 
+ void OTMAN::processMultiRev(Packet* pkt)
+ {
+ 	//RevQ_.printRevQueue();
+ 	//TRANSMIT THE TIME IN AVOIDING ITEM TO MY OWN TIME VIEW
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+     uint rev_num = *(uint*)walk;
+     walk += sizeof(uint);
+ 
+ 	Time delta_time = cmh->timestamp() - (*(Time*)walk);
+ 	//reservation time = majorinterval -delta_time +NOW
+ 	walk += sizeof(Time);
+ 
+ 	/*store the rev requests in Pending Revs and 
+ 	 *process it when RevAckAccumTimer expires
+ 	 */
+ 	
+ 	Time PktLen_;
+ 	for(uint i=0; i<rev_num; i++) {
+ 		if( *((nsaddr_t*)walk) == index_ ) {
+ 			walk += sizeof(nsaddr_t);
+ 
+ 			if( RevAckAccumTimer.status() == TIMER_IDLE ) {
+ 				RevAckAccumTimer.resched(RevAckAccumTime_);
+ 			}
+ 
+ 			RevReq* tmp = new RevReq();
+ 			tmp->requestor = mh->macSA();
+ 			//tmp->Sincetime = map2OwnTime(cmh->ts_, mh->macSA());
+ 				
+ 			PktLen_ = *((Time*)walk);
+ 			walk += sizeof(Time);
+ 			tmp->AcceptedRevID = *((int*)walk);
+ 			walk += sizeof(int);
+ 
+ 			//covert the time based on this node's timeline
+ 			tmp->StartTime = *((Time*)walk)-delta_time + NOW;   
+ 			walk += sizeof(Time);
+ 			tmp->EndTime = tmp->StartTime + PktLen_;
+ 
+ 			//check major slot
+ 			if( RevQ_.checkAvailability(tmp->StartTime,tmp->EndTime, RECVING) ) {
+ 				tmp->RejectedRevID = *((int*)walk);
+ 				walk += sizeof(int)+sizeof(Time);
+ 			
+ 				RevQ_.push(RevID, tmp->StartTime, tmp->EndTime, 
+ 					tmp->requestor, RECVING);
+ 			}
+ 			else{
+ 				tmp->RejectedRevID = tmp->AcceptedRevID;
+ 				tmp->AcceptedRevID = *((int*)walk);
+ 				walk += sizeof(int);
+ 
+ 				//covert the time based on this node's timeline
+ 				tmp->StartTime = *((Time*)walk)-delta_time + NOW;
+ 				walk += sizeof(Time);			
+ 				tmp->EndTime = tmp->StartTime + PktLen_;
+ 
+ 				if( RevQ_.checkAvailability(tmp->StartTime, tmp->EndTime, RECVING) ) {
+ 
+ 					RevQ_.push(RevID, tmp->StartTime, tmp->EndTime, 
+ 						tmp->requestor, RECVING);
+ 				}
+ 				else {
+ 					//give a wrong rev time interval, so the requestor will know both are wrong
+ 					tmp->StartTime = -1.0;
+ 					tmp->EndTime = -1.0;
+ 				}
+ 				
+ 			}
+ 			PendingRevs.push_back(tmp);
+ 
+ 		}
+ 		else{
+ 			//this entry has nothing to do with this node. skip it
+ 			walk += sizeof(nsaddr_t);
+ 			walk += 3*sizeof(Time);
+ 			walk += 2*sizeof(int);
+ 		}
+ 	}
+ 	//RevQ_.printRevQueue();
+ }
+ 
+ 
+ /*
+  * MultiRevAck format
+  *	nsaddr_t	requestor;
+  *	Time		StartTime;  //related to current time
+  *	Time		EndTime;
+  *	int			AcceptedRevID;
+  *	int			RejectedRevID;
+  */
+ Packet* OTMAN::makeMultiRevAck()
+ {
+ 	//overhear neighbors rev
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	hdr_o->packet_type = MULTI_REV_ACK;
+ 	
+ 	
+     cmh->next_hop() = MAC_BROADCAST; 
+     cmh->direction()=hdr_cmn::DOWN; 
+     cmh->addr_type()=NS_AF_ILINK;
+     cmh->ptype() = PT_OTMAN;
+ 
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	mh->macDA() = MAC_BROADCAST;
+ 	mh->macSA() = index_;
+ 
+ 	pkt->allocdata( sizeof(uint)+ sizeof(Time)+
+ 				(sizeof(nsaddr_t)+2*sizeof(int)+2*sizeof(Time))*PendingRevs.size() );
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+     *(uint*)walk = PendingRevs.size();
+     walk += sizeof(uint);
+ 	*(Time*)walk = NOW;
+ 	walk += sizeof(Time);
+ 
+ 	for( vector<RevReq*>::iterator pos=PendingRevs.begin();
+          pos != PendingRevs.end(); pos++)
+     {
+ 		*(nsaddr_t*)walk = (*pos)->requestor;  //ack to whom
+         walk += sizeof(nsaddr_t);
+ 		*(Time*)walk = (*pos)->StartTime - NOW;
+ 		walk += sizeof(Time);
+ 		*(Time*)walk = (*pos)->EndTime - NOW;
+ 		walk += sizeof(Time);
+ 		*(int*)walk = (*pos)->AcceptedRevID;
+ 		walk += sizeof(int);		
+ 		*(int*)walk = (*pos)->RejectedRevID;
+ 		walk += sizeof(int);
+     }
+ 	
+ 	//schedule the rev req.
+ 	//node id use 10 bits, first time slot use 10bits, backup time slot use 4 bits 
+ 	//hdr_o->size() = (PendingRevs.size()*(10+10+6+4))/8;
+ 	cmh->size() = (PendingRevs.size()*(8+10+6+4))/8;
+ 
+ 	return pkt;
+ }
+ 
+ void OTMAN::processMultiRevAck(Packet *pkt)
+ {
+ 	//RevQ_.printRevQueue();
+ 	//overhear neighbors revack
+ 	//change the pre_rev to SENDING, and delete the other slot rev
+ 	//start the the timer in the rev_elem
+ 	//hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+     uint rev_num = *(uint*)walk;
+     walk += sizeof(uint);
+ 	Time delta_time = cmh->timestamp() - (*(Time*)walk);
+ 	walk += sizeof(Time);
+ 
+ 
+ 	RevReq* tmp = new RevReq();
+ 	for(uint i=0; i<rev_num; i++) {
+ 
+ 		tmp->requestor = *(nsaddr_t*)walk;
+ 		walk += sizeof(nsaddr_t);
+ 		tmp->StartTime = *(Time*)walk;
+ 		walk += sizeof(Time);
+ 		tmp->EndTime = *(Time*)walk;
+ 		walk += sizeof(Time);
+ 		tmp->AcceptedRevID = *(int*)walk;
+ 		walk += sizeof(int);		
+ 		tmp->RejectedRevID = *(int*)walk;
+ 		walk += sizeof(int);
+ 
+ 		if( tmp->StartTime > 0 ) {
+ 			if( tmp->requestor == index_ ) {
+ 				//start timer in updateStatus
+ 				RevQ_.updateStatus(tmp->AcceptedRevID, SENDING);  
+ 				RevQ_.deleteRev(tmp->RejectedRevID);
+ 			}
+ 			else {
+ 				RevQ_.push(tmp->AcceptedRevID, NOW+tmp->StartTime -delta_time - prop_delays[mh->macSA()],
+ 							NOW+tmp->EndTime -delta_time - prop_delays[mh->macSA()],
+ 							mh->macSA(), AVOIDING);
+ 			}
+ 		}
+ 		else if( tmp->requestor == index_ ) {
+ 			RevQ_.deleteRev(tmp->AcceptedRevID);
+ 			RevQ_.deleteRev(tmp->RejectedRevID);
+ 		}
+ 		
+ 	}
+ 	delete tmp;
+ 	//RevQ_.printRevQueue();
+ 
+ }
+ 
+ void OTMAN::RecordDataPkt(Packet* pkt)
+ {
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 
+ 	DataAck* tmp = new DataAck;
+ 	tmp->Sender = mh->macSA();
+ 	tmp->SeqNum = cmh->uid();
+ 	PendingDataAcks.push_back(tmp);
+ 
+ 	SucDataNum[mh->macSA()]++;
+ 	// startAckTimer
+ 	if( DataAckAccumTimer.status() == TIMER_IDLE ) {
+ 		DataAckAccumTimer.resched(DataAckAccumTime_);
+ 	}
+ }
+ 
+ 
+ Packet* OTMAN::makeDataAck()
+ {
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_otman* hdr_o = hdr_otman::access(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+ 	hdr_o->packet_type = MULTI_DATA_ACK;
+ 	
+ 	
+     cmh->next_hop() = MAC_BROADCAST; 
+     cmh->direction()=hdr_cmn::DOWN; 
+     cmh->addr_type()=NS_AF_ILINK;
+     cmh->ptype() = PT_OTMAN;
+ 
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	mh->macDA() = MAC_BROADCAST;
+ 	mh->macSA() = index_;
+ 
+ 	uint DataAckNum = PendingDataAcks.size();
+ 
+ 	//hdr_o->size() = DataAckNum*((10+10)/8);
+ 	cmh->size() = DataAckNum*((10+10)/8);
+ 
+ 	pkt->allocdata(sizeof(uint)+DataAckNum*(sizeof(nsaddr_t)+sizeof(int)));
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+ 	*(uint*)walk = DataAckNum;
+     walk += sizeof(uint);
+ 
+ 
+ 	for(vector<DataAck*>::iterator pos = PendingDataAcks.begin(); 
+ 		pos != PendingDataAcks.end(); pos++ )
+ 	{
+ 		*(nsaddr_t*)walk = (*pos)->Sender;
+ 		walk += sizeof(nsaddr_t);
+ 		*(int*)walk = (*pos)->SeqNum;
+ 		walk += sizeof(int);
+ 	}
+ 
+ 	return pkt;
+ }
+ 
+ 
+ void OTMAN::processDataAck(Packet* pkt)
+ {
+ 	unsigned char* walk = (unsigned char*)pkt->accessdata();
+     uint AckNum = *(uint*)walk;
+     walk += sizeof(uint);
+ 
+ 	/*store the rev requests in Pending Revs and 
+ 	 *process it when RevAckAccumTimer expires
+ 	 */
+ 	int pkt_id;
+ 	for(uint i=0; i<AckNum; i++) {
+ 		if( *((nsaddr_t*)walk) == index_ ) {
+ 			walk += sizeof(nsaddr_t);
+ 			/*nsaddr_t recver = hdr_mac::access(pkt)->macSA();
+ 			if( PktWH_.deletePkt(recver, *(int*)walk) ) {
+ 				if( SucDataNum.count(recver) == 0 )
+ 					SucDataNum[recver] = 1;
+ 				else
+ 					SucDataNum[recver]++;
+ 			}
+ 
+ 			walk += sizeof(int);	*/
+ 			pkt_id = (*(int*)walk);
+ 			if( AckWaitingList.count(pkt_id) != 0 ) {
+ 				if( AckWaitingList[pkt_id].status() == TIMER_PENDING ) {
+ 					AckWaitingList[pkt_id].cancel();
+ 				}
+ 				if( AckWaitingList[pkt_id].pkt_!= NULL ) {
+ 					Packet::free(AckWaitingList[pkt_id].pkt_);
+ 					AckWaitingList[pkt_id].pkt_ = NULL;		
+ 				}
+ 			}
+ 			walk += sizeof(int);
+ 		}
+ 		else{
+ 			walk += sizeof(nsaddr_t);
+ 			walk += sizeof(int);
+ 		}
+ 	}
+ }
+ 
+ 
+ void OTMAN::CallbackProcess(Event* e)
+ {
+ 	if( callback_ != NULL )
+ 		callback_->handle(e);
+ }
+ 
+ 
+ void OTMAN::StatusProcess(Event *e)
+ {
+ 	//perhaps not right
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	if( SEND == n->TransmissionStatus() ){
+ 		n->SetTransmissionStatus(IDL);
+ 	}
+   	return;
+ }
+ 
+ 
+ 
+ Time OTMAN::map2OwnTime(Time SenderTime, nsaddr_t Sender)
+ {
+ 	return SenderTime+prop_delays[Sender];
+ }
+ 
+ 
+ 
+ 
+ 
+ void OTMAN::printResult()
+ {
+ 	int totalPkt = 0;
+ 	map<nsaddr_t, int>::iterator pos = SucDataNum.begin();
+ 	for(; pos != SucDataNum.end(); pos++) {
+ 		totalPkt += pos->second;
+ 	}
+ 	printf("node %d receive %d packets\n", index_, totalPkt);
+ }
+ 
+ 
+ 
+ void OTMAN::clearAckWaitingList()
+ {
+ 	
+ 	set<int> DelList;
+ 	for(map<int, AckWaitTimer>::iterator pos = AckWaitingList.begin();
+ 			pos!=AckWaitingList.end(); pos++)				 {
+ 		if( pos->second.pkt_ == NULL )
+ 			DelList.insert(pos->first);
+ 	}
+ 
+ 	for(set<int>::iterator pos = DelList.begin();
+ 		pos!=DelList.end(); pos++)    {
+ 			AckWaitingList.erase(*pos);
+ 	}
+ }
+ 
+ void OTMAN::insertAckWaitingList(Packet* p, Time delay)
+ {
+ 	clearAckWaitingList();
+ 	int uid_ = HDR_CMN(p)->uid();
+ 	AckWaitingList[uid_].mac_ = this;
+ 	AckWaitingList[uid_].pkt_ = p;
+ 	AckWaitingList[uid_].resched(delay);
+ }
+ 
+ //
+ //void CtrlPktTimer::expire(Event *e)
+ //{
+ //	mac_->sendDown(pkt_);
+ //}
+ void AckWaitTimer::expire(Event *e)
+ {
+ 	//int pkt_id = HDR_CMN(pkt_)->uid();
+ 	mac_->PktWH_.insert2PktQs(pkt_);
+ 	pkt_ = NULL;
+ }
+ 
+ 
+ void CtrlPktTimer::expire(Event *e)
+ {
+ 	mac_->SendPkt(pkt_);
+ 	pkt_ = NULL;
+ }
+ 
+ 
+ void ctrlpktqueue::insert(Packet *ctrl_p, Time delay)
+ {
+ 	CtrlPktTimer* tmp = new CtrlPktTimer(mac_);
+ 	tmp->pkt_ = ctrl_p;
+ 	tmp->resched(delay);
+ 	CtrlQ_.push(tmp);
+ }
+ 
+ void ctrlpktqueue::clearExpiredElem()
+ {
+ 	CtrlPktTimer* tmp = NULL;
+ 	while( (CtrlQ_.size() >0) && ((CtrlQ_.front())->pkt_ == NULL) ) {
+ 		tmp = CtrlQ_.front();
+ 		CtrlQ_.pop();
+ 		delete tmp;
+ 	}
+ }
+ 
+ void OTMAN::printDelayTable()
+ {
+ 	FILE* stream = fopen("distance", "a");
+ 
+ 	map<nsaddr_t, Time>::iterator pos=prop_delays.begin();
+ 	for(;pos != prop_delays.end(); pos++) {
+ 		fprintf(stream, "%f\n", pos->second*1500);
+ 	}
+ 
+ 	fclose(stream);
+ }
+ 
+ void PrintDistanceTimer::expire(Event *e)
+ {
+ 	mac_->printDelayTable();
+ }
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/COPEMAC/copemac.h ns-2.35-aquasim/underwatersensor/uw_mac/COPEMAC/copemac.h
*** ns-2.35/underwatersensor/uw_mac/COPEMAC/copemac.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/COPEMAC/copemac.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,526 ----
+ #ifndef __OTMAN_H__
+ #define __OTMAN_H__
+ 
+ #include <packet.h>
+ #include <random.h>
+ 
+ #include <timer-handler.h>
+ 
+ #include <mac.h>
+ #include "../underwatermac.h"
+ #include "../underwaterchannel.h"
+ #include "../underwaterpropagation.h"
+ 
+ 
+ 
+ #include <map>
+ #include <set>
+ #include <vector>
+ #include <queue>
+ using namespace std;
+ 
+ 
+ #define OTMAN_CALLBACK_DELAY 0.001
+ #define OTMAN_BACKOFF_TIME	 0.01
+ #define	OTMAN_REV_DELAY		0.5
+ #define BACKOFF_DELAY_ERROR		1
+ #define	MAX_INTERVAL		1
+ #define SEND_DELAY			0.001
+ #define MAXIMUMCOUNTER		6
+ 
+ typedef double Time;
+ 
+ enum PacketType{
+ 	OTMAN_ND,
+ 	OTMAN_ND_REPLY,
+ 	MULTI_REV,
+ 	MULTI_REV_ACK,
+ 	MULTI_DATA_ACK
+ };
+ //neighbor discovery packet header
+ 
+ //struct hdr_nd{
+ //	Time send_time_;
+ //	static inline int size() { 
+ //		return 8; 
+ //	}
+ //};
+ //
+ //
+ //struct hdr_nd_reply{
+ //	Time nd_send_time_;
+ //	Time delay_at_receiver;
+ //	static inline int size() {
+ //		return sizeof(Time)+sizeof(Time); 
+ //	}
+ //};
+ //
+ //
+ //struct hdr_ctrl{
+ //	int size_;
+ //	inline int size() { return size_; }	
+ //};
+ 
+ 
+ struct hdr_otman{
+ 	PacketType packet_type;
+ 	inline int size() {
+ 		return 1; //return size_;
+ 	};
+ 	/*union{
+ 		hdr_nd ndh;
+ 		hdr_nd_reply nd_reply_h;
+ 		hdr_ctrl  ctrl_h;
+ 	}hdr;*/
+ 	int size_;
+ 
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_otman* access(const Packet*  p) {
+ 		return (hdr_otman*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ //-----------------------------------------------
+ //save the incoming packets.
+ //-----------------------------------------------
+ 
+ 
+ struct PktElem{
+ 	Packet* pkt_;
+ 	PktElem* next_;
+ 	inline PktElem(): pkt_(NULL), next_(NULL) {
+ 	}
+ 	inline PktElem(Packet* pkt): pkt_(pkt), next_(NULL) {
+ 	}
+ };
+ 
+ struct PktList{
+ 	PktElem* head;
+ 	PktElem* tail;
+ 	inline PktList(): head(NULL), tail(NULL){
+ 	};
+ 	inline ~PktList() {
+ 		PktElem* temp = NULL;
+ 		while (head != tail ) {
+ 			temp = head;
+ 			head = head->next_;
+ 			Packet::free(temp->pkt_);
+ 			temp->next_ = NULL;
+ 		}
+ 	}
+ };
+ 
+ 
+ 
+ class OTMAN;
+ 
+ //all pending packets are stored in this data structure
+ class PktWareHouse{
+ 	friend class OTMAN;
+ private:
+ 	map<nsaddr_t, PktList> Queues;
+ 	int		CachedPktNum_;
+ 	bool	locked;
+ public:
+ 	PktWareHouse():CachedPktNum_(0), locked(false) {
+ 	}
+ 	inline bool IsEmpty() {
+ 		return !CachedPktNum_;
+ 	}
+ 		 
+ 	//inline void lock() {
+ 	//	locked = true;
+ 	//}
+ 
+ 	//inline void unlock() {
+ 	//	locked = false;
+ 	//}
+ 	void	insert2PktQs(Packet* p);
+ 	bool	deletePkt(nsaddr_t Recver, int SeqNum);
+ };
+ 
+ 
+ //----------------------------------------------------
+ //cache the reservation request
+ struct RevReq{
+ 	nsaddr_t	requestor;
+ 	int			AcceptedRevID;  //if AcceptedRevID and RejctedRevID is not succesive, both are rejected
+ 	int			RejectedRevID;
+ 	Time		StartTime;
+ 	Time		EndTime;
+ };
+ 
+ struct DataAck{
+ 	nsaddr_t Sender;
+ 	int		 SeqNum;
+ };
+ //---------------------------------------------------
+ class PktSendTimer: public TimerHandler{
+ public:
+ 	PktSendTimer(OTMAN* mac, Packet* pkt): TimerHandler() {
+ 		mac_ = mac;
+ 		pkt_ = pkt;
+ 	}
+ 	~PktSendTimer();
+ protected:
+ 	OTMAN* mac_;
+ 	Packet* pkt_;
+ 	void expire(Event* e);
+ };
+ 
+ enum RevType {
+ 		PRE_REV,	//the interval is in reserved in REV Request
+ 		AVOIDING,	//overheared from rev-ack. cannot receive but can send at this time
+ 		SENDING,	//the interval is for that this node sends packet
+ 		RECVING	//the interval is for receiving packet from other nodes
+ };
+ 
+ //Reservation Element
+ struct RevElem{
+ 
+ 	Time		StartTime;
+ 	Time		EndTime;
+ 	nsaddr_t	Reservor;   //reserve for which node
+ 	RevType		rev_type;
+ 	int			RevID;
+ 
+ 	
+ 	//node may reserve time for itself to send out packet, this timer is used to send packet
+ 	PktSendTimer* send_timer;
+ 	RevElem*	next;
+ 	RevElem();
+ 	RevElem(int RevID_, Time StartTime_, 
+ 		Time EndTime_, nsaddr_t Reservor_, RevType rev_type_);
+ 	~RevElem();
+ };
+ 
+ 
+ class RevQueues{
+ private:
+ 	RevElem*	Head_;
+ 	OTMAN*		mac_;
+ public:
+ 	RevQueues(OTMAN* mac);
+ 	~RevQueues();
+ 	/*
+ 	 * If [startTime, EndTime] overlaps with some 
+ 	 * existing reservation time interval,
+ 	 * push will fails and false is returned. 
+ 	 * Otherwise, insert successfully and return true.
+ 	 * If force is true, it will not check availability
+ 	 */
+ 	bool push(int RevID, Time StartTime, Time EndTime, nsaddr_t Reservor, 
+ 		RevType rev_type, Packet* pkt=NULL);
+ 	void	clearExpired(Time ExpireTime);
+ 	bool    checkAvailability(Time StartTime, Time EndTime, RevType rev_type);
+ 	void	deleteRev(int RevID);
+ 	void	updateStatus(int RevID, RevType new_type);
+ 	void	printRevQueue();
+ 	Time	getValidStartTime(Time Interval, Time SinceTime=NOW);  //absolute time
+ };
+ 
+ //---------------------------------------------------
+ 
+ 
+ 
+ //handlers
+ class OTMAN_CallbackHandler: public Handler{
+ public:
+ 	OTMAN_CallbackHandler(OTMAN* mac) {
+ 		mac_ = mac;
+ 	}
+ 	void handle(Event*);
+ private:
+ 	OTMAN* mac_;
+ };
+ 
+ 
+ class OTMAN_StatusHandler: public Handler{
+ public:
+ 	OTMAN_StatusHandler(OTMAN* mac) {
+ 		mac_ = mac;
+ 	}
+ 	void handle(Event*);
+ private:
+ 	OTMAN* mac_;
+ };
+ 
+ 
+ class OTMAN_SendDelayHandler: public Handler{
+ public:
+ 	OTMAN_SendDelayHandler(OTMAN* mac) {
+ 		mac_ = mac;
+ 	}
+ 	void handle(Event*);
+ private:
+ 	OTMAN* mac_;
+ };
+ 
+ class OTMAN_BackoffHandler: public Handler{
+ public:
+ 	OTMAN_BackoffHandler(OTMAN* mac) {
+ 		mac_ = mac;
+ 		counter = 0;
+ 	}
+ 	void clear();
+ 	void handle(Event*);
+ private:
+ 	OTMAN* mac_;
+ 	Packet* pkt_;
+ 	int counter;
+ 	friend class OTMAN;
+ };
+ 
+ 
+ class OTMAN_NDProcess_Initor: public TimerHandler{
+ public:
+ 	OTMAN_NDProcess_Initor(OTMAN* mac): TimerHandler() {
+ 		mac_ = mac;
+ 		MaxTimes_ = 3;
+ 	}
+ 
+ protected:
+ 	OTMAN* mac_;
+ 	int MaxTimes_;    //the maximum times of delay measurement
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class OTMAN_NDReply_Initor: public TimerHandler{
+ 	public:
+ 	OTMAN_NDReply_Initor(OTMAN* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 
+ protected:
+ 	OTMAN* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class OTMAN_DataSendTimer: public TimerHandler {
+ public:
+ 	OTMAN_DataSendTimer(OTMAN* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	OTMAN* mac_;  //Data pulse
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class OTMAN_RevAckAccumTimer: public TimerHandler {
+ public:
+ 	OTMAN_RevAckAccumTimer(OTMAN* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	
+ protected:
+ 	OTMAN* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class OTMAN_DataAckAccumTimer: public TimerHandler {
+ public:
+ 	OTMAN_DataAckAccumTimer(OTMAN* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	
+ protected:
+ 	OTMAN* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ class OTMAN_InitiatorTimer: public TimerHandler {
+ public:
+ 	OTMAN_InitiatorTimer(OTMAN* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	OTMAN* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ struct NDRecord{
+ 	Time nd_sendtime;
+ 	Time nd_recvtime;
+ };
+ 
+ class CtrlPktTimer: public TimerHandler{
+ public:
+ 	CtrlPktTimer(OTMAN* mac):TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	OTMAN* mac_;
+ 	Packet* pkt_;
+ protected:
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class ctrlpktqueue{
+ public:
+ 	ctrlpktqueue(OTMAN* mac) {
+ 		mac_ = mac;
+ 	}
+ 	void insert(Packet* ctrl_p, Time delay);
+ 	void clearExpiredElem();
+ 	
+ protected:
+ 	OTMAN* mac_;
+ 	queue<CtrlPktTimer*>  CtrlQ_;
+ };
+ 
+ class AckWaitTimer: public TimerHandler{
+ public:
+ 	AckWaitTimer(): TimerHandler() {
+ 		mac_ = NULL;
+ 	}
+ 	Packet* pkt_;
+ 	OTMAN* mac_;
+ protected:	
+ 	virtual void expire(Event* e);
+ 
+ };
+ 
+ class PrintDistanceTimer: public TimerHandler{
+ public:
+ 	PrintDistanceTimer(OTMAN* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	virtual void expire(Event* e);
+ 	OTMAN* mac_;
+ };
+ 
+ class OTMAN: public UnderwaterMac{
+ public:
+ 	OTMAN();
+ 	int  command(int argc, const char*const* argv);
+ 	// to process the incomming packet
+ 	virtual  void RecvProcess(Packet*);
+ 	// to process the outgoing packet
+ 	virtual  void TxProcess(Packet*);
+ 	
+ 
+ 
+ protected:
+ 	void	PreSendPkt(Packet* pkt, Time delay=0.0001);  //send out the packet after delay
+ 	void	SendPkt(Packet* pkt);
+ 	void	start();
+ 	//int	round2Slot(Time time);  //round the time to the slot sequence num since now
+ 	//Time	Slot2Time(int SlotNum, Time BaseTime = NOW);
+ 	//Time	round2RecverSlotBegin(Time time, nsaddr_t recver);
+ 
+ 	void	startHandShake();
+ 	Time	map2OwnTime(Time SenderTime, nsaddr_t Sender); //map time SenderTime on sender to the time on this node
+ 
+ 	void	RecordDataPkt(Packet* pkt);
+ 	//process control packets.
+ 	void	processND(Packet* pkt);
+ 	void	processNDReply(Packet* pkt);
+ 	void	processMultiRev(Packet* pkt);
+ 	void	processMultiRevAck(Packet* pkt);
+ 	void	processDataAck(Packet* pkt);
+ 
+ 	//make control packets.
+ 	Packet* makeND();  //ND packet include the neighbors which this node already knows.
+ 	Packet* makeNDReply(); 
+ 	Packet* makeMultiRev();
+ 	Packet* makeMultiRevAck();
+ 	Packet* makeDataAck();
+ 
+ 	//for test
+ 	void	printDelayTable();
+ 	void	printResult();
+ 
+ 
+ 	void	clearAckWaitingList();
+ 	void	insertAckWaitingList(Packet* p, Time delay);
+ 
+ 	//hanlder callback functions & Events
+ 	void	CallbackProcess(Event* e);
+ 	void	StatusProcess(Event *e);
+ 	Event	callback_event;
+ 	Event	status_event;
+ 	Event	backoff_event;
+ 	
+ 
+ 	//handlers and timers
+ 	OTMAN_CallbackHandler	callback_handler;
+ 	OTMAN_StatusHandler		status_handler;
+ 	OTMAN_SendDelayHandler	senddelay_handler;
+ 	OTMAN_BackoffHandler	backoff_handler;
+ 	OTMAN_NDProcess_Initor	nd_process_initor;  //it's a timer
+ 	OTMAN_NDReply_Initor	ndreply_initor;
+ 	OTMAN_DataSendTimer		DataSendTimer;
+ 	OTMAN_RevAckAccumTimer	RevAckAccumTimer;
+ 	OTMAN_DataAckAccumTimer DataAckAccumTimer;
+ 	OTMAN_InitiatorTimer	InitiatorTimer;
+ 	PrintDistanceTimer		PrintTimer;
+ 
+ private:
+ 	/*Time	PktInterval_;*/	//the interval between sending two packet
+ 	Time	NDInterval_;	//the interval between two successive ND process
+ 	Time	DataAccuPeriod;	//the period of data pulse 
+ 	Time	DataTxStartTime_;
+ 	Time	RevAckAccumTime_;
+ 	Time	DataAckAccumTime_;
+ 	/*length of time slot should be bigger than maximum transmissioin time of packet*/
+ 	//Time	TimeSlotLen_;
+ 	PktWareHouse	PktWH_;	
+ 	
+ 	map<nsaddr_t, Time>	prop_delays;  //the propagation delay to neighbors
+ 	map<nsaddr_t, Time>	nd_receive_time;   //the time when receives ND packet
+ 	map<nsaddr_t, Time>	nd_depart_neighbor_time;    //the time when neighbor send ND to this node
+ 	vector<RevReq*>	 PendingRevs;  //all pending revs are stored here. Schedule it before sending ack
+ 	vector<DataAck*> PendingDataAcks;
+ 	map<nsaddr_t, int>	SucDataNum;   //result is here
+ 
+ 	RevQueues	RevQ_;
+ 	uint	next_hop;
+ 	uint	neighbor_id;
+ 	//Time MajorBackupInterval; //int		MaxSlotRange_;  //the interval between majorInterval and backup
+ 	
+ 	//the begin time of MajorInterval will be chosen among the following two values
+ 	//they are the offset based on current time
+ 	Time		MajorIntervalLB;  //lower bound of major interval//RecvSlotLowerRange; 
+ 	
+ 	Time		DataStartTime;
+ 	static int		RevID;
+ 	Time	GuardTime;
+ 	Time	NDWin;
+ 	Time	NDReplyWin;
+ 	map<nsaddr_t, NDRecord> PendingND;
+ 
+ 	map<int, AckWaitTimer>	AckWaitingList; //stores the packet is (prepared to) sent out but not receive the ack yet.
+ 	
+ 	Time	AckTimeOut;
+ 	ctrlpktqueue    CtrlPktQ_;
+ 	int		PktSize;
+ 
+ 	int		isParallel;
+ 	
+ 	friend class RevQueues;
+ 	friend class OTMAN_CallbackHandler;
+ 	friend class OTMAN_StatusHandler;
+ 	friend class OTMAN_NDProcess_Initor;
+ 	friend class OTMAN_NDReply_Initor;
+ 	friend class OTMAN_DataSendTimer;
+ 	friend class OTMAN_RevAckAccumTimer;
+ 	friend class PktSendTimer;
+ 	friend class OTMAN_DataAckAccumTimer;
+ 	friend class OTMAN_SendDelayHandler;
+ 	friend class OTMAN_BackoffHandler;
+ 	friend class OTMAN_InitiatorTimer;
+ 	friend class AckWaitTimer;
+ 	friend class CtrlPktTimer;
+ 	friend class ctrlpktqueue;
+ 	friend class PrintDistanceTimer;
+ 
+ };
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_mac/FAMA/fama.cc ns-2.35-aquasim/underwatersensor/uw_mac/FAMA/fama.cc
*** ns-2.35/underwatersensor/uw_mac/FAMA/fama.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/FAMA/fama.cc	2016-09-03 00:43:31.928000000 +0800
***************
*** 0 ****
--- 1,522 ----
+ #include "fama.h"
+ #include "underwatersensor/uw_routing/vectorbasedforward.h"
+ 
+ 
+ 
+ int hdr_FAMA::offset_;
+ static class FAMA_HeaderClass: public PacketHeaderClass{
+ public:
+ 	FAMA_HeaderClass():PacketHeaderClass("PacketHeader/FAMA",sizeof(hdr_FAMA))
+ 	{
+ 		bind_offset(&hdr_FAMA::offset_);
+ 	}
+ }class_FAMA_hdr;
+ 
+ 
+ static class FAMAClass : public TclClass {
+ public:
+ 	FAMAClass():TclClass("Mac/UnderwaterMac/FAMA") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new FAMA());
+ 	}
+ }class_FAMA;
+ 
+ 
+ void FAMA_ND_Timer::expire(Event *e)
+ {
+ 	mac_->sendPkt(mac_->makeND());
+ 	nd_times_--;
+ 
+ 	if( nd_times_ > 0 )
+ 		resched(Random::uniform(mac_->NDPeriod));
+ }
+ 
+ 
+ void FAMA_BackoffTimer::expire(Event *e)
+ {
+ 	mac_->sendRTS(2*mac_->MaxPropDelay
+ 		+mac_->RTSTxTime+mac_->CTSTxTime+mac_->EstimateError);
+ }
+ 
+ 
+ void FAMA_StatusHandler::handle(Event *e)
+ {
+ 	mac_->StatusProcess();
+ }
+ 
+ 
+ void FAMA_WaitCTSTimer::expire(Event *e)
+ {
+ 	mac_->doBackoff();
+ }
+ 
+ 
+ void FAMA_DataSendTimer::expire(Event *e)
+ {
+ 	mac_->processDataSendTimer(this);
+ }
+ 
+ 
+ 
+ void FAMA_DataBackoffTimer::expire(Event *e)
+ {
+ 	mac_->processDataBackoffTimer();
+ }
+ 
+ 
+ 
+ void FAMA_RemoteTimer::expire(Event* e)
+ {
+ 	mac_->processRemoteTimer();
+ }
+ 
+ 
+ void FAMA_CallBackHandler::handle(Event* e)
+ {
+ 	mac_->CallbackProcess(e);
+ }
+ 
+ 
+ FAMA::FAMA(): UnderwaterMac(), FAMA_Status(PASSIVE), NDPeriod(4), MaxBurst(1),
+ 		DataPktInterval(0.00001), EstimateError(0.001),DataPktSize(1600),
+ 		neighbor_id(0), backoff_timer(this), status_handler(this), NDTimer(this), 
+ 		WaitCTSTimer(this),DataBackoffTimer(this),RemoteTimer(this), CallBack_Handler(this)
+ {
+ 	MaxPropDelay = UnderwaterChannel::Transmit_distance()/1500.0;
+ 	RTSTxTime = MaxPropDelay;
+ 	CTSTxTime = RTSTxTime + 2*MaxPropDelay;
+ 	
+ 	MaxDataTxTime = DataPktSize/bit_rate_;  //1600bits/10kbps
+ 
+ 	bind("MaxBurst", &MaxBurst);
+ 
+ 	NDTimer.resched(Random::uniform(NDPeriod)+0.000001);
+ }
+ 
+ 
+ 
+ void FAMA::sendPkt(Packet *pkt)
+ {
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 	//hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+ 	double txtime=cmh->txtime();
+ 	Scheduler& s=Scheduler::instance();
+ 	
+ 	switch( n->TransmissionStatus() ) {
+ 		case SLEEP:
+ 			Poweron();
+ 
+ 		case IDL:
+ 			n->SetTransmissionStatus(SEND); 
+ 			cmh->timestamp() = NOW;
+ 			cmh->direction() = hdr_cmn::DOWN;
+ 			sendDown(pkt);
+ 			s.schedule(&status_handler,&status_event,txtime);
+ 			break;
+ 		case RECV:
+ 			printf("RECV-SEND Collision!!!!!\n");
+ 			Packet::free(pkt);
+ 			break;
+ 			
+ 		default:
+ 			//status is SEND
+ 			printf("node%d send data too fast\n",index_);
+ 			Packet::free(pkt);
+ 
+ 	}
+ 
+ 	return;
+ }
+ 
+ 
+ 
+ void FAMA::StatusProcess()
+ {
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	n->SetTransmissionStatus(IDL);
+ 	return;
+ }
+ 
+ 
+ void FAMA::TxProcess(Packet* pkt)
+ {
+ 	Scheduler::instance().schedule(&CallBack_Handler, &callback_event, CALLBACK_DELAY);
+ 
+ 	if( NeighborList_.empty() ) {
+ 		Packet::free(pkt);
+ 		return;
+ 	}
+ 	//figure out how to cache the packet will be sent out!!!!!!!
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 	cmh->size() = DataPktSize;
+ 	cmh->txtime() = MaxDataTxTime;
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 
+ 	UpperLayerPktType = cmh->ptype();
+ 
+ 	cmh->next_hop() = NeighborList_[neighbor_id];
+ 	neighbor_id = (neighbor_id+1)%NeighborList_.size();
+ 	cmh->ptype() = PT_FAMA;
+ 
+ 	vbh->target_id.addr_ = cmh->next_hop();
+ 	FAMAh->packet_type = hdr_FAMA::FAMA_DATA;
+ 	FAMAh->SA = index_;
+ 	FAMAh->DA = cmh->next_hop();
+ 
+ 	PktQ_.push(pkt);
+ 	
+ 	//fill the next hop when sending out the packet;
+ 	if( (PktQ_.size() == 1) /*the pkt is the first one*/
+ 		&& FAMA_Status == PASSIVE ) {
+ 
+ 			if( CarrierDected() ) {
+ 				doRemote(2*MaxPropDelay+EstimateError);
+ 			}
+ 			else{
+ 				sendRTS(2*MaxPropDelay+CTSTxTime+RTSTxTime+EstimateError);
+ 			}
+ 		
+ 	}
+ }
+ 
+ 
+ void FAMA::RecvProcess(Packet *pkt)
+ {
+ 	hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 	nsaddr_t dst = FAMAh->DA;
+ 	//int src = mh->macSA();
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+ 	
+ 	if( backoff_timer.status() == TIMER_PENDING ) {
+ 		backoff_timer.cancel();
+ 		doRemote(2*MaxPropDelay+EstimateError);
+ 	} else if( RemoteTimer.status() == TIMER_PENDING ) {
+ 		RemoteTimer.cancel();
+ 		RemoteTimer.ExpiredTime = -1;
+ 	}
+ 
+ 	/*ND is not a part of FAMA. We just want to use it to get next hop
+ 	 *So we do not care wether it collides with others
+ 	 */
+ 	if( (cmh->ptype()==PT_FAMA) 
+ 		&& (FAMAh->packet_type==hdr_FAMA::ND) ) {
+ 		processND(pkt);
+ 		Packet::free(pkt);
+ 		return;
+ 	}
+ 	
+     if( cmh->error() ) 
+     {
+      	//printf("broadcast:node %d  gets a corrupted packet at  %f\n",index_,NOW);
+      	if(drop_)
+ 			drop_->recv(pkt,"Error/Collision");
+      	else
+ 			Packet::free(pkt);
+ 
+ 		doRemote(2*MaxPropDelay+EstimateError);
+      	return;
+     }
+ 
+ 
+ 	if( WaitCTSTimer.status() == TIMER_PENDING ) {
+ 
+ 		//printf("%f: node %d receive RTS\n", NOW, index_);
+ 		WaitCTSTimer.cancel();
+ 		if( (cmh->ptype() == PT_FAMA ) 
+ 			&& (FAMAh->packet_type==hdr_FAMA::CTS)
+ 			&& (cmh->next_hop()==index_) ) {
+ 			//receiving the CTS
+ 			sendDataPkt();
+ 		}
+ 		else {
+ 			doBackoff();
+ 		}
+ 		Packet::free(pkt);
+ 		return;
+ 	}
+ 
+ 
+ 	if( cmh->ptype() == PT_FAMA ) {
+ 
+ 		switch( FAMAh->packet_type ) {
+ 
+ 			case hdr_FAMA::RTS:
+ 				//printf("%f: node %d receive RTS\n", NOW, index_);
+ 				if( dst == index_ ) {
+ 					processRTS(pkt);
+ 				}
+ 				doRemote(CTSTxTime+2*MaxPropDelay+EstimateError);
+ 
+ 				break;
+ 			case hdr_FAMA::CTS:
+ 				//printf("%f: node %d receive CTS\n", NOW, index_);
+ 				// this CTS must be not for this node
+ 				doRemote(2*MaxPropDelay+EstimateError);
+ 				break;
+ 			default:
+ 				//printf("%f: node %d receive DATA\n", NOW, index_);
+ 				//process Data packet
+ 				if( dst == index_ ) {
+ 					cmh->ptype() = UpperLayerPktType;
+ 					sendUp(pkt);
+ 					return;
+ 				}
+ 				else {
+ 					doRemote(MaxPropDelay+EstimateError);
+ 				}
+ 				
+ 		}
+ 	}
+ 	
+ 	Packet::free(pkt);	
+ }
+ 
+ 
+ 
+ 
+ void FAMA::sendDataPkt()
+ {
+ 	int PktQ_Size = PktQ_.size();
+ 	int SentPkt = 0;
+ 	Time StartTime = NOW;
+ 	nsaddr_t recver = HDR_CMN(PktQ_.front())->next_hop();
+ 	Packet* tmp = NULL;
+ 	for(int i=0; i<PktQ_Size && SentPkt<MaxBurst; i++) {
+ 		tmp = PktQ_.front();
+ 		PktQ_.pop();
+ 		if( HDR_CMN(tmp)->next_hop() == recver ) {
+ 			SentPkt++;
+ 			FAMA_DataSendTimer* DataSendTimer = new FAMA_DataSendTimer(this);
+ 			DataSendTimer->pkt_ = tmp;
+ 			DataSendTimer->resched(StartTime-NOW);
+ 			DataSendTimerSet.insert(DataSendTimer);
+ 			if( !PktQ_.empty() ) {
+ 				StartTime += HDR_CMN(PktQ_.front())->txtime() + DataPktInterval;
+ 			}
+ 			else {
+ 				break;
+ 			}
+ 		}
+ 		else{
+ 			PktQ_.push(tmp);
+ 		}
+ 	}
+ 
+ 	FAMA_Status = WAIT_DATA_FINISH;
+ 
+ 	DataBackoffTimer.resched(MaxPropDelay+StartTime-NOW);
+ }
+ 
+ 
+ void FAMA::processDataSendTimer(FAMA_DataSendTimer * DataSendTimer)
+ {
+ 	FAMA_DataSendTimer* tmp = DataSendTimer;
+ 	sendPkt(DataSendTimer->pkt_);
+ 	DataSendTimer->pkt_ = NULL;
+ 	DataSendTimerSet.erase(DataSendTimer);
+ 	delete tmp;
+ }
+ 
+ 
+ 
+ void FAMA::processDataBackoffTimer()
+ {
+ 	if( !PktQ_.empty() )
+ 		doBackoff();
+ 	else
+ 		FAMA_Status = PASSIVE;
+ }
+ 
+ 
+ Packet* FAMA::makeND()
+ {
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 
+ 	cmh->size() = 2*sizeof(nsaddr_t)+1;
+ 	cmh->txtime() = getTxTimebyPktSize(cmh->size());
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->ptype() = PT_FAMA;
+ 	cmh->next_hop() = MAC_BROADCAST;
+ 
+ 	FAMAh->packet_type = hdr_FAMA::ND;
+ 	FAMAh->SA = index_;
+ 	FAMAh->DA = MAC_BROADCAST;
+ 
+ 	return pkt;
+ }
+ 
+ 
+ 
+ 
+ void FAMA::processND(Packet *pkt)
+ {
+ 	hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 	NeighborList_.push_back(FAMAh->SA);
+ 	return;
+ }
+ 
+ 
+ 
+ Packet* FAMA::makeRTS(nsaddr_t Recver)
+ {
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 
+ 
+ 	cmh->size() = getPktSizebyTxTime(RTSTxTime);
+ 	cmh->txtime() = RTSTxTime;
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->ptype() = PT_FAMA;
+ 	cmh->next_hop() = Recver;
+ 
+ 	FAMAh->packet_type = hdr_FAMA::RTS;
+ 	FAMAh->SA = index_;
+ 	FAMAh->DA = Recver;
+ 
+ 	return pkt;
+ }
+ 
+ 
+ 
+ void FAMA::sendRTS(Time DeltaTime)
+ { 
+ 	hdr_cmn* cmh = HDR_CMN( PktQ_.front() );
+ 	sendPkt( makeRTS(cmh->next_hop()) );
+ 	FAMA_Status = WAIT_CTS;
+ 	WaitCTSTimer.resched(DeltaTime);
+ }
+ 
+ 
+ void FAMA::processRTS(Packet *pkt)
+ {
+ 	nsaddr_t RTS_Sender = hdr_FAMA::access(pkt)->SA;
+ 	sendPkt(makeCTS(RTS_Sender));
+ 	FAMA_Status = WAIT_DATA;
+ }
+ 
+ 
+ 
+ Packet* FAMA::makeCTS(nsaddr_t RTS_Sender)
+ {
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 
+ 	cmh->size() = getPktSizebyTxTime(CTSTxTime);
+ 	cmh->txtime() = CTSTxTime;
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->ptype() = PT_FAMA;
+ 	cmh->next_hop() = RTS_Sender;
+ 
+ 	FAMAh->packet_type = hdr_FAMA::CTS;
+ 	FAMAh->SA = index_;
+ 	FAMAh->DA = RTS_Sender;
+ 
+ 	return pkt;
+ }
+ 
+ 
+ 
+ /*PktSize is in byte*/
+ Time FAMA::getTxTimebyPktSize(int PktSize)
+ {
+ 	return (PktSize*8)*encoding_efficiency_/bit_rate_;
+ }
+ 
+ int FAMA::getPktSizebyTxTime(Time TxTime)
+ {
+ 	return int((TxTime*bit_rate_)/(8*encoding_efficiency_));
+ }
+ 
+ 
+ bool FAMA::CarrierDected()
+ {
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	if( n->TransmissionStatus() == RECV
+ 		|| n->TransmissionStatus() == SEND )  {
+ 		
+ 		return true;
+ 	}
+ 	else {
+ 		return false;
+ 	}
+ 
+ }
+ 
+ void FAMA::doBackoff()
+ {
+ 	Time BackoffTime = Random::uniform(10*RTSTxTime);
+ 	FAMA_Status = BACKOFF;
+ 	if( backoff_timer.status() == TIMER_PENDING ) {
+ 		backoff_timer.cancel();
+ 	}
+ 	
+ 	backoff_timer.resched(BackoffTime);
+ }
+ 
+ 
+ void FAMA::doRemote(Time DeltaTime)
+ {
+ 	FAMA_Status = REMOTE;
+ 	
+ 	if( NOW+DeltaTime > RemoteTimer.ExpiredTime ) {
+ 		RemoteTimer.ExpiredTime = NOW+DeltaTime;
+ 		if( RemoteTimer.status() == TIMER_PENDING ) {
+ 			RemoteTimer.cancel();		
+ 		}
+ 		RemoteTimer.resched(DeltaTime);	
+ 	}
+ }
+ 
+ 
+ 
+ 
+ void FAMA::processRemoteTimer()
+ {
+ 	if( PktQ_.empty() ) {
+ 		FAMA_Status = PASSIVE;
+ 	}
+ 	else {
+ 		doBackoff();
+ 		//sendRTS(2*MaxPropDelay+CTSTxTime+RTSTxTime+EstimateError);
+ 	}
+ }
+ 
+ 
+ 
+ void FAMA::CallbackProcess(Event* e)
+ {
+ 	callback_->handle(e);
+ }
+ 
+ 
+ int FAMA::command(int argc, const char *const *argv)
+ {
+ 	if(argc == 3) {
+ 		if (strcmp(argv[1], "node_on") == 0) {
+ 			Node* n1=(Node*) TclObject::lookup(argv[2]);
+ 			if (!n1) return TCL_ERROR;
+ 			node_ =n1; 
+ 			return TCL_OK;
+ 		}
+ 	}
+ 
+ 	return UnderwaterMac::command(argc, argv);
+ }
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/FAMA/fama.h ns-2.35-aquasim/underwatersensor/uw_mac/FAMA/fama.h
*** ns-2.35/underwatersensor/uw_mac/FAMA/fama.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/FAMA/fama.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,240 ----
+ #ifndef __FAMA_H__
+ #define __FAMA_H__
+ 
+ #include <packet.h>
+ #include <random.h>
+ 
+ #include <timer-handler.h>
+ 
+ #include <mac.h>
+ #include "../underwatermac.h"
+ #include "../underwaterchannel.h"
+ #include "../underwaterpropagation.h"
+ 
+ 
+ #include <queue>
+ #include <vector>
+ #include <set>
+ using namespace std;
+ 
+ typedef double Time;
+ #define CALLBACK_DELAY 0.001
+ 
+ class FAMA;
+ 
+ struct hdr_FAMA{
+ 	nsaddr_t SA;
+ 	nsaddr_t DA;
+ 
+ 	enum PacketType {
+ 		RTS,	//the previous forwarder thinks this is DATA-ACK
+ 		CTS,
+ 		FAMA_DATA,
+ 		ND		//neighbor discovery. need know neighbors, so it can be used as next hop.
+ 	} packet_type;
+ 
+ 	static int offset_;
+ 	inline static int& offset() {  return offset_; }
+ 
+ 	inline static hdr_FAMA* access(const Packet*  p) {
+ 		return (hdr_FAMA*) p->access(offset_);
+ 	}
+ 
+ };
+ 
+ class FAMA_ND_Timer: public TimerHandler{
+ public:
+ 	FAMA_ND_Timer(FAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 		nd_times_ = 4;
+ 	}
+ protected:
+ 	FAMA* mac_;
+ 	int	 nd_times_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class FAMA_BackoffTimer: public TimerHandler{
+ public:
+ 	FAMA_BackoffTimer(FAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 
+ protected:
+ 	FAMA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class FAMA_StatusHandler: public Handler{
+ public:
+ 	FAMA_StatusHandler(FAMA* mac): Handler() {
+ 		mac_ = mac;
+ 	}
+ 
+ protected:
+ 	FAMA* mac_;
+ 	virtual void handle(Event* e);
+ };
+ 
+ 
+ 
+ class FAMA_WaitCTSTimer: public TimerHandler{
+ public:
+ 	FAMA_WaitCTSTimer(FAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	FAMA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ class FAMA_DataSendTimer: public TimerHandler{
+ public:
+ 	FAMA_DataSendTimer(FAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	Packet* pkt_;
+ protected:
+ 	FAMA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class FAMA_DataBackoffTimer: public TimerHandler{
+ public:
+ 	FAMA_DataBackoffTimer(FAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 
+ protected:
+ 	FAMA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ 
+ class FAMA_RemoteTimer: public TimerHandler{
+ public:
+ 	FAMA_RemoteTimer(FAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 		ExpiredTime = -1;
+ 	}
+ 	
+ protected:
+ 	FAMA* mac_;
+ 	Time	ExpiredTime;
+ 	virtual void expire(Event* e);
+ 	friend class FAMA;
+ };
+ 
+ 
+ class FAMA_CallBackHandler: public Handler{
+ public:
+ 	FAMA_CallBackHandler(FAMA* mac): Handler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	FAMA* mac_;
+ 	virtual void handle(Event* e);
+ };
+ 
+ class FAMA: public UnderwaterMac{
+ public:
+ 	FAMA();
+ 	int  command(int argc, const char*const* argv);
+ 	void TxProcess(Packet* pkt);
+ 	void RecvProcess(Packet* pkt);
+ 
+ 
+ protected:
+ 
+ 	enum {
+ 		PASSIVE,
+ 		BACKOFF,
+ 		WAIT_CTS,
+ 		WAIT_DATA_FINISH,
+ 		WAIT_DATA,
+ 		REMOTE   /*I don't know what it it means. but 
+ 				 node can only receiving packet in this status*/
+ 	}FAMA_Status;
+ 
+ 	Time NDPeriod;
+ 	int  MaxBurst;	//the maximum number of packet burst. default is 1
+ 	Time DataPktInterval;  //0.0001??
+ 
+ 	Time EstimateError;		//Error for timeout estimation
+ 	int	 DataPktSize;
+ 	int	 neighbor_id; //use this value to pick the next hop one by one
+ 
+ 	FAMA_BackoffTimer		backoff_timer;
+ 	FAMA_StatusHandler		status_handler;
+ 	FAMA_ND_Timer			NDTimer;   //periodically send out Neighbor discovery packet for 4 times.
+ 	FAMA_WaitCTSTimer		WaitCTSTimer;
+ 	FAMA_DataBackoffTimer	DataBackoffTimer;
+ 	FAMA_RemoteTimer		RemoteTimer;
+ 	FAMA_CallBackHandler	CallBack_Handler;
+ 
+ 
+ 	Time MaxPropDelay;
+ 	Time RTSTxTime;
+ 	Time CTSTxTime;
+ 
+ 	Time MaxDataTxTime;
+ 
+ 
+ 	queue<Packet*>	PktQ_;
+ 	vector<nsaddr_t> NeighborList_;
+ 	set<FAMA_DataSendTimer*> DataSendTimerSet;
+ 
+ 	Event	status_event;
+ 	Event	callback_event;
+ 
+ 	packet_t UpperLayerPktType;
+ 
+ 
+ 	Packet* makeND(); //broadcast
+ 	Packet* makeRTS(nsaddr_t Recver);
+ 	Packet* makeCTS(nsaddr_t RTS_Sender);
+ 
+ 	void	processND(Packet* pkt);
+ 	void	processRTS(Packet* pkt);
+ 
+ 	void	sendRTS(Time DeltaTime);
+ 
+ 	void	sendPkt(Packet* pkt);
+ 	void	sendDataPkt();
+ 
+ 	void	processDataSendTimer(FAMA_DataSendTimer* DataSendTimer);
+ 	void	processDataBackoffTimer();
+ 	void	processRemoteTimer();
+ 
+ 
+ 	void	StatusProcess();
+ 	void	backoffProcess();
+ 	void	CallbackProcess(Event* e);
+ 
+ 
+ 	Time	getTxTimebyPktSize(int PktSize);
+ 	int		getPktSizebyTxTime(Time TxTime);
+ 	bool	CarrierDected();
+ 	void	doBackoff();
+ 	void	doRemote(Time DeltaTime);
+ 
+ 
+ 
+ 	friend class FAMA_BackoffTimer;
+ 	friend class FAMA_ND_Timer;
+ 	friend class FAMA_StatusHandler;
+ 	friend class FAMA_WaitCTSTimer;
+ 	friend class FAMA_DataSendTimer;
+ 	friend class FAMA_DataBackoffTimer;
+ 	friend class FAMA_RemoteTimer;
+ 	friend class FAMA_CallBackHandler;
+ 
+ };
+ 
+ #endif
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/rmac.cc ns-2.35-aquasim/underwatersensor/uw_mac/rmac.cc
*** ns-2.35/underwatersensor/uw_mac/rmac.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/rmac.cc	2016-09-03 00:39:39.772000000 +0800
***************
*** 0 ****
--- 1,3153 ----
+ /* 
+ In this version of RMAC, the major modifications for the 10-5-2006 
+   version are :
+ 1. Adding the number of control for phase 2
+ 2. Adding the full collecting reservations, i.e., each node has 
+    to collect reservations in two consecutive periods.       
+ 3. when the revack windows collide, the receiver will schedule the ackrev 
+ in the next period interval
+ 4. no carrier sensing necessary               
+ */
+ 
+ #include "packet.h"
+ //#include "random.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "underwatersensor/uw_routing/vectorbasedforward.h"
+ #include "mac.h"
+ #include "rmac.h"
+ #include "underwaterphy.h"
+ #include "random.h"
+ #include <stdlib.h>
+ 
+ 
+ int hdr_rmac::offset_;
+ 
+ 
+ 
+ static class RMACHeaderClass: public PacketHeaderClass{
+  public:
+   RMACHeaderClass():PacketHeaderClass("PacketHeader/RMAC",sizeof(hdr_rmac))
+ {
+  bind_offset(&hdr_rmac::offset_);
+ }
+ } class_rmachdr;
+ 
+ 
+ 
+ 
+ //MACRECVHandler::MACRECVHandler(RMac* p): mac_(p),duration(0),status(0),data_sender(0){}
+ 
+ void 
+ MACRECVHandler::handle(Event* e)
+ {
+   mac_->StartRECV(duration, status, data_sender);
+ }
+ 
+ //ClearChannelHandler::ClearChannelHandler(RMac* p): mac_(p){}
+ 
+ void 
+ ClearChannelHandler::handle(Event* e)
+ {
+   mac_->ClearChannel();
+ }
+ 
+ 
+ 
+ 
+ //ACKREVHandler::ACKREVHandler(RMac* p): mac_(p){}
+ 
+ void 
+ ACKREVHandler::handle(Event* e)
+ {
+   printf("ACKREVHandler: node%d handle ackrev\n",mac_->index_);
+   mac_->TxACKRev((Packet*) e);
+ }
+ 
+ //SYNHandler::SYNHandler(RMac* p): mac_(p){}
+ 
+ void 
+ SYNHandler::handle(Event* e)
+ {
+   printf("SYNHandler: node%d handle syn\n",mac_->index_);
+   mac_->TxND((Packet*) e, mac_->PhaseTwo_window_);
+ }
+ 
+ 
+ //TimeoutHandler::TimeoutHandler(RMac* p): mac_(p){}
+ 
+ void 
+ TimeoutHandler::handle(Event* e)
+ {
+  
+   mac_->ResetMacStatus();
+ }
+ 
+ /*
+ 
+ void 
+ RMac::InitPhaseThree(){
+ 
+  
+   printf("RMac: this is InitPhaseThree\n"); 
+ 
+    SortPeriodTable();
+    PrintTable();
+ 
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   if(n->TransmissionStatus()==SLEEP) Poweron();
+   
+   mac_status=RMAC_IDLE;
+   Scheduler &s=Scheduler::instance();
+    s.schedule(&sleep_handler,&sleep_event,duration_);
+     return;
+ }
+ */
+ 
+ 
+ 
+ //SleepHandler::SleepHandler(RMac* p): mac_(p){}
+ 
+ void 
+ SleepHandler::handle(Event* e)
+ {
+   mac_->ProcessSleep();
+ }
+ 
+ //WakeupHandler::WakeupHandler(RMac* p): mac_(p){}
+ 
+ void 
+ WakeupHandler::handle(Event* e)
+ {
+   mac_->Wakeup();
+ }
+ 
+ 
+ 
+ //NDBackoffHandler::NDBackoffHandler(RMac* p):mac_(p),window_(0),counter_(0){}
+  
+ void NDBackoffHandler::handle(Event*e)
+ {
+   counter_++;
+   if(counter_<MAXIMUMBACKOFF)
+     mac_->TxND((Packet*)e, window_);
+   else 
+     {
+     clear();
+   printf("Rmac:backoff:too many backoffs\n");
+   Packet::free((Packet*)e);
+     }
+ }
+ 
+ void NDBackoffHandler::clear(){
+ counter_=0;
+ }
+ 
+ 
+ //ReserveHandler::ReserveHandler(RMac* p):mac_(p){}
+  
+ void ReserveHandler::handle(Event*e)
+ {
+   mac_->TxRev(e);
+ }
+ 
+ 
+ //ACKDATAHandler::ACKDATAHandler(RMac* p):mac_(p){}
+  
+ void ACKDATAHandler::handle(Event*e)
+ {
+   mac_->TxACKData(e);
+ }
+ 
+ 
+ //ACKWindowHandler::ACKWindowHandler(RMac* p):mac_(p){}
+  
+ void ACKWindowHandler::handle(Event*e)
+ {
+   mac_->ProcessListen();
+ }
+ 
+ 
+ 
+ //CarrierSenseHandler::CarrierSenseHandler(RMac* p):mac_(p){}
+  
+ void CarrierSenseHandler::handle(Event*e)
+ {
+   mac_->ProcessCarrier();
+ }
+ 
+ 
+ //TransmissionHandler::TransmissionHandler(RMac* p):mac_(p), receiver(0){}
+  
+ void TransmissionHandler::handle(Event*e)
+ {
+   
+   mac_->TxData(receiver);
+ }
+ 
+ 
+ 
+ //NDStatusHandler::NDStatusHandler(RMac* p):mac_(p),status_(SLEEP){}
+ void NDStatusHandler::handle(Event* e)
+ {
+   if(status_!=SLEEP) mac_->StatusProcess(e,status_);
+   else mac_->Poweroff();
+ }
+ 
+ 
+ void NDStatusHandler::SetStatus(TransmissionStatus  status)
+ {
+   status_=status;
+ }
+ 
+ 
+ 
+ 
+ //ShortNDHandler::ShortNDHandler(RMac* p):mac_(p){}
+ 
+ void ShortNDHandler::handle(Event* e)
+ {  
+   
+     mac_->cycle_start_time=NOW;
+     mac_->SendND(mac_->short_packet_size_);
+ }
+ 
+ 
+ 
+ //ShortAckNDWindowHandler::ShortAckNDWindowHandler(RMac* p):mac_(p){}
+ 
+ void ShortAckNDWindowHandler::handle(Event* e)
+ { 
+    mac_->SendShortAckND();
+ }
+ 
+ 
+ //ACKNDHandler::ACKNDHandler(RMac* p):mac_(p){}
+ 
+ void ACKNDHandler::handle(Event* e)
+ { 
+     mac_->TxND((Packet*) e, mac_->ACKND_window_);
+ }
+ 
+ 
+ 
+ 
+ //PhaseOneHandler::PhaseOneHandler(RMac* p):mac_(p){}
+ 
+ void PhaseOneHandler::handle(Event* e)
+ { 
+     mac_->InitPhaseOne(mac_->ND_window_,mac_->ACKND_window_, mac_->PhaseOne_window_);
+ }
+ 
+ 
+ 
+ //PhaseTwoHandler::PhaseTwoHandler(RMac* p):mac_(p){}
+ 
+ void PhaseTwoHandler::handle(Event* e)
+ { 
+     mac_->StartPhaseTwo();
+ }
+ 
+ //PhaseThreeHandler::PhaseThreeHandler(RMac* p):mac_(p){}
+ 
+ void PhaseThreeHandler::handle(Event* e)
+ { 
+     mac_->InitPhaseThree();
+ }
+ 
+ /* ======================================================================
+     RMAC for  underwater sensor
+    ====================================================================== */
+ static class RMacClass : public TclClass {
+ public:
+  RMacClass():TclClass("Mac/UnderwaterMac/RMac") {}
+    TclObject* create(int, const char*const*) {
+ 	  return (new RMac());
+    }
+ } class_rmac;
+ 
+ 
+ RMac::RMac() :UnderwaterMac(),backoff_handler(this),
+   short_nd_handler(this),short_acknd_window_handler(this),
+   status_handler(this), phaseone_handler(this),acknd_handler(this), 
+   phasetwo_handler(this), phasethree_handler(this), sleep_handler(this), 
+   wakeup_handler(this), reserve_handler(this), ackrev_handler(this),
+   mac_recv_handler(this),timeout_handler(this),transmission_handler(this),
+   ackdata_handler(this),clear_channel_handler(this),ackwindow_handler(this),
+   carrier_sense_handler(this),syn_handler(this)
+ {
+   num_send=0;
+   num_data=0;
+   num_block=0;
+ 
+   large_packet_size_=30;
+   short_packet_size_=10;
+   Timer=5;
+  
+   short_latency_table_index=0;
+ 
+   reserved_time_table_index=0;
+   reservation_table_index=0;
+   ackdata_table_index=0;
+ 
+   period_table_index=0;
+ 
+   next_period=0;  
+   ack_rev_pt=NULL;
+ 
+ 
+ 
+   recv_busy=false;
+   carrier_sense=false;
+   collect_rev=false;
+     
+  for(int i=0;i<TABLE_SIZE;i++){
+   
+    next_available_table[i].node_addr=-1;
+    next_available_table[i].required_time=0;
+ 
+     short_latency_table[i].node_addr=-1;
+     short_latency_table[i].num=0;
+     short_latency_table[i].last_update_time=0.0;
+ 
+     period_table[i].node_addr=-1;
+     period_table[i].difference=0.0;
+     period_table[i].last_update_time=0.0; 
+   }
+ 
+     arrival_table_index=0; 
+   for(int i=0;i<TABLE_SIZE;i++)
+     arrival_table[i].node_addr=-1;
+ 
+ 
+ 
+  
+   bind("PhaseOne_window_",&PhaseOne_window_);
+   bind("PhaseTwo_window_",&PhaseTwo_window_);
+   bind("PhaseTwo_interval_",&PhaseTwo_interval_);
+   bind("duration_",&duration_);
+   bind("ND_window_",&ND_window_); 
+   bind("ACKND_window_",&ACKND_window_); 
+   bind("PhyOverhead_",&PhyOverhead_);
+   bind("large_packet_size_",&large_packet_size_);
+   bind("short_packet_size_",&short_packet_size_);
+   bind("PhaseOne_cycle_",&PhaseOne_cycle_);
+   bind("PhaseTwo_cycle_",&PhaseTwo_cycle_);
+   bind("IntervalPhase2Phase3_",&IntervalPhase2Phase3_);
+   bind("PeriodInterval_",&PeriodInterval_);
+   bind("transmission_time_error_",&transmission_time_error_);
+   bind("SIF_",&SIF_);
+   bind("ACKRevInterval_",&ACKRevInterval_);
+ 
+ 
+    theta=transmission_time_error_/10.0;
+    max_short_packet_transmissiontime=((1.0*short_packet_size_*encoding_efficiency_
+                       +PhyOverhead_)/bit_rate_)*(1+transmission_time_error_);
+    max_large_packet_transmissiontime=((1.0*large_packet_size_*encoding_efficiency_
+                       +PhyOverhead_)/bit_rate_)*(1+transmission_time_error_);
+   
+   InitPhaseOne(ND_window_,ACKND_window_, PhaseOne_window_);
+   
+ }
+ 
+ void 
+ RMac::InitPhaseOne(double t1,double t2, double t3)
+ {
+   
+    printf("RMac: Phaseone cycle: %d...\n",PhaseOne_cycle_);
+ 
+    if(PhaseOne_cycle_)
+     { 
+       PhaseStatus=PHASEONE;
+     Scheduler& s=Scheduler::instance();
+     InitND(t1,t2,t3);
+     s.schedule(&phaseone_handler,&phaseone_event,t3);
+     PhaseOne_cycle_--;
+     return;
+     }
+   
+    // PrintTable();
+    InitPhaseTwo();
+    return;
+ }
+ 
+ 
+ 
+ 
+ void 
+ RMac::TxACKRev(Packet* pkt){
+ 
+   printf("rmac Txackrev: node %d at time %f\n",index_,NOW);     
+   DeleteBufferCell(pkt);
+    
+   hdr_cmn* cmh=HDR_CMN(pkt);
+   hdr_rmac* ackh = HDR_RMAC(pkt); 
+ 
+   printf("rmacTxackrev: node %d is transmitting a packet st=%f at time %f\n",index_,ackh->st,NOW);     
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  
+   hdr_cmn::access(pkt)->txtime()=(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+   printf("rmacTxackrev: node %d is transmitting a packet st=%f tx=%f at time %f\n",
+           index_,ackh->st,txtime,NOW);   
+ 
+   if(SLEEP==n->TransmissionStatus()) {
+   Poweron();
+   n->SetTransmissionStatus(SEND); 
+   cmh->ts_=NOW;
+ 
+   sendDown(pkt);
+   // check if the sending this ACKRev collides with my own ackrev windows
+   if(IsACKREVWindowCovered(NOW)) {
+       printf("rmacTxackrev: node %d converged with ACKwindow\n",index_);   
+      InsertReservedTimeTable(index_,PeriodInterval_,4*PeriodInterval_);
+   }
+   status_handler.SetStatus(SLEEP);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==n->TransmissionStatus()){
+   
+     n->SetTransmissionStatus(SEND);
+      cmh->ts_=NOW;
+      sendDown(pkt);
+   //  printf("broadcast %d Tx Idle set timer at %f tx is %f\n",node_->nodeid(),NOW,txtime);
+ 
+   // check if the sending this ACKRev collides with my own ackrev windows
+   if(IsACKREVWindowCovered(NOW)) {
+   printf("rmacTxackrev: node %d converged with ACKwindow\n",index_);  
+   InsertReservedTimeTable(index_,PeriodInterval_,4*PeriodInterval_);
+   }
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==n->TransmissionStatus())
+     {
+       
+       InterruptRecv(txtime);
+       cmh->ts_=NOW;
+       sendDown(pkt);
+ 
+       if(IsACKREVWindowCovered(NOW)){
+   printf("rmacTxackrev: node %d converged with ACKwindow\n",index_);  
+        InsertReservedTimeTable(index_,PeriodInterval_,4*PeriodInterval_);
+       }
+       status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);
+      return;
+     }
+ 
+ 
+ if (SEND==n->TransmissionStatus())
+   {
+     printf("rmac: queue send data too fast\n");
+     Packet::free(pkt);
+       return;
+   }
+ }
+ 
+ 
+ 
+ bool 
+ RMac::IsACKREVWindowCovered(double current_time)
+ {
+   if((current_time-cycle_start_time==PeriodInterval_) 
+      ||(current_time-cycle_start_time==0)) return true;
+   else return false;
+ }
+ 
+ void 
+ RMac:: InsertReservedTimeTable(int sender_addr, double start_time, double dt)
+ {
+  printf("rmac:InsertReservedTimeTable: node %d inserts  the reserved_time_table at %f\n",index_,NOW);
+  if(reserved_time_table_index>=TABLE_SIZE){
+   printf("rmac:InsertReservedTimeTable: the reserved_time_table is full\n");
+         return;
+  }
+   int index=-1;
+   for(int i=0;i<reserved_time_table_index;i++){
+     if(reserved_time_table[i].node_addr==sender_addr) index=i;
+   }
+   if(index==-1)
+     {
+  reserved_time_table[reserved_time_table_index].node_addr=sender_addr;
+       reserved_time_table[reserved_time_table_index].start_time=start_time;
+       reserved_time_table[reserved_time_table_index].duration=dt;
+       reserved_time_table_index++;
+     }
+   else 
+ {
+       reserved_time_table[index].node_addr=sender_addr;
+       reserved_time_table[index].start_time=start_time;
+       reserved_time_table[index].duration=dt;
+ }
+ }
+ 
+ 
+ void 
+ RMac::DeleteBufferCell(Packet* p)
+ {
+  printf("Rmac: node %d ack_rev link\n",index_);
+   buffer_cell* t1;
+   buffer_cell* t2;
+   t1=ack_rev_pt;
+  
+   if(!t1){
+   printf("Rmac: there is no ack_rev link\n");
+   return;
+   }
+ 
+  
+   if(t1->next) t2=t1->next; 
+ 
+ 
+   if(t1->packet==p) {
+            ack_rev_pt=ack_rev_pt->next;
+            delete t1;
+            return;
+   }
+ 
+   /*
+   if(t2){
+ 
+     Packet* t=t2->packet;
+     hdr_ack_rev*  th=HDR_ACK_REV(t);
+    printf("Rmac:node %d  !!!!sender_addr=%d\n", index_, th->sender_addr); 
+   }
+   */
+ 
+   while(t2){
+     if(p==t2->packet) {
+ 
+       t1->next=t2->next;
+       delete t2;
+       return;
+     }
+     t1=t2;
+     t2=t2->next;
+   }
+ 
+   return;
+ }
+ 
+ 
+ /*
+ 
+ void 
+ RMac::InitPhaseThree(){
+ 
+  
+   printf("RMac: this is InitPhaseThree\n"); 
+ 
+    SortPeriodTable();
+    PrintTable();
+ 
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   if(n->TransmissionStatus()==SLEEP) Poweron();
+   
+   mac_status=RMAC_IDLE;
+   Scheduler &s=Scheduler::instance();
+    s.schedule(&sleep_handler,&sleep_event,duration_);
+     return;
+ }
+ */
+ 
+ 
+ void 
+ RMac::InitPhaseThree()
+ {
+   printf("RMac: this is InitPhaseThree...\n"); 
+ 
+    SortPeriodTable(period_table);
+    PrintTable();
+ 
+    mac_status=RMAC_IDLE;
+    Wakeup();
+     return;
+ }
+ 
+ 
+ void 
+ RMac::PrintTable(){
+ 
+  
+   printf("RMac: the short latency table in node%d...\n",index_); 
+ 
+   for (int i=0;i<TABLE_SIZE;i++)
+ {
+   printf("node addr is%d and short latency is%f\n",
+         short_latency_table[i].node_addr,short_latency_table[i].latency);
+ }
+ 
+ 
+ printf("RMac: the period table in node%d...\n",index_); 
+ 
+   for (int i=0;i<TABLE_SIZE;i++)
+ {
+   printf("node addr is%d and difference is%f\n",period_table[i].node_addr,period_table[i].difference);
+ }
+ 
+ }
+ 
+ 
+ /*
+ void 
+ RMac::SortPeriodTable()
+ {
+   printf("RMac:SortPeriodTable;node %d sort period table \n",index_);
+   bool unswapped=false;
+   int i=0;
+   int j=0;
+ 
+   while ((!unswapped)&&(i<period_table_index-1))
+     {
+       j=0;
+       unswapped=true;
+       while (j<period_table_index-1-i)
+ 	{
+        if(period_table[j].difference>period_table[j+1].difference)
+ 	{
+ 	  // printf("sortperiodtable;node %d swictch two values %f and %f \n",
+ 	  // index_,period_table[j].difference, period_table[j+1].difference);
+ 	  double dt=period_table[j].difference;
+           int addr=period_table[i].node_addr;
+           double du=period_table[i].duration;
+           double lut=period_table[i].last_update_time;
+ 
+           period_table[j].difference=period_table[j+1].difference;
+           period_table[j].node_addr=period_table[j+1].node_addr;
+           period_table[j].duration=period_table[j+1].duration;
+           period_table[j].last_update_time=period_table[j+1].last_update_time;       
+           
+ 	  period_table[j+1].difference=dt;
+           period_table[j+1].node_addr=addr;
+           period_table[j+1].duration=du;
+           period_table[j+1].last_update_time=lut;
+           unswapped=false;
+ 	}
+        j++;
+ 	}
+       i++;
+     }
+ }
+ 
+ */
+ 
+ 
+ 
+ 
+ 
+ 
+ // use bubble algorithm to sort the period table
+ 
+ void 
+ RMac::SortPeriodTable(struct period_record * table)
+ {
+   printf("RMac:SortPeriodTable;node %d sort period table \n",index_);
+   bool unswapped=false;
+   int i=0;
+   int j=0;
+ 
+   while ((!unswapped)&&(i<period_table_index-1))
+     {
+       j=0;
+       unswapped=true;
+       while (j<period_table_index-1-i)
+ 	{
+        if(table[j].difference>table[j+1].difference)
+ 	{
+ 	  // printf("sortperiodtable;node %d swictch two values %f and %f \n",
+ 	  // index_,period_table[j].difference, period_table[j+1].difference);
+ 	  double dt=table[j].difference;
+           int addr=table[j].node_addr;
+           double du=table[j].duration;
+           double lut=table[j].last_update_time;
+ 
+           table[j].difference=table[j+1].difference;
+           table[j].node_addr=table[j+1].node_addr;
+           table[j].duration=table[j+1].duration;
+           table[j].last_update_time=table[j+1].last_update_time;       
+           
+ 	  table[j+1].difference=dt;
+           table[j+1].node_addr=addr;
+           table[j+1].duration=du;
+           table[j+1].last_update_time=lut;
+           unswapped=false;
+ 	}
+        j++;
+ 	}
+       i++;
+     }
+ }
+ 
+ 
+ void 
+ RMac::ProcessSleep(){
+    printf("RMac: node %d  is ProcessSleep at %f and wake up afte %f -%f\n", 
+             index_,NOW,PeriodInterval_,duration_); 
+ 
+    if(mac_status==RMAC_RECV) return; 
+ 
+    Poweroff(); //? Is it safe to poweroff 
+ 
+    if((mac_status==RMAC_IDLE)&&(reservation_table_index!=0))
+    {
+      if(!collect_rev) collect_rev=true;
+       else{
+      printf("RMac: node %d process_sleep reservation table is not empty %d\n",index_, reservation_table_index); 
+      // mac_status=RMAC_ACKREV;
+      ArrangeReservation();
+       }
+    }
+    return;
+ }
+ 
+ 
+ void 
+ RMac::InsertBackoff()
+ {
+   // int indx=-1;
+   double elapsed_time=NOW-cycle_start_time;
+   double start_time=elapsed_time+PeriodInterval_; 
+   // adding PeriodInterval_ just to make sure that subsequent process correct
+   double dt=4*PeriodInterval_;
+   InsertReservedTimeTable(index_,start_time,dt);
+ }
+ 
+ void 
+ RMac:: CancelREVtimeout(){ 
+   printf("rmac:CancelREVtimeout node %d \n",index_);
+    Scheduler& s=Scheduler::instance();
+    s.cancel(&timeout_event);      
+     return;
+ }
+ 
+ 
+ void 
+ RMac:: ClearChannel(){ 
+   printf("rmac:ClearChannel node %d at %f!!!!!!!!\n",index_,NOW);
+   if(NewData()){
+     if(mac_status==RMAC_FORBIDDED)
+      {// avoid overlap
+      MakeReservation();
+      mac_status=RMAC_REV;
+      }
+   }
+   else mac_status=RMAC_IDLE;
+     return;
+ }
+ 
+ 
+ void 
+ RMac:: CancelReservation(){
+    printf("rmac:cancelReservation: node %d\n",index_);
+  
+     for (int i=0;i<TABLE_SIZE;i++){
+       reservation_table[i].node_addr=-1;
+        } 
+     return;
+    
+ }
+ 
+ 
+ void 
+ RMac::StartRECV(double dt, int id, int data_sender)
+  {
+    printf("rmac:StartRECV: node %d at %f \n",index_,NOW);
+   if(id==0) 
+     {
+       //   data_sender=-12;
+      
+    /*
+    for (int i=0;i<MAXIMUM_BUFFER;i++) bit_map[i]=0;
+    printf("rmac:StartRECV: node %d at %f to power on\n",index_,NOW);
+    */
+ 
+    Poweron();
+    recv_busy=false;
+   
+ 
+    mac_status=RMAC_RECV;
+    mac_recv_handler.status=1;
+   
+    double t=2*max_large_packet_transmissiontime;
+   
+    Scheduler& s=Scheduler::instance();
+    s.schedule(&timeout_handler, &timeout_event,t);  
+    s.schedule(&mac_recv_handler, &mac_recv_event,dt);  
+     }
+   else {
+     // modification for the version02-10-2006 here, the RECV status ends when 
+     // the receiver receives the data packets.
+     // mac_status=RMAC_IDLE;
+  printf("rmac:StartRECV: node %d at %f to power off\n",index_,NOW);
+  ScheduleACKData(data_sender);
+      Poweroff();
+   }
+ 	 return;
+  }
+ 
+ 
+ void 
+ RMac::ArrangeReservation()
+ {
+     printf("rmac:ArrangeReservation: node %d at %f...\n",index_,NOW);
+        int sender_index=-1;
+        if(ProcessRetransmission())
+ 	 {
+         printf("Rmac:Arrangereservation: node %d handle retransmission this time!!\n",index_); 
+        return;
+          }
+ 
+         sender_index=SelectReservation();  
+        if(sender_index==-1){
+ 	 printf("Rmac:Arrangereservation: no reservation selected!!\n");
+ 	 return;
+        }
+        else{
+           
+           mac_status=RMAC_ACKREV;
+ 
+          int sender=reservation_table[sender_index].node_addr;
+          double dt=reservation_table[sender_index].required_time;   
+          double offset=reservation_table[sender_index].interval;
+ 
+           printf("Rmac:Arrangereservation: sender %d and dutation %f is scheduled\n",
+                  sender,dt);         
+           ScheduleACKREV(sender,dt,offset);
+        }
+ }
+ 
+ 
+ //the receiver is the address of the data sender
+ 
+ void 
+ RMac::ScheduleACKREV(int receiver, double duration, double offset)
+ {
+   printf("rmac:ScheduleACKREV: node %d\n",index_);
+   int i=0;
+   //  double Number_Period=0;
+   double last_time=0.0;
+   double upper_bound=0;
+   double elapsed_time=NOW-cycle_start_time;
+  
+    int     receiver_addr=receiver;
+    double  dt=CheckDifference(period_table,receiver);
+    double  latency=CheckLatency(short_latency_table,receiver_addr)
+                      -max_short_packet_transmissiontime;
+ 
+ 
+ 
+     printf("rmac:scheduleACKRev: node %d is scheduling ackrev, duration=%f, interval=%f\n",
+              index_,duration, offset);
+     while ((period_table[i].node_addr!=-1)&&(i<TABLE_SIZE))
+       {
+         if (period_table[i].node_addr!=receiver)
+ 	  { 
+ 	    int nid=period_table[i].node_addr;
+             double d1=CheckDifference(period_table,nid);
+             double l1=CheckLatency(short_latency_table,nid)-max_short_packet_transmissiontime;       
+ 	    double t1=CalculateACKRevTime(d1,l1,elapsed_time); 
+ 
+            
+ 	    Packet* ackrev=GenerateACKRev(nid,receiver,duration);
+              
+             InsertACKRevLink(ackrev,&t1); 
+       
+             Scheduler& s=Scheduler::instance();
+             s.schedule(&ackrev_handler, (Event*) ackrev,t1);
+   printf("rmac:scheduleACKRev: node %d and node %d t1=%f the current  time is %f\n",
+                   index_,nid,t1,NOW);
+ 	    //   if (Number_Period<1) Number_Period=1;
+        if(t1+2*l1>last_time) last_time=t1+2*l1;
+        if(t1+l1>upper_bound) upper_bound=t1+l1;
+ 	  }
+ 	i++;
+ 
+     } // end of all the neighbors
+ 
+ 
+     //      double l=offset;
+ 
+       // int receiver_addr=receiver;
+       // double dt=CheckDifference(period_table,receiver);
+ 
+       //  double latency=CheckLatency(short_latency_table,receiver_addr)
+       //          -max_short_packet_transmissiontime;
+       double t1=CalculateACKRevTime(dt,latency,elapsed_time);
+      
+        while(t1<upper_bound) t1+=PeriodInterval_;
+        double t3=t1+2*latency+max_short_packet_transmissiontime;
+ 
+         
+         Packet* ackrevpacket=GenerateACKRev(receiver,receiver,duration);
+         InsertACKRevLink(ackrevpacket,&t1);   
+ 
+         Scheduler& s=Scheduler::instance();
+         s.schedule(&ackrev_handler, (Event*) ackrevpacket,t1);  
+    printf("rmac:scheduleACKRev: node %d and node %d t1=%f t3=%f latency=%f the current time is %f\n",
+                 index_, receiver,t1,t3,latency,NOW); 
+         // decide the start time of reservation duration
+ 
+         if(t3<last_time)t3=last_time;
+  
+         double st=dt+offset-elapsed_time+latency;
+         while(t3>st) st+=PeriodInterval_;  // start time of reserved duration
+ 
+ 	double end_time=st+duration;  // end time of reserved duration
+          
+ 
+ 
+ 	/* 
+              this is modified from the version 02-10-2006 
+ 	 */
+ 	double available_period=PeriodInterval_+dt-elapsed_time;
+         double end_period=PeriodInterval_-elapsed_time;
+ 
+         // the earliest time period that is available for new request 
+ 	while(available_period<(end_time+latency))available_period+=PeriodInterval_;
+      
+ 
+         available_period=available_period+
+                         duration_-latency-max_short_packet_transmissiontime;
+           
+         while (end_period<available_period) end_period+=PeriodInterval_;
+ 
+ 	// SetStartTime(ack_rev_pt,st,available_period);
+         
+         SetStartTime(ack_rev_pt,st,end_period);
+ 	
+ 
+ 	// SetStartTime(ack_rev_pt,st,end_time);
+  printf("rmac:scheduleACKRev: node %d offset time %f  and set the end time  is %f  at %f\n", 
+                 index_,st,end_period,NOW);
+         mac_recv_handler.status=0;
+ 
+ 	// 2 times max_large_packet_transmissiontime is enough for ackdata
+ 	// mac_recv_handler.duration=(duration+2*max_large_packet_transmissiontime);
+    
+ 	// this is time for ackdata
+         mac_recv_handler.duration=duration;
+         mac_recv_handler.data_sender=receiver;
+         s.schedule(&mac_recv_handler, &mac_recv_event,st);  
+ }
+ 
+ 
+ 
+ // this function first check if the arranged slot collides with 
+ // the slot for the intended receiver if so, adjust its sending 
+  //time to avoid interference the intended receiver, however, 
+ //  interfere with the receiver.
+ 
+ double 
+ RMac::CalculateACKRevTime(double diff1, double l1,double diff2,double l2)
+ {
+ 
+   bool collision_status=false;
+   double elapsed_time=NOW-cycle_start_time;
+   double s1=diff1-l1;
+   while (s1<0) s1+=PeriodInterval_;
+   double s2=diff2-l2;
+   while (s2<0) s2+=PeriodInterval_;
+ 
+    
+   double delta=s1-s2;
+   if(((s1<=s2)&&(s2<=s1+max_short_packet_transmissiontime))
+      || ((s2<=s1)&&(s1<=s2+max_short_packet_transmissiontime))) 
+     collision_status=true;
+  
+ 
+   
+   if(collision_status) 
+   {
+    printf("calculateACKRev: collision!! delat=%f\n",delta);
+    delta=s1-s2;
+   }
+   else delta=0;
+  double offset_time=diff2+delta;  
+  while (elapsed_time+l2>offset_time)offset_time+=PeriodInterval_;
+  return offset_time-l2-elapsed_time;
+ 
+ }
+ 
+ 
+ double 
+ RMac::CalculateACKRevTime(double diff,double latency, double elapsed_time)
+ {
+ 
+  double offset_time=diff;
+  while (elapsed_time+latency>offset_time)offset_time+=PeriodInterval_;
+  return offset_time-latency-elapsed_time;
+ 			 
+ }
+ 
+ 
+ 
+ Packet* 
+ RMac::GenerateACKRev(int receiver, int intended_receiver, double duration){
+ 
+   printf("rmac:GenerateACKREV: node %d\n",index_);
+       Packet* pkt =Packet::alloc();
+       hdr_rmac* ackrevh = HDR_RMAC(pkt);
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+  
+ 
+        cmh->next_hop()=receiver;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_RMAC;
+        cmh->size()=short_packet_size_;      
+ 
+       ackrevh->ptype=P_ACKREV; 
+       ackrevh->pk_num = num_send;
+       ackrevh->receiver_addr=intended_receiver;
+       ackrevh->duration=duration;
+       ackrevh->sender_addr=index_;
+ 
+       num_send++;
+       return pkt;
+ }
+ 
+ 
+ // In old version of this program, the silence duration is not  changed 
+ // however, in new version of this program, the silence duration is also changed
+ 
+ void 
+ RMac::SetStartTime(buffer_cell* ack_rev_pt, double st, double next_period){
+  printf("rmac setstarttime: node %d \n",index_);
+   buffer_cell* t1;
+   t1=ack_rev_pt;
+   while(t1){
+     hdr_rmac*  ackrevh=HDR_RMAC(t1->packet);
+     double d=t1->delay;
+     ackrevh->st=st-d;
+     ackrevh->interval=next_period-d;
+     ackrevh->duration=next_period-d;
+      printf("rmac Setstarttime: node %d: offset time is: %f and next period is %f\n",
+          index_,ackrevh->st,ackrevh->interval);
+     t1=t1->next;
+   }
+ }
+ 
+ 
+ /* // old version of SetStartTime
+ void 
+ RMac::SetStartTime(buffer_cell* ack_rev_pt, double st, double next_period){
+  printf("rmac setstarttime: node %d \n",index_);
+   buffer_cell* t1;
+   t1=ack_rev_pt;
+   while(t1){
+     hdr_rmac*  ackrevh=HDR_RMAC(t1->packet);
+     double d=t1->delay;
+     ackrevh->st=st-d;
+     ackrevh->interval=next_period-d;
+  printf("rmac setstarttime: node %d interval to recv =%f and next period is %f\n",index_,ackrevh->st,ackrevh->interval);
+     t1=t1->next;
+   }
+ }
+ 
+ */
+ 
+ 
+ 
+ void 
+ RMac::InsertACKRevLink(Packet* p, double d){
+    printf("rmac:InsertACKREVLink: node %d\n",index_);
+   buffer_cell* t1=new buffer_cell;
+   t1->packet=p;
+   t1->delay=d;
+   t1->next=NULL;  
+ 
+   if(ack_rev_pt==NULL){
+     ack_rev_pt=t1;  
+     printf("node %d ackrev link is empty\n", index_);
+     return;
+   }
+   else 
+     {
+       buffer_cell* t2=ack_rev_pt;
+       ack_rev_pt=t1;
+       t1->next=t2;
+       printf("node %d ackrev link is not empty\n", index_);
+     
+   return;
+     }
+ }
+ 
+ 
+ 
+ 
+ void 
+ RMac::InsertACKRevLink(Packet* p, double* d){
+   double s1=*d;
+   double win=max_short_packet_transmissiontime;
+ 
+    printf("rmac:InsertACKREVLink: node %d\n",index_);
+   buffer_cell* t1=new buffer_cell;
+   t1->packet=p;
+   t1->delay=s1;
+   t1->next=NULL;  
+ 
+   if(ack_rev_pt==NULL){
+     ack_rev_pt=t1;  
+     printf("node %d ackrev link is empty\n", index_);
+     return;
+   }
+   else 
+     {
+       buffer_cell* t2=ack_rev_pt;
+       buffer_cell* tmp;
+       printf("node %d ackrev link is not empty\n", index_);
+ 
+       while(t2)
+ 	{
+ 	  tmp=t2;
+ 	  double s2=t2->delay;
+ 	  if(((s1<=s2)&&(s2<=s1+win))|| ((s2<=s1)&&(s1<=s2+win))) 
+           {
+ 	 printf("InsertACKrev:node %d finds collisions!\n",index_);
+ 	 s1+=PeriodInterval_;
+ 	  }
+        t2=t2->next;
+ 	}
+ 
+       t1->delay=s1;
+       tmp->next=t1;
+       *d=s1;
+   return;
+     }
+       
+ }
+ 
+ 
+ 
+ void 
+ RMac::ResetReservationTable()
+ {
+    printf("rmac:ReserReservation: node %d\n",index_);
+   for(int i=0;i<TABLE_SIZE;i++){
+     reservation_table[i].node_addr=-1;
+     reservation_table[i].required_time=0.0;
+   }
+ }
+ 
+ 
+ 
+ // returned true if there exist retransmission request, false otherwise
+ bool 
+ RMac::ProcessRetransmission()
+ {
+   bool status=false;
+   int i=0;
+   while (i<reservation_table_index)
+     {
+     if(IsRetransmission(i)) 
+        {
+ 	 status=true;
+       ScheduleACKData(reservation_table[i].node_addr);
+       ClearReservationTable(i); // delete the record from table
+       i--;
+        }
+   i++;
+     }
+   return status;
+ }
+ 
+ void 
+ RMac::ClearReservationTable(int index)
+ {
+   for(int i=index;i<reservation_table_index-1;i++)
+     {
+     reservation_table[i].node_addr=reservation_table[i+1].node_addr;
+     reservation_table[i].block_id=reservation_table[i+1].block_id;
+     reservation_table[i].required_time=reservation_table[i+1].required_time;   
+     reservation_table[i].interval=reservation_table[i+1].interval;          
+     }
+   reservation_table_index--;
+ }
+ 
+ 
+ bool 
+ RMac::IsRetransmission(int reservation_index)
+ {
+   int block=reservation_table[reservation_index].block_id;
+   int node_id=reservation_table[reservation_index].node_addr;
+ 
+   for(int i=0;i<ackdata_table_index;i++)
+     if((ackdata_table[i].node_addr==node_id)
+        &&(ackdata_table[i].block_num==block))
+       {
+ 	printf("RMac: IsRetransmission: node %d received a retx from %d\n",index_,node_id); 
+       return true;
+       }
+   return false;
+ }
+ 
+ 
+ 
+ int 
+ RMac::SelectReservation(){
+ 
+   /* this one favor the long queue
+   printf("rmac:selectReservation: node %d\n",index_);
+   int index=-1;
+   double dt=-1.0;
+   int i=0;
+ 
+   while(!(reservation_table[i].node_addr==-1))
+    {
+      printf("rmac:select reservation: node %d, request id is%d \n",index_,reservation_table[i].node_addr);
+     if (reservation_table[i].required_time>dt) index=i;
+     i++;
+    }
+   
+   return index;
+ 
+   */
+ 
+   if(0==reservation_table_index) return -1; // no new reservation request
+   // if(skip){
+   // if(rand()%2==0) return -1;
+     // } 
+   //  if(rand()%2==0) return -1;
+   int i=0;
+   while(!(reservation_table[i].node_addr==-1))
+    {
+      printf("rmac:select reservation: node %d, request id is%d  i=%d\n",index_,reservation_table[i].node_addr,i);
+    
+     i++;
+    }
+   //  printf("rmac:select reservation  node %d i=%d\n",index_,i);
+   return rand()%i;
+  
+ }
+ 
+ 
+ void 
+ RMac::ResetMacStatus(){
+   printf("node %d timeout at %f!\n\n",index_,NOW);
+ 
+   if((mac_status==RMAC_WAIT_ACKREV)||(mac_status==RMAC_FORBIDDED)) {
+     txbuffer.UnlockBuffer();
+     //ResumeTxProcess();
+     printf("ResetMacStatus: node %d unlock txbuffer\n",index_); 
+   }
+ 
+   if(mac_status==RMAC_RECV){
+   printf("ResetMacStatus: node %d don't receive the data packet at %f\n",index_,NOW);
+   Scheduler & s=Scheduler::instance();
+   s.cancel(&mac_recv_event);
+   Poweroff();  
+   }
+  mac_status=RMAC_IDLE;
+ }
+ 
+ 
+ void 
+ RMac::Wakeup(){
+ 
+   printf("\n. ..WakeUp node %d wake up at %f  and the number of packet is %d...\n\n",
+            index_,NOW,txbuffer.num_of_packet);
+ 
+   // reset the carrier sense
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+  
+   n->ResetCarrierSense(); 
+   carrier_sense=false;
+ 
+   /*
+   if(n->CarrierSense()){
+     printf("Rmac: node %d sense the busy channel at %f\n",index_,NOW); 
+    carrier_sense=true;
+   }
+   else {
+      carrier_sense=false;
+      n->ResetCarrierId(); 
+   }
+   */
+   //skip=!skip;
+ 
+   Poweron();
+   cycle_start_time=NOW;
+  
+ 
+   /*
+   for(int i=0;i<TABLE_SIZE;i++){
+     reservation_table[i].node_addr=-1;
+   }
+  
+   reservation_table_index=0;
+   */
+ 
+    // one ack windows:rev
+    double ACKwindow=max_short_packet_transmissiontime; 
+ 
+    printf("\n. ..WakeUp node %d schedule sleep after %f at%f...\n\n",index_,duration_,NOW);
+    Scheduler &s=Scheduler::instance();
+    s.schedule(&sleep_handler,&sleep_event,duration_);
+    s.schedule(&wakeup_handler,&wakeup_event,PeriodInterval_);
+   
+    // s.schedule(&carrier_sense_handler,&carrier_sense_event,ACKwindow);
+    s.schedule(&ackwindow_handler,&ackwindow_event,1.5*ACKwindow);
+    return;
+ }
+ 
+ void 
+ RMac::ResetReservation()
+ {
+ 
+  for(int i=0;i<TABLE_SIZE;i++){
+     reservation_table[i].node_addr=-1;
+   }
+  
+   reservation_table_index=0;
+   return;
+ }
+ 
+ 
+ 
+ 
+ void 
+ RMac::ProcessCarrier()
+ { 
+   printf("RMac:node %d processes carrier sense at %f...\n",index_,NOW);
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   if(n->CarrierId())
+ {
+   printf("RMac:node %d senses carrier!!\n",index_);
+  carrier_sense=true;
+ }
+    else carrier_sense=false;
+   n->ResetCarrierId();
+ }
+ 
+ 
+ void 
+ RMac::ProcessListen()
+ {
+   printf("RMac:node %d processes listen  at %f...\n",index_,NOW); 
+   if(carrier_sense){
+   printf("RMac:node %d senses carriers  at %f...\n",index_,NOW); 
+   // InsertBackoff();
+    carrier_sense=false;
+   }
+   ProcessReservedTimeTable();
+   
+   switch (mac_status){
+   case RMAC_IDLE: 
+               
+                  if (NewData()&&(!collect_rev)){ 
+    printf("WakeUp: There is new data in node %d and the number of packet is %d\n", 
+                    index_,txbuffer.num_of_packet);
+ 	           mac_status=RMAC_REV;
+                    MakeReservation();
+                         }
+                  break;
+   case RMAC_FORBIDDED:
+    printf("WakeUp NODE %d is in state RMAC_FORBIDDED\n",index_);
+       CancelReservation();
+       CancelREVtimeout();
+       ClearACKRevLink();
+       collect_rev=false;
+     break;
+   case RMAC_WAIT_ACKREV:  
+      collect_rev=false;
+     printf("WakeUp NODE %d is in state RMAC_WAIT_ACKREV\n",index_);
+     break;
+   case RMAC_RECV:  
+      collect_rev=false;
+     printf("WakeUp NODE %d is in state RMAC_RECV\n",index_);
+     break;
+  case RMAC_TRANSMISSION:  
+      collect_rev=false;
+     printf("WakeUp NODE %d is in state RMAC_TRANSMISSION\n",index_);
+     break;
+  case RMAC_REV:  
+      collect_rev=false;
+     printf("WakeUp NODE %d is in state RMAC_REV\n",index_);
+     break;
+   case RMAC_ACKREV:  
+      collect_rev=false;
+     printf("WakeUp NODE %d is in state RMAC_ACKREV\n",index_);
+     break;
+    case RMAC_WAIT_ACKDATA: 
+      collect_rev=false; 
+     printf("WakeUp NODE %d is in state RMAC_WAIT_ACKDATA\n",index_);
+     break;
+   default: 
+    collect_rev=false;
+   printf("WakeUp node %d don't expect to be in this state\n",index_);
+     break;
+   
+   }
+ 
+   if(!collect_rev) ResetReservation();
+   return;
+ }
+ 
+ 
+ /*
+ void 
+ RMac::ProcessCarrier()
+ {
+   printf("RMac:node %d processes carrier sense at %f...\n",index_,NOW);
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   if(n->CarrierSense()) 
+      {
+       InsertBackoff();
+       n->ResetCarrierSense();
+      }
+ }
+ */
+ 
+ void 
+ RMac::ClearACKRevLink(){
+  printf("rmac clearACKREV: node %d\n",index_);
+   if(!ack_rev_pt) return;
+   buffer_cell* t1;
+   buffer_cell* t2;
+   Event * e1;
+    Scheduler &s=Scheduler::instance();
+  
+ 
+ 
+   // t1=ack_rev_pt->next;
+   t1=ack_rev_pt;
+   while (t1){
+     t2=t1->next;
+     e1=(Event*)t1->packet;
+     s.cancel(e1);
+     Packet::free(t1->packet);
+     delete t1;
+     t1=t2;
+     ack_rev_pt=t1;
+   }
+    
+ }
+ 
+ 
+ void 
+ RMac::ProcessReservedTimeTable(){
+    printf("rmac:ProcessReservedtimetable: node %d index=%d\n",index_, reserved_time_table_index);
+    int i=0;
+    //   double largest_duration=0;
+    double elapsed_time=NOW-cycle_start_time;
+ 
+   while(i<reserved_time_table_index){
+     // printf("rmac:ProcessReservedtimetable: node %d index=%d\n",index_, reserved_time_table_index);
+     double nst=reserved_time_table[i].start_time-PeriodInterval_-elapsed_time;
+     double lt=reserved_time_table[i].duration;
+     int addr=reserved_time_table[i].node_addr;
+     double  l=CheckLatency(short_latency_table,addr);
+     double t1=l-max_short_packet_transmissiontime;
+     nst=nst-t1;
+ 
+     if (nst<0) {
+       if((lt+nst)<=0) {
+         DeleteRecord(i);
+ 	i--;    
+       }
+       else 
+ 	{ // nst>=
+        mac_status=RMAC_FORBIDDED;
+  printf("RMac:ProcessReservedTimeTable: node %d sets reserved time  inetrval=%f and duration is%f\n",
+            index_,0.0,(lt+nst));
+        reserved_time_table[i].start_time=elapsed_time;
+        reserved_time_table[i].duration=lt+nst;
+ 	}
+     }// end of nst<0
+     else {
+       // nst>0
+       // if (nst<=PeriodInterval_) mac_status=RMAC_FORBIDDED;
+        mac_status=RMAC_FORBIDDED;
+        printf("RMac:ProcessReservedTimeTable: node %d sets reserved time  inetrval=%f and duration is%f\n",
+                 index_,nst,lt);
+        reserved_time_table[i].start_time=nst;
+        reserved_time_table[i].duration=lt;
+     }
+     i++;
+   }
+ 
+   if(mac_status==RMAC_FORBIDDED){
+     // Scheduler& s=Scheduler::instance();
+    // s.cancel(&clear_channel_event);
+   
+    // s.schedule(&clear_channel_handler,&clear_channel_event,largest_duration); //?? waht's this used for?
+   }
+ 
+ 
+   if((reserved_time_table_index==0)&&(mac_status==RMAC_FORBIDDED)) 
+           mac_status=RMAC_IDLE; 
+ }
+ 
+ 
+ void 
+ RMac::DeleteRecord(int index){
+  
+   for(int i=index;i<reserved_time_table_index;i++)
+     {
+       reserved_time_table[i].node_addr= reserved_time_table[i+1].node_addr;
+       reserved_time_table[i].start_time= reserved_time_table[i+1].start_time;
+       reserved_time_table[i].duration= reserved_time_table[i+1].duration;
+       reserved_time_table_index--;
+     }
+  printf("rmac:deleteRecord: node %d the reserved index=%d\n",index_, reserved_time_table_index);
+ }
+ 
+ 
+ 
+ 
+ bool 
+ RMac::NewData(){
+   return (!txbuffer.IsEmpty());//!! this is correct??think about it
+ }
+ 
+ 
+ void 
+ RMac::MakeReservation(){
+  
+  printf("rmac MakeReservation: node %d MakeReservation at %f\n",index_,NOW);
+ 
+   Packet* p=txbuffer.head();
+   hdr_cmn*  cmh = HDR_CMN(p);
+   int receiver_addr=cmh->next_hop();
+   
+    txbuffer.LockBuffer();
+    int num=txbuffer.num_of_packet;
+    printf("rmac MakeReservation: node %d lock txbuffer \n",index_);
+ 
+    //   int sender_addr=index_;
+ 
+ 
+    // double lt=-1.0;
+      double dt=num*max_large_packet_transmissiontime+(num-1)*SIF_;
+      double it=CalculateOffset(dt);
+      double t2=DetermineSendingTime(receiver_addr);
+ 
+       Packet* pkt =Packet::alloc();
+       hdr_rmac* revh = HDR_RMAC(pkt);
+       cmh = HDR_CMN(pkt);
+  
+ 
+        cmh->next_hop()=receiver_addr;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_RMAC;
+       
+        revh->ptype=P_REV;
+        revh->block_num=num_block;
+        revh->pk_num = num_send;
+        revh->duration=dt;
+        revh->sender_addr=index_;
+        revh->interval=it;
+        num_send++;
+ 
+   printf("rmac:Makereservation node %d send a reservation to node %d, duration is %f and offset is %f after %f at %f \n",
+           index_, receiver_addr,revh->duration,it,t2,NOW);  
+ 
+          Scheduler& s=Scheduler::instance();
+         s.schedule(&reserve_handler, (Event*) pkt,t2);	
+ }
+ 
+ 
+ 
+ /*
+ In this function, we assume that the sleep time is long enough such that there 
+ exist interval between two reserved slot (ACK slot) that is long for the max 
+ data transmission, this function will return the offset of the transmission 
+ duration to the beginning if this period.
+ */
+ 
+ double 
+ RMac::CalculateOffset(double dt)
+ {
+ 
+   int index=-1;
+   
+   double offset=0.0; 
+   double ack_window=max_short_packet_transmissiontime;
+   double elapsed_time=NOW-cycle_start_time;
+   struct period_record table[TABLE_SIZE];
+   
+    for(int i=0;i<TABLE_SIZE;i++)
+      {
+       
+        table[i].node_addr=period_table[i].node_addr;
+        double l=CheckLatency(short_latency_table, table[i].node_addr)
+ 	 -max_short_packet_transmissiontime;
+        double d=period_table[i].difference-l;
+        if (d<0) d+=PeriodInterval_;
+        table[i].difference=d;
+ 
+      }
+ 
+      SortPeriodTable(table);
+ 
+    
+     
+ 
+      for (int i=0;i<TABLE_SIZE;i++)
+ {
+   printf("node addr is%d and difference is%f\n",table[i].node_addr,table[i].difference);
+ }
+       
+      
+ 
+  // find the first index that can be reached by sending data after elapsed_time 
+    int k=0;
+   while((-1==index)&&(k<period_table_index))
+     {
+       
+     if(table[k].difference+ack_window>elapsed_time) index=k;     
+     k++;
+     }
+   
+   if(-1==index)
+  {
+     offset=elapsed_time;
+     return offset;
+  }
+  
+   //  double it=0;
+   int start_index=-1;
+   double t0=elapsed_time;
+ 
+   for(int i=index;i<period_table_index-1;i++)  
+     {
+       // double t=period_table[i+1].difference-period_table[i].difference;
+       double t=table[i].difference-t0;
+       
+       //t-=ack_window;// avoid the reserved time slot for ackrev 
+       if((t>=dt)&&(-1==start_index)) start_index=i;
+       t0=table[i].difference+ack_window;
+     }
+  
+   //  printf("Calculate offset start_index=%d and index=%d and elapsedtime=%f t0=%f\n",
+   //            start_index,index, elapsed_time,t0);
+   
+ 
+   // we assumw that the listen window is large enough, there must 
+   // exist slot larger enough for data transmission
+ 
+   if(-1==start_index) start_index=period_table_index-1;
+   if(start_index==index) return elapsed_time;
+ 
+   offset=table[start_index-1].difference+ack_window;
+   return offset;
+ }
+ 
+ 
+ 
+ // determine the sending time, we assume that listen duration is 
+ // long enough such that we have enough time slots to select.  
+ // this function randomly selects one of the available slots and 
+ // converts into time scale
+ 
+ double 
+ RMac::DetermineSendingTime(int receiver_addr)
+ {
+ 
+    struct period_record table[TABLE_SIZE];
+   
+    for(int i=0;i<TABLE_SIZE;i++)
+      {
+       
+        table[i].node_addr=period_table[i].node_addr;
+        double l=CheckLatency(short_latency_table, table[i].node_addr)
+ 	 -max_short_packet_transmissiontime;
+        double d=period_table[i].difference-l;
+        if (d<0) d+=PeriodInterval_;
+        table[i].difference=d;
+      }
+ 
+      SortPeriodTable(table);
+ 
+ 
+      //  double delay=CheckLatency(short_latency_table,receiver_addr)
+      //  -max_short_packet_transmissiontime;
+ 
+   /*
+   double dt1=CheckDifference(period_table,receiver_addr);
+   double elapsed_time=NOW-cycle_start_time;
+   double offset_time=0;
+   */
+       double elapsed_time=NOW-cycle_start_time;
+      double time_slot=max_short_packet_transmissiontime;
+      double dt1=CheckDifference(table,receiver_addr);
+      double offset_time=dt1+time_slot-elapsed_time;
+      while (offset_time<0) offset_time+=PeriodInterval_;        
+     
+    double dt2=dt1+duration_-time_slot; // end of the time slot 
+    double t0=dt1;   //start time of the time slot
+    int num_slot=0;
+    int n=0;
+    int i=0;
+ 
+    //  while ((period_table[i].difference>dt1)&&(period_table[i].difference<dt2))
+    while (table[i].difference<dt2)
+     {
+       if(table[i].difference>dt1)
+ 	{
+       double t=table[i].difference;
+       double l=t-t0-time_slot;
+       n=(int) floor(l/time_slot);
+       num_slot+=n;
+       t0=t;
+         }
+       i++;
+     }
+   
+      double l=dt2-t0-time_slot;
+      n=(int) floor(l/time_slot);
+      num_slot+=n;
+   
+      int randIndex=rand()% num_slot;     
+     
+   i=0;
+   int sum=0; 
+   double rand_time=0.0;
+   //  int sum1=0;
+   t0=dt1;
+   bool allocated=false;
+   // while ((period_table[i].difference>=dt1)&&(period_table[i].difference<dt2))
+ 
+ 
+    
+   while (table[i].difference<dt2)
+     {
+       if(table[i].difference>dt1)
+     {
+       double t=table[i].difference;
+       rand_time=t0-dt1;
+ 
+       double l=t-t0-time_slot;
+       n=(int) floor(l/time_slot);
+ 
+       t0=t;
+       // i++;
+       if((sum+n)>randIndex) {
+         allocated=true;
+         while(sum<=randIndex) 
+        {
+          rand_time+=time_slot;
+          sum++;
+        }
+       }
+ 	else sum+=n;
+     }
+       i++;
+     }
+   
+   if(!allocated)
+     {
+      rand_time=t0-dt1;
+      double l=dt2-t0-time_slot;
+      n=(int) floor(l/time_slot);
+ 
+         if((sum+n)>randIndex) {
+         allocated=true;
+         while(sum<=randIndex) 
+        {
+          rand_time+=time_slot;
+          sum++;
+        }
+ 	}
+     }
+    
+   if(!allocated) printf("RMac:DetermineSendingTime,node %d has some probem to allocate sending time \n",
+ 			index_); 
+ 
+    return offset_time+rand_time;
+ }
+ 
+ 
+ double 
+ RMac::CheckLatency(latency_record* table,int addr)
+ {
+   int i=0;
+ double d=0.0;
+  
+  while((table[i].node_addr!=addr)&&(i<TABLE_SIZE))
+ {
+   //printf("node addr is%d and latency is%f\n",table[i].node_addr,table[i].latency);
+  i++;
+ }
+  if (i==TABLE_SIZE) return d;
+  else return table[i].latency;
+ }
+ 
+ 
+ 
+ 
+ double 
+ RMac:: CheckDifference(period_record* table,int addr)
+ {
+   int i=0;
+ double d=-0.0;
+  
+  while((table[i].node_addr!=addr)&&(i<TABLE_SIZE))i++;
+ 
+  if (i==TABLE_SIZE) return d;
+  else return table[i].difference;
+ }
+ 
+ 
+ void 
+ RMac::TxRev(Event* e){
+ 
+   printf("RMac TxREv node %d at %f\n",index_,NOW);
+ 
+   Packet* pkt=(Packet*) e;  
+   hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+   
+   if(mac_status==RMAC_FORBIDDED) {
+  printf("TxREV, node %d is in  RMAC_FORBIDDED, cancel sending REV at %f\n",index_,NOW);
+  Packet::free(pkt);
+  return;
+   }
+ 
+   // Is it possible??
+  if(mac_status==RMAC_WAIT_ACKREV) {
+  printf("TxREV, node %d is in  RMAC_ACKREV, cancel sending REV at %f\n",index_,NOW);
+  Packet::free(pkt);
+  return;
+   } 
+ 
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  
+   hdr_cmn::access(pkt)->txtime()=(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+ 
+    mac_status=RMAC_WAIT_ACKREV;
+ 
+    printf("TxREV, node %d is in  RMAC_WAIT_ACKREV at %f\n",index_,NOW);
+ 
+    // double t=Timer*PeriodInterval_;
+ 
+      double t=5*PeriodInterval_;
+     Scheduler& s=Scheduler::instance();
+     s.schedule(&timeout_handler,&timeout_event,t);
+ 
+   if(SLEEP==n->TransmissionStatus()) {
+   Poweron();
+   n->SetTransmissionStatus(SEND); 
+   cmh->ts_=NOW;
+ 
+   sendDown(pkt);
+   // printf("TxREV, node %d is in sleep at %f\n",index_,NOW);
+   status_handler.SetStatus(SLEEP);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==n->TransmissionStatus()){
+   
+     n->SetTransmissionStatus(SEND);
+  
+      cmh->ts_=NOW;
+ 
+      sendDown(pkt);
+      // printf("broadcast %d Tx Idle set timer at %f tx is %f\n",node_->nodeid(),NOW,txtime);
+ 
+      printf("TxREV, node %d is in idle at %f\n",index_,NOW);
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==n->TransmissionStatus())
+     {
+       
+       InterruptRecv(txtime);
+       cmh->ts_=NOW;
+       sendDown(pkt);
+       printf("TxREV, node %d is in recv at %f\n",index_,NOW);
+       status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);
+      return;
+     }
+ 
+ 
+ if (SEND==n->TransmissionStatus())
+   {
+     printf("rmac: queue send data too fast\n");
+     Packet::free(pkt);
+       return;
+   }
+ 
+ }
+ 
+ 
+ 
+ void 
+ RMac::InitPhaseTwo(){
+ 
+    double delay=Random::uniform()*PhaseTwo_window_;
+    next_period=IntervalPhase2Phase3_+PhaseTwo_cycle_*PhaseTwo_window_+delay;
+ 
+    Scheduler& s=Scheduler::instance();
+    s.schedule(&phasethree_handler, &phasethree_event,next_period);
+   
+    StartPhaseTwo();
+     return;  
+ }
+ 
+ void 
+ RMac::StartPhaseTwo()
+ {
+    if(PhaseTwo_cycle_)
+     {  
+      printf("Phase Two: node %d  and cycle:%d\n",index_, PhaseTwo_cycle_);
+      PhaseStatus=PHASETWO;
+      cycle_start_time=NOW;
+     double  delay=Random::uniform()*PhaseTwo_window_; 
+     Packet* pkt=GenerateSYN();
+     Scheduler& s=Scheduler::instance();
+     s.schedule(&syn_handler,(Event*) pkt, delay);    
+     s.schedule(&phasetwo_handler,&phasetwo_event,PhaseTwo_window_+PhaseTwo_interval_);
+     next_period-=PhaseTwo_window_-PhaseTwo_interval_;
+     PhaseTwo_cycle_--;
+     }
+    return;   
+ }
+ 
+ 
+ 
+ 
+ /*
+ void 
+ RMac::InitPhaseTwo(){
+ 
+    double delay=Random::uniform()*PhaseTwo_window_;
+    PhaseStatus=PHASETWO;
+ 
+     cycle_start_time=NOW;
+     next_period=IntervalPhase2Phase3_+PhaseTwo_window_+delay;
+  
+     printf("rmac Initphasetwo: the phasethree of node %d is scheduled at %f\n",index_,NOW+next_period);
+     Scheduler& s=Scheduler::instance();
+     s.schedule(&phasetwo_handler, &phasetwo_event,delay);
+     return;
+ }
+ 
+ */
+ 
+ Packet*  
+ RMac::GenerateSYN(){
+ 
+        Packet* pkt =Packet::alloc();
+        hdr_rmac* synh = HDR_RMAC(pkt); 
+        hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+        cmh->size()=short_packet_size_;
+        cmh->next_hop()=MAC_BROADCAST;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_RMAC;
+       
+       
+        synh->ptype=P_SYN;
+        synh->pk_num = num_send;
+        synh->sender_addr= node_->address();
+      
+        synh->duration=duration_;
+         num_send++;
+ 
+ 	printf("rmac GenerateSYN:node(%d) generates SYN packet at %f\n", synh->sender_addr,NOW);
+ 	return pkt; 
+ }
+ 
+ 
+ 
+ void 
+ RMac::SendSYN(){
+ 
+        Packet* pkt =Packet::alloc();
+        hdr_rmac* synh = HDR_RMAC(pkt); 
+        hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+        cmh->size()=short_packet_size_;
+        cmh->next_hop()=MAC_BROADCAST;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_RMAC;
+       
+       
+        synh->ptype=P_SYN;
+        synh->pk_num = num_send;
+        synh->sender_addr= node_->address();
+      
+        synh->duration=duration_;
+         num_send++;
+ 
+ 	printf("rmac SendSYN:node(%d) send SYN packet at %f\n", synh->sender_addr,NOW);
+       TxND(pkt, PhaseTwo_window_);  
+ }
+ 
+ 
+ void 
+ RMac::InitND(double t1,double t2, double t3)
+ {  
+  
+   double delay=Random::uniform()*t1;
+   double itval=(t3-t2-t1)/2.0;
+   double delay3=t1+itval;
+  
+   Scheduler& s=Scheduler::instance();
+ 
+    s.schedule(&short_nd_handler, &short_nd_event, delay);
+    s.schedule(&short_acknd_window_handler,&short_acknd_event,delay3);
+   return;
+ }
+ 
+ void 
+ RMac::SendND(int pkt_size)
+ {
+ 
+       Packet* pkt =Packet:: alloc();
+       hdr_rmac* ndh = HDR_RMAC(pkt);
+     
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+    
+      // additional 2*8 denotes the size of type,next-hop of the packet and 
+      // timestamp
+   
+       //       cmh->size()=sizeof(hdr_nd)+3*8;
+       //  printf("old size is %d\n",cmh->size());
+         cmh->size()=pkt_size;
+ 
+        cmh->next_hop()=MAC_BROADCAST;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_RMAC;
+       
+        
+      
+       ndh->ptype=P_ND;
+       ndh->pk_num = num_send;
+       ndh->sender_addr= node_->address();
+ 
+       num_send++;
+ 
+       // iph->src_.addr_=node_->address();
+       // iph->dst_.addr_=node_->address();
+       //iph->dst_.port_=255;     
+ 
+  printf("rmac SendND:node(%d) send ND type is %d at %f\n", ndh->sender_addr,cmh->ptype_, NOW);
+       TxND(pkt, ND_window_);  
+ }
+ 
+ 
+ 
+ 
+ 
+ void 
+ RMac::SendShortAckND()
+ {
+     printf("rmac:SendShortND: node %d\n",index_);
+   if (arrival_table_index==0) return;// not ND received
+ 
+ 
+   while(arrival_table_index>0){ 
+       Packet* pkt = Packet::alloc();
+       hdr_rmac* ackndh = HDR_RMAC(pkt);
+     
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+       ackndh->ptype=P_SACKND;
+       ackndh->pk_num = num_send;
+       ackndh->sender_addr=node_->address();
+       num_send++;
+ 
+       cmh->ptype_=PT_RMAC;
+         
+          int index1=-1;
+         index1=rand()%arrival_table_index; 
+         double t2=-0.1;
+         double t1=-0.1;
+     
+         int receiver=arrival_table[index1].node_addr;
+          t2=arrival_table[index1].arrival_time; 
+          t1=arrival_table[index1].sending_time; 
+ 
+ 	 for(int i=index1;i<arrival_table_index;i++){
+ 	   arrival_table[i].node_addr=arrival_table[i+1].node_addr;
+            arrival_table[i].sending_time=arrival_table[i+1].sending_time;
+            arrival_table[i].arrival_time=arrival_table[i+1].arrival_time;
+ 	 }
+    
+           ackndh->arrival_time=t2;
+           ackndh->ts=t1;
+   // additional 2*8 denotes the size of type,next-hop of the packet and 
+   // timestamp
+     //  cmh->size()=sizeof(hdr_ack_nd)+3*8;
+     
+ 
+       cmh->size()=short_packet_size_;
+       cmh->next_hop()=receiver;
+       cmh->direction()=hdr_cmn::DOWN; 
+       cmh->addr_type()=NS_AF_ILINK;
+ 
+       
+          Scheduler& s=Scheduler::instance();
+          double delay=Random::uniform()*ACKND_window_;
+          s.schedule(&acknd_handler, (Event*) pkt, delay);
+ 
+ 	 arrival_table_index--;
+   }
+ 
+ 
+      arrival_table_index=0; 
+   for(int i=0;i<TABLE_SIZE;i++)
+     arrival_table[i].node_addr=-1;
+ 
+           return; 
+ }
+ 
+ /*
+ void 
+ RMac::TxND(Packet* pkt, double window)
+ {
+   //  printf("RMac TxND node %d\n",index_); 
+   hdr_cmn* cmh=HDR_CMN(pkt);
+    hdr_rmac* synh = HDR_RMAC(pkt); 
+   
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  
+   hdr_cmn::access(pkt)->txtime()=(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+   if(SLEEP==n->TransmissionStatus()) {
+   Poweron();
+   n->SetTransmissionStatus(SEND);
+   cmh->ts_=NOW;
+ 
+   if(PhaseStatus==PHASETWO){
+ 
+     double t=NOW-cycle_start_time;
+ 
+     synh->interval=next_period-t;
+  
+     
+     Scheduler & s=Scheduler::instance();
+     s.schedule(&phasethree_handler,&phasethree_event,synh->interval);
+   }
+ 
+   sendDown(pkt);
+   backoff_handler.clear();
+ 
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==n->TransmissionStatus()){
+   
+   n->SetTransmissionStatus(SEND);
+  
+   //printf("TxND the data type is %d\n",MAC_BROADCAST);
+   //printf("broadcast : I am going to send the packet down tx is %f\n",txtime);
+      cmh->ts_=NOW;
+ 
+   if(PhaseStatus==PHASETWO){
+ 
+    double t=NOW-cycle_start_time;
+    synh->interval=next_period-t; 
+ 
+   
+     Scheduler & s=Scheduler::instance();
+     s.schedule(&phasethree_handler,&phasethree_event,synh->interval);
+   }
+ 
+   sendDown(pkt);
+   backoff_handler.clear();
+   //  printf("broadcast %d Tx Idle set timer at %f tx is %f\n",node_->nodeid(),NOW,txtime);
+ 
+    status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==n->TransmissionStatus())
+     {
+       Scheduler& s=Scheduler::instance();
+       double d1=window-(NOW-cycle_start_time);
+  
+       if(d1>0){
+       double backoff=Random::uniform()*d1;
+       backoff_handler.window_=window;
+    // printf("broadcast Tx set timer at %f backoff is %f\n",NOW,backoff);
+       s.schedule(&backoff_handler,(Event*) pkt,backoff);
+       return;
+       }
+       else {
+           backoff_handler.clear();
+           printf("Rmac:NODE %d backoff:no time left \n",index_);
+           Packet::free(pkt);
+       }
+ 
+     }
+ 
+ if (SEND==n->TransmissionStatus())
+ {
+   // this case is supposed not to  happen 
+     printf("rmac: queue send data too fas\n");
+     Packet::free(pkt);
+       return;
+ }
+ 
+ }
+ 
+ */
+ 
+ 
+ 
+ void 
+ RMac::TxND(Packet* pkt, double window)
+ {
+    printf("RMac TxND node %d\n",index_); 
+   hdr_cmn* cmh=HDR_CMN(pkt);
+    hdr_rmac* synh = HDR_RMAC(pkt); 
+   
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  
+   hdr_cmn::access(pkt)->txtime()=(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+   if(SLEEP==n->TransmissionStatus()) {
+   Poweron();
+   n->SetTransmissionStatus(SEND);
+   cmh->ts_=NOW;
+ 
+   if(PhaseStatus==PHASETWO){
+ 
+     double t=NOW-cycle_start_time;
+ 
+     synh->interval=next_period-t;
+   }
+ 
+   sendDown(pkt);
+   backoff_handler.clear();
+ 
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==n->TransmissionStatus()){
+   
+   n->SetTransmissionStatus(SEND);
+  
+   //printf("TxND the data type is %d\n",MAC_BROADCAST);
+   //printf("broadcast : I am going to send the packet down tx is %f\n",txtime);
+      cmh->ts_=NOW;
+ 
+   if(PhaseStatus==PHASETWO){
+ 
+    double t=NOW-cycle_start_time;
+    synh->interval=next_period-t; 
+ 
+   }
+ 
+   sendDown(pkt);
+   backoff_handler.clear();
+   //  printf("broadcast %d Tx Idle set timer at %f tx is %f\n",node_->nodeid(),NOW,txtime);
+ 
+    status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==n->TransmissionStatus())
+     {
+       Scheduler& s=Scheduler::instance();
+       double d1=window-(NOW-cycle_start_time);
+  
+       if(d1>0){
+       double backoff=Random::uniform()*d1;
+       backoff_handler.window_=window;
+    // printf("broadcast Tx set timer at %f backoff is %f\n",NOW,backoff);
+       s.schedule(&backoff_handler,(Event*) pkt,backoff);
+       return;
+       }
+       else {
+           backoff_handler.clear();
+           printf("Rmac:backoff: node %d no time left, just drop the packet \n",index_);
+           Packet::free(pkt);
+       }
+ 
+     }
+ 
+ if (SEND==n->TransmissionStatus())
+ {
+   // this case is supposed not to  happen 
+     printf("rmac: queue send data too fas\n");
+     Packet::free(pkt);
+       return;
+ }
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ void  
+ RMac::ProcessACKRevPacket(Packet* pkt)
+ {
+     printf("RMac:ProcessACKRevPacket: node %d at time %f\n",index_,NOW);
+ 
+     hdr_rmac* ackrevh=HDR_RMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+     int dst=cmh->next_hop();
+     int ptype=ackrevh->ptype; 
+ 
+     // since the node clearly receives the ACKrev, does not need to backoff, 
+     //  therefore, resets the carrier sense;   
+     UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+    
+ 
+   
+     if(ptype!=P_ACKREV) 
+       {
+ 	printf("processACKRevPacket:node %d receives no ACK_REV packet at %f\n",index_,NOW);
+         return;
+       }
+     if(cmh->error()){
+ 	printf("processACKRevPacket:node %d senses carrier in ackwindow at  %f\n",index_,NOW);
+         carrier_sense=true;
+         return;
+     }
+     n->ResetCarrierId();
+     carrier_sense=false;
+ 
+ 
+     int receiver_addr=ackrevh->receiver_addr;
+     double dt=ackrevh->duration-ackrevh->st;
+     double st=ackrevh->st;
+     int sender_addr=ackrevh->sender_addr;
+    
+     double  l=CheckLatency(short_latency_table,sender_addr);
+     double  it=st-l;
+    
+     double elapsedtime=NOW-cycle_start_time; 
+  
+     if(elapsedtime>1.1*max_short_packet_transmissiontime) 
+       {
+ 	printf("RMac:processACKRev:node %d this is out of my ackrev window...\n",index_);
+ 	Packet::free(pkt);
+         return;
+       }
+ 
+ 
+     if((dst!=index_)&&(index_==receiver_addr))
+  {
+   
+    printf("RMac:processACKrev: node %d  receives a ackrev  targetd at %d and receiver is %d\n",
+              index_,dst,receiver_addr);
+    Packet::free(pkt);
+  return;
+  }
+     
+ 
+      printf("rmac:ProcessAckRevPacket:node %d I get the ACK REV packet offset is %f and duration=%f at %f\n",
+             index_, it,dt,NOW);     
+     //printf("rmac:ProcessAckRevPacket: node %d I get the ACK REV packet interval is %f \n",index_, it);
+ 
+     if(it<0) 
+      printf("rmac:ProcessAckRevPacket: the notification is too short\n");
+     
+     Packet::free(pkt);
+ 
+ 
+     if(receiver_addr!=index_) {
+       // This ackrev is not for me
+      printf("rmac:ProcessAckRevPacket: node %d this ACKREV is not for me\n",index_);
+      double poffset=PeriodInterval_+elapsedtime+it-l+max_short_packet_transmissiontime;
+      InsertReservedTimeTable(receiver_addr,poffset,dt);
+     }
+     else {
+     // This ackrev is for me
+       if(mac_status!=RMAC_WAIT_ACKREV) {
+      printf("rmac:ProcessAckRevPacket:status change, I quit this chance\n");  
+      return;
+       }
+        
+         printf("rmac:ProcessAckRevPacket: node %d this ACKREV is for me\n",index_);         
+         num_data=0;
+      
+ 	double  it1=it-l+max_short_packet_transmissiontime;
+         mac_status=RMAC_TRANSMISSION;
+         Scheduler& s=Scheduler::instance();
+         printf("rmac:ProcessAckRevPacket: node %d schedule Txdata after %f at time %f, latency is %f\n",
+                  index_,it1,NOW,l);
+     
+         s.cancel(&timeout_event);// cancel the timer of rev
+         transmission_handler.receiver=sender_addr;      
+         s.schedule(&transmission_handler,&transmission_event,it1);
+     } 
+     return;
+ }
+ 
+ 
+ void 
+ RMac::ClearTxBuffer(){
+  printf("RMac: ClearTxBuffer: node %d clear its buffer\n",index_);
+ 
+   Packet*  p1[MAXIMUM_BUFFER];
+   
+   for (int i=0;i<MAXIMUM_BUFFER;i++)p1[i]=NULL;
+   buffer_cell* bp=txbuffer.head_;
+   int i=0;
+   while(bp){
+     p1[i]=bp->packet;
+     bp=bp->next;
+     i++;
+   }
+ 
+  
+ 
+   for (int i=0;i<MAXIMUM_BUFFER;i++){
+     //   printf("ClearTxBuffer the poniter is%d\n",p1[i]);
+     if (bit_map[i]==1) txbuffer.DeletePacket(p1[i]);
+   
+ 
+   }
+  
+   /*
+   printf("ClearTxBuffer: show the queue****************after txbufferdelete\n");
+       t->showqueue();  
+   */
+ 
+   printf("txbuffer is cleared, there are %d packets left\n",txbuffer.num_of_packet);
+ 
+   return; 
+ }
+ 
+ 
+ 
+ void 
+ RMac::ProcessACKDataPacket(Packet* pkt)
+ {
+ printf("rmac:ProcessACKDATAPacket: node %d process ACKDATA packets at time %f duration_=%f\n",index_,NOW,duration_);
+ //  hdr_rmac* ackrevh=HDR_RMAC(pkt);
+ //    hdr_cmn* cmh=HDR_CMN(pkt);
+  
+     Scheduler& s=Scheduler::instance();
+ printf("rmac:ProcessAckData: node %d cancel timeout dutation=%f\n",index_,duration_);    
+       s.cancel(&timeout_event);// cancel the timer of data
+   
+ 
+   
+     
+     for (int i=0;i<MAXIMUM_BUFFER;i++)bit_map[i]=0;
+ 
+     memcpy(bit_map, pkt->accessdata(),sizeof(bit_map));
+   
+   printf("rmac:ProcessACKDATAPacket: node %d received the bitmap is:\n",index_);
+   
+ 
+   for (int i=0;i<MAXIMUM_BUFFER;i++) printf("bitmap[%d]=%d ",i,bit_map[i]);
+   printf("\n");
+ 
+   printf("txbuffer will be cleared, there are %d packets in queue and duration=%f\n",txbuffer.num_of_packet,duration_);
+ 
+       Packet::free(pkt);   
+ 
+ 
+  /*
+ !!!
+ This part should consider the retransmission state, in this implementation, we don't consider the packets loss
+ caused by channel errors, therefore, we just ignore it, it should be added later. 
+ */
+ 
+     ClearTxBuffer(); 
+     num_block++;
+     txbuffer.UnlockBuffer();
+     mac_status=RMAC_IDLE;
+ printf("rmac:ProcessACKDATAPacket: node %d unlock txbuffer duration_=%f\n",index_,duration_);
+    ResumeTxProcess();
+     return;
+ }
+ 
+ 
+ void 
+ RMac::ProcessRevPacket(Packet* pkt)
+ {
+     printf("RMac:ProcessRevPacket: node %d is processing rev\n",index_);
+     hdr_rmac* revh=HDR_RMAC(pkt);
+     // hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int sender_addr=revh->sender_addr;
+     double dt=revh->duration;
+     double interval=revh->interval;
+     int block=revh->block_num;
+ 
+     Packet::free(pkt);
+    
+    
+     if (mac_status==RMAC_IDLE)
+     {     
+     if(reservation_table_index <TABLE_SIZE){  
+     reservation_table[reservation_table_index].node_addr=sender_addr;
+     reservation_table[reservation_table_index].required_time=dt;   
+     reservation_table[reservation_table_index].interval=interval;      
+     reservation_table[reservation_table_index].block_id=block;
+     reservation_table_index++;
+     }
+     else {
+     printf("ramc:ProcessRevPacket: too many reservation, drop the packet\n");
+     }
+     }
+     else {
+    printf("rmac:ProcessRevPacket: I am not in idle state, drop this packet\n"); 
+     }
+       return;
+ }
+ 
+ 
+ 
+ 
+ void 
+ RMac::ProcessNDPacket(Packet* pkt)
+ {
+   // printf("rmac:ProcessNDPacket: node %d\n",index_);
+     hdr_rmac* ndh=HDR_RMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int  sender=ndh->sender_addr;
+     double time=NOW;
+     if(arrival_table_index>=TABLE_SIZE){ 
+       printf("rmac:ProcessNDPacket:arrival_table is full\n");
+       Packet::free(pkt);
+       return;
+     }
+     arrival_table[arrival_table_index].node_addr=sender;
+     arrival_table[arrival_table_index].arrival_time=time;
+     arrival_table[arrival_table_index].sending_time=cmh->ts_;
+     arrival_table_index++;
+     Packet::free(pkt);
+       return;
+ }
+ 
+ 
+ void 
+ RMac::ProcessDataPacket(Packet* pkt)
+ {
+   printf("rmac:ProcessDataPacket: node %d get data packet\n",index_);
+ 
+   //  hdr_uwvb* vbh=HDR_UWVB(pkt);
+   hdr_rmac* rmach=HDR_RMAC(pkt);
+ 
+   int  data_sender=rmach->sender_addr;
+   int  bnum=rmach->block_num;
+   int num=rmach->data_num;
+  
+ 
+       recv_busy=true;
+       Scheduler& s=Scheduler::instance();
+       s.cancel(&timeout_event);
+ 
+       //     MarkBitMap(num);
+       UpdateACKDataTable(data_sender,bnum,num);
+       
+       uptarget_->recv(pkt,this);
+       return;
+ }
+ 
+ /*
+ void 
+ RMac::MarkBitMap(int num){
+   if(num<MAXIMUM_BUFFER) bit_map[num]=1;
+ }
+ */
+ 
+ void 
+ RMac::UpdateACKDataTable(int data_sender,int bnum,int num)
+ {
+   int index=-1;
+   for (int i=0;i<ackdata_table_index;i++) 
+     if(ackdata_table[i].node_addr==data_sender) index=i;
+ 
+   if(index==-1){
+     ackdata_table[ackdata_table_index].node_addr=data_sender;
+     ackdata_table[ackdata_table_index].block_num=bnum;
+     ackdata_table[ackdata_table_index].bitmap[num]=1;
+     ackdata_table_index++;
+   }
+   else 
+     {
+     ackdata_table[index].node_addr=data_sender;
+     ackdata_table[index].block_num=bnum;
+     ackdata_table[index].bitmap[num]=1;
+     }
+ }
+ 
+ 
+ // this program need to be modified to handle the 
+ // retransmission 
+ 
+ void 
+ RMac::ScheduleACKData(int data_sender)
+ {
+   printf("rmac Schdeule ACKDATA: node %d at %f\n",index_,NOW);
+   
+   if(data_sender<0) 
+   {
+     printf("Ramc:ScheduleACKData: invalid sender address\n");
+     return; 
+   }
+ 
+     Packet* pkt=Packet::alloc(sizeof(bit_map)); 
+     hdr_cmn*  cmh = HDR_CMN(pkt);
+     hdr_rmac* revh = HDR_RMAC(pkt);
+  
+     CopyBitmap(pkt, data_sender);
+  
+        cmh->next_hop()=data_sender;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_RMAC;
+        cmh->size()=short_packet_size_;     
+      
+        revh->ptype=P_ACKDATA;
+        revh->pk_num = num_send;
+        revh->sender_addr=index_;
+        num_send++;
+  
+        double t1=DetermineSendingTime(data_sender);
+          
+       printf("rmac Schdeule ACKDATA: node %d  schedule ackdata after %f at %f\n",index_,t1,NOW);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&ackdata_handler, (Event*) pkt,t1);
+ }
+ 
+ void 
+ RMac::CopyBitmap(Packet* pkt,int data_sender)
+ {
+   int index=-1;
+   for (int i=0;i<ackdata_table_index;i++)
+     if(ackdata_table[i].node_addr==data_sender) index=i;
+       
+  
+   if(index!=-1) 
+     memcpy(pkt->accessdata(),ackdata_table[index].bitmap,sizeof(bit_map));
+   else printf("CopyBitMap: Node %d: I can't find the entry of the sender %d \n",index_, data_sender);
+ }
+ 
+ bool
+ RMac::IsSafe()
+ {
+   bool safe_status=true;
+   if(RMAC_FORBIDDED!=mac_status) return safe_status;
+   double start_time=NOW-cycle_start_time;
+   double ending_time=start_time+max_short_packet_transmissiontime;
+   for(int i=0;i<reserved_time_table_index;i++)
+     {
+       double t1=reserved_time_table[i].start_time;
+       double d1=reserved_time_table[i].duration;
+       if((ending_time>t1)&&((t1+d1)>start_time)) safe_status=false;
+     }
+   return safe_status;
+ }
+ 
+ 
+ void  
+ RMac::TxACKData(Event* e)
+ {
+  printf("RMac TxACKData node %d at %f\n",index_,NOW);
+ 
+   Packet* pkt=(Packet*) e;
+   hdr_cmn* cmh=HDR_CMN(pkt);
+  
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+   if(!IsSafe()) {
+     // It is not safe to send this ACKData  since it collides with reserved time  slot
+     Packet::free(pkt);
+     return;
+   }
+  
+   hdr_cmn::access(pkt)->txtime()=(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+ 
+    mac_status=RMAC_IDLE;
+ 
+   printf("TxACKData, node %d is in  RMAC_IDLE at %f\n",index_,NOW);
+ 
+  
+   if(SLEEP==n->TransmissionStatus()) {
+   Poweron();
+   n->SetTransmissionStatus(SEND); 
+   cmh->ts_=NOW;
+ 
+   sendDown(pkt);
+ 
+   printf("RMac TxACKData node %d at %f\n",index_,NOW);
+   status_handler.SetStatus(SLEEP);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==n->TransmissionStatus()){
+   
+     n->SetTransmissionStatus(SEND);
+  
+      cmh->ts_=NOW;
+ 
+      sendDown(pkt);
+   printf("RMac TxACKData node %d at %f\n",index_,NOW);
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==n->TransmissionStatus())
+     {
+       
+       InterruptRecv(txtime);
+       cmh->ts_=NOW;
+       sendDown(pkt);
+ printf("RMac TxACKData node %d at %f\n",index_,NOW);
+       status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);
+      return;
+     }
+ 
+ 
+ if (SEND==n->TransmissionStatus())
+   {
+     printf("rmac: node%d send data too fast\n",index_);
+     Packet::free(pkt);
+       return;
+   }
+ 
+ }
+ 
+ 
+ void 
+ RMac::ProcessShortACKNDPacket(Packet* pkt)
+ {
+   // printf("rmac:ProcessshortACKNDPacket: node %d\n",index_);
+     hdr_rmac* ackndh=HDR_RMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int  sender=ackndh->sender_addr;
+     double t4=NOW;
+     double t3=cmh->ts_;
+     int myaddr=node_->address();
+  
+     double t2=ackndh->arrival_time;
+     double t1=ackndh->ts;
+ 
+ double latency=((t4-t1)-(t3-t2))/2.0;
+ bool newone=true;   
+ 
+ Packet::free(pkt);
+    
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (short_latency_table[i].node_addr==sender)
+       {
+        short_latency_table[i].sumLatency+=latency;
+        short_latency_table[i].num++;
+        short_latency_table[i].last_update_time=NOW;
+        short_latency_table[i].latency = 
+                   short_latency_table[i].sumLatency/short_latency_table[i].num;
+        newone=false;
+       }
+  
+  if(newone)
+ {
+ 
+     if(short_latency_table_index>=TABLE_SIZE){ 
+       printf("rmac:ProcessNDPacket:arrival_table is full\n");
+       return;
+     }
+ 
+     short_latency_table[short_latency_table_index].node_addr=sender;
+     short_latency_table[short_latency_table_index].sumLatency+=latency;
+     short_latency_table[short_latency_table_index].num++;
+     short_latency_table[short_latency_table_index].last_update_time=NOW;
+     short_latency_table[short_latency_table_index].latency = 
+           short_latency_table[short_latency_table_index].sumLatency/short_latency_table[short_latency_table_index].num;
+     short_latency_table_index++;
+ }
+  for(int i=0;i<short_latency_table_index;i++)
+    printf("node (%d) to node (%d) short latency is %f and number is %d\n", myaddr, short_latency_table[i].node_addr, short_latency_table[i].latency,short_latency_table[i].num); 
+  
+  return;
+ 
+ }
+ 
+ 
+ void 
+ RMac::ProcessSYN(Packet* pkt)
+ {
+   // printf("rmac:ProcessSYN: node %d\n",index_);
+     hdr_rmac* synh=HDR_RMAC(pkt);
+     //    hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int  sender=synh->sender_addr;
+     double interval=synh->interval;
+     double tduration=synh->duration;
+       Packet::free(pkt);
+ 
+ 
+     double t1=-1.0;
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (short_latency_table[i].node_addr==sender)
+      t1=short_latency_table[i].latency;
+ 
+  if(t1==-1.0) {
+  printf("Rmac:ProcessSYN: I receive a SYN from unknown neighbor %d\n",sender);
+    return; 
+  }
+ 
+  interval-=t1;
+  double t2=next_period-(NOW-cycle_start_time);
+  double d=interval-t2;
+ 
+ if (d>=0.0) {
+    while (d>=PeriodInterval_) d-=PeriodInterval_;
+  }
+  else 
+    {
+      while (d+PeriodInterval_<=0.0) d+=PeriodInterval_;
+    }
+ 
+ 
+ 
+  bool newone=true;     
+  
+  if(d<0) d=d+PeriodInterval_;   
+ 
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (period_table[i].node_addr==sender)
+       {
+        period_table[i].difference=d;
+        period_table[i].last_update_time=NOW;
+        period_table[i].duration =tduration; 
+        newone=false;
+       }
+  
+  if(newone)
+ {
+ 
+     if(period_table_index>=TABLE_SIZE){ 
+       printf("rmac:ProcessSYN:period_table is full\n");
+       return;
+     }
+ 
+ 
+     period_table[period_table_index].node_addr=sender;
+     period_table[period_table_index].difference=d;
+     period_table[period_table_index].last_update_time=NOW;
+     period_table[period_table_index].duration=tduration;
+     period_table_index++;
+ }
+ 
+  for(int i=0;i<period_table_index;i++)
+    printf("node (%d) to node (%d) period difference  is %f \n",index_,period_table[i].node_addr, period_table[i].difference); 
+  
+  return;
+ 
+ }
+ 
+ 
+ /*
+  this program is used to handle the received packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ 
+ void 
+ RMac::RecvProcess(Packet* pkt){
+    
+    hdr_cmn* cmh=HDR_CMN(pkt);
+    hdr_rmac* cmh1=HDR_RMAC(pkt);
+    int dst=cmh->next_hop();
+    int ptype=cmh1->ptype; 
+    double elapsed_time=NOW-cycle_start_time;
+    double ack_window=max_short_packet_transmissiontime+theta;
+     
+    printf("rmac:node %d  gets a broadcast packet at  %f\n",index_,NOW);
+    
+    // check if it is in the revack window
+    if(elapsed_time<=ack_window) 
+       {
+      ProcessACKRevPacket(pkt);
+      return;
+       }
+ 
+    if (cmh->error()) 
+      {
+      printf("rmac:node %d  gets a corrupted packet at  %f\n",index_,NOW);
+      Packet::free(pkt);
+      return;
+      }
+ 
+   if(dst==MAC_BROADCAST){
+     printf("rmac:node %d  gets a broadcast packet at  %f and type is %d\n",index_,NOW, cmh->ptype_);
+     if (ptype==P_ND) ProcessNDPacket(pkt); //this is ND packet
+ 
+         // this is ACK_ND packet  
+     if (ptype==P_SYN) ProcessSYN(pkt);
+    
+     // uptarget_->recv(pkt, this);
+     return;
+   }
+ 
+   //  if (ptype==P_ACKREV) {ProcessACKRevPacket(pkt); return;}
+    if(dst==index_){
+  printf("rmac:node %d  gets a packet at  %f and type is %d and %d\n",index_,NOW, cmh->ptype_,cmh1->ptype);
+    if (ptype==P_SACKND) ProcessShortACKNDPacket(pkt); 
+    if (ptype==P_REV) ProcessRevPacket(pkt); 
+    if (ptype==P_DATA) ProcessDataPacket(pkt);
+   // if (ptype==P_ACKREV) ProcessACKRevPacket(pkt);
+    if(ptype==P_ACKDATA) ProcessACKDataPacket(pkt);
+      // printf("underwaterbroadcastmac:this is my packet \n");
+      //  uptarget_->recv(pkt, this);
+     return;
+ }
+     printf("rmac: node%d this is neither broadcast nor my packet %d, just drop it at %f\n",index_,dst, NOW);
+    Packet::free(pkt);
+    return;
+ }
+ 
+ 
+ void 
+ RMac::TxData(int receiver)
+ {
+   printf("RMac:node %d TxData at time %f\n",index_,NOW);
+ 
+   if (txbuffer.IsEmpty()) 
+ {
+ printf("Rmac:TxData: what a hell! I don't have data to send\n");
+ return;
+ }
+ 
+ 
+   if(mac_status!=RMAC_TRANSMISSION) {
+  printf("Rmac:TxData: node %d is not in transmission state\n",index_);
+       return;
+   }
+ 
+    UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   if(n->TransmissionStatus()==SLEEP) Poweron();
+ 
+      mac_status=RMAC_TRANSMISSION;
+ 
+     Packet* pkt=txbuffer.next();
+    
+     hdr_cmn* cmh=hdr_cmn::access(pkt);
+     hdr_rmac* datah =hdr_rmac::access(pkt);
+     hdr_uwvb* hdr2=hdr_uwvb::access(pkt);
+ 
+     // printf("RMac:node %d TxData at time %f data type is %d offset is%d and size is %d and offset is %d and size is%d uwvb offset is %d and size is %d\n",index_,NOW,hdr2->mess_type,cmh,sizeof(hdr_cmn),datah,sizeof(hdr_rmac),hdr2,sizeof(hdr_uwvb));
+          datah->ptype=P_DATA;  
+ 
+          datah->sender_addr=index_;
+    
+          datah->pk_num=num_send;
+          datah->data_num=num_data;
+          datah->block_num=num_block;
+ 
+          num_send++;
+          num_data++;
+   
+           cmh->size()=large_packet_size_;
+ 
+             cmh->next_hop()=receiver;
+ 	   
+             cmh->direction()=hdr_cmn::DOWN; 
+             cmh->addr_type()=NS_AF_ILINK;
+             cmh->ptype_=PT_RMAC; 
+ 
+ 	    
+ 
+   hdr_cmn::access(pkt)->txtime()=(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+  printf("RMac:node %d TxData at time %f data type is %d packet data_num=%d class data_num=%d \n",index_,NOW,hdr2->mess_type,datah->data_num,num_data);
+   TransmissionStatus status=n->TransmissionStatus();
+ 
+  
+ 
+  if(IDL==status)
+  {
+   n->SetTransmissionStatus(SEND); 
+         sendDown(pkt);
+  printf("RMac:node %d TxData at %f\n ",index_,NOW);
+         status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);  
+  }
+ 
+  if(RECV==status)
+     {
+       InterruptRecv(txtime);
+       
+       sendDown(pkt);
+  printf("RMac:node %d TxData at %f\n ",index_,NOW);
+       status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);
+     }
+ 
+  if (SEND==status)
+     { 
+     printf("rmac:Txdata: queue send data too fast\n");
+     Packet::free(pkt);
+     }
+ 
+   
+   if (txbuffer.IsEnd()) {
+    printf("rmac:Txdata: node %d is in state MAC_WAIT_ACKDATA\n",index_);
+    mac_status=RMAC_WAIT_ACKDATA; 
+   
+    //  double txtime=Timer*PeriodInterval_;  
+        double txtime=3*PeriodInterval_; 
+    printf("RMac:node %d TxData at %f\n ",index_,NOW);
+    Scheduler& s=Scheduler::instance();
+    s.schedule(&timeout_handler,&timeout_event,txtime);
+   
+    //  num_block++;
+    Poweroff();
+   }
+   else {
+   double it=SIF_+txtime;   
+  
+  printf("rmac:Txdata: node%d schedule  next data packet , interval=%f at time%f\n",index_,it,NOW);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&transmission_handler,&transmission_event,it);
+   }
+ 
+ }
+ 
+ 
+ void 
+ RMac::ResumeTxProcess(){
+ 
+   printf("rmac:ResumeTxProcess: node %d at %f\n",index_,NOW);
+ 
+   if(!txbuffer.IsFull()) 
+   if(callback_) callback_->handle(&status_event);
+   return;
+ }
+ 
+ 
+ 
+ /*
+  this program is used to handle the transmitted packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ RMac::TxProcess(Packet* pkt){
+ 
+   hdr_uwvb* hdr=HDR_UWVB(pkt);
+ 
+   printf("rmac:TxProcess: node %d type is %d\n",index_,hdr->mess_type);
+  UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   if (n->setHopStatus){
+    hdr_cmn* cmh=HDR_CMN(pkt);
+    cmh->next_hop()=n->next_hop;
+    cmh->error()=0;//set off the error flag
+ 
+    // printf("rmac:TxProcess: node %d set next hop to %d\n",index_,cmh->next_hop());
+   }
+  
+ 
+   txbuffer.AddNewPacket(pkt);
+   printf("rmac:TxProcess: node %d put new data packets in txbuffer\n",index_);
+   if(!txbuffer.IsFull()) 
+   if(callback_) callback_->handle(&status_event);
+   return;
+ }
+ 
+ 
+  
+ void 
+ RMac::StatusProcess(Event* p, TransmissionStatus  state)
+ {
+ 
+    printf("RMac StatusProcess node %d \n",index_);
+  UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+  
+  if(SLEEP==n->TransmissionStatus()) return;
+ 
+     n->SetTransmissionStatus(state);
+ 
+  return;
+ }
+ 
+ 
+ 
+ 
+ int
+ RMac::command(int argc, const char*const* argv)
+ {
+ 
+ 
+      if(argc == 3) {
+        //TclObject *obj;
+                  if (strcmp(argv[1], "node_on") == 0) {
+ 		   Node* n1=(Node*) TclObject::lookup(argv[2]);
+ 		   if (!n1) return TCL_ERROR;
+ 		   node_ =n1; 
+ 		   return TCL_OK;
+ 		 }
+ 
+ 		 /*
+                if (strcmp(argv[1], "set_next_hop") == 0) {
+ 		 setHopStatus=1;
+ 		 next_hop=atoi(argv[2]);
+ 		   return TCL_OK;
+ 	       }
+ 	      */
+      }
+ 
+ 	return UnderwaterMac::command(argc, argv);
+ }
diff -crBN ns-2.35/underwatersensor/uw_mac/rmac.h ns-2.35-aquasim/underwatersensor/uw_mac/rmac.h
*** ns-2.35/underwatersensor/uw_mac/rmac.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/rmac.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,652 ----
+ #ifndef ns_rmac_h
+ #define ns_rmac_h
+ 
+ #include "underwatermac.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "uwbuffer.h"
+ 
+ #define TABLE_SIZE 20 // the size of delay table
+ #define MAXIMUMBACKOFF 4 // the maximum times of backoffs
+ #define BACKOFF 1 //deleted later, used by TxProcess
+ 
+ 
+ 
+ #define UW_ND 1
+ #define UW_ACK_ND 2
+ 
+ 
+ #define PHASEONE 1
+ #define PHASETWO 2
+ #define PHASETHREE 3
+ 
+ enum RmacPacketType{
+   P_DATA,
+   P_REV,
+   P_ACKREV,
+   P_ND,
+   P_SACKND,
+   P_ACKDATA,
+   P_SYN
+ };
+ 
+ 
+ enum MAC_STATUS{
+   RMAC_IDLE,
+   RMAC_REV,
+   RMAC_ACKREV,
+   RMAC_RECV,
+   RMAC_WAIT_ACKREV,
+   RMAC_WAIT_ACKDATA,
+   RMAC_FORBIDDED,
+   RMAC_TRANSMISSION,
+ };
+ 
+ 
+ 
+ 
+ struct forbidden_time_record{
+   int node_addr;// the address of the node
+   double start_time;// the time to receive the ND packet from the node
+   double next_time; // the  start time of next availabe period 
+   double duration; // the sending time of ND in local clock
+  
+ };
+ 
+ struct time_record{
+   int node_addr;// the address of the node
+   double arrival_time;// the time to receive the ND packet from the node
+   double sending_time; // the sending time of ND in local clock
+ };
+ 
+ 
+ struct reservation_record{
+   int  node_addr;    // the address of the node 
+   double required_time;    // the duration of required time slot 
+   double interval;
+   int block_id;
+ //the  interval between the start time of the transmission and the 
+ // start time of the cycle
+ };
+ 
+ 
+ 
+ struct ackdata_record{
+   int node_addr;// the address of the sender
+   int bitmap[MAXIMUM_BUFFER];  // the pointer to the bitmap
+   int block_num;// the block id 
+ };
+ 
+ 
+ struct period_record{
+   int node_addr;// the address of the node
+   double difference;// the difference with my period
+   double duration; // duration of duty cycle
+   double last_update_time; // the time last updated
+ };
+ 
+ 
+ struct latency_record{
+   int node_addr;      // the address of the node
+   double latency;    // the propagation latency with that node
+   double sumLatency;// the sum of latency
+   int num;         // number of ACKND packets 
+   double last_update_time; // the time of last update
+ };
+ 
+ struct hdr_rmac{
+          int ptype;     //packet type
+         int pk_num;    // sequence number
+         int data_num; 
+         int block_num; // the block num, in real world, one bit is enough
+         int sender_addr;  //original sender' address
+    	double st;           // Timestamp when pkt is generated.
+         int receiver_addr;
+         double duration;
+         double interval;
+         double arrival_time;
+          double ts;	
+ 
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_rmac* access(const Packet*  p) {
+ 		return (hdr_rmac*) p->access(offset_);
+ 	}
+ };
+ 
+ /*
+ struct hdr_rmac_data{
+         double duration;  // there is a bug, put this to fix it
+           int pk_num;    // sequence number
+          int sender_addr;     //original sender' address
+        // int receiver_addr;  // the address of the intended receiver
+            
+ 	
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_rmac_data* access(const Packet*  p) {
+ 		return (hdr_rmac_data*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ 
+ 
+ struct hdr_rev{
+         // unsigned int type;     //packet type
+          int pk_num;    // sequence number
+         int sender_addr;     //original sender' address
+   // int receiver_addr;  // the address of the intended receiver
+         double duration;           // time interval for reservation 
+ 	
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_rev* access(const Packet*  p) {
+ 		return (hdr_rev*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ struct hdr_ack_rev{
+         // unsigned int type;     //packet type
+         int pk_num;    // sequence number
+         int sender_addr;     //original sender' address
+         int receiver_addr;  // the address of the intended receiver
+         double duration;           // time interval for reservation 
+         double st;                 // start time of reservation 	
+ 
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_ack_rev* access(const Packet*  p) {
+ 		return (hdr_ack_rev*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ 
+ 
+ struct hdr_syn{
+         //  unsigned int type;     //packet type
+          int pk_num;    // sequence number
+         int sender_addr;  //original sender' address
+         double interval;    // interval to the begining of periodic operation
+         double duration; // duration of duty cycle;
+ 
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_syn* access(const Packet*  p) {
+ 		return (hdr_syn*) p->access(offset_);
+ 	}
+ };
+ 
+ struct hdr_ack_nd{
+   //	unsigned int type;
+          int pk_num;    // sequence number
+         int sender_addr;  //original sender' address
+          double ts;// sending time of the ND in sender's clock
+   double arrival_time; //arrival time of ND in  the receiver's clock
+        //  struct  time_record table[TABLE_SIZE]; // delay table
+ 	
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+ 
+   	inline static hdr_ack_nd* access(const Packet*  p) {
+ 		return (hdr_ack_nd*) p->access(offset_);
+ 	}
+ };
+ 
+ */
+ 
+ 
+ 
+ class RMac;
+ 
+ class ACKREVHandler: public Handler{
+  public:
+   ACKREVHandler(RMac* p): mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ class ClearChannelHandler: public Handler{
+  public:
+   ClearChannelHandler(RMac* p): mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ 
+ };
+ 
+ 
+ 
+ 
+ class MACRECVHandler: public Handler{
+  public:
+   MACRECVHandler(RMac* p):data_sender(0),duration(0),status(0),mac_(p) {};
+   void handle(Event*);
+   int data_sender;
+   double duration;// duration of RECV 
+   int status;// 0 is open the recv window and 1 is close window
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ 
+ class TimeoutHandler: public Handler{
+  public:
+   TimeoutHandler(RMac* p): mac_(p){};
+   void handle(Event*);
+ 
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ 
+ class SleepHandler: public Handler{
+  public:
+   SleepHandler(RMac* p): mac_(p){};
+   void handle(Event*);
+ 
+  private:
+   RMac* mac_;
+ };
+ 
+ class WakeupHandler: public Handler{
+  public:
+   // WakeupHandler(RMac*);
+   WakeupHandler(RMac* p): mac_(p){};
+   void handle(Event*);
+ 
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ class ACKDATAHandler: public Handler{
+  public:
+   // ACKDATAHandler(RMac*);
+   ACKDATAHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ class ACKWindowHandler: public Handler{
+  public:
+   //  ACKWindowHandler(RMac*);
+   ACKWindowHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ class CarrierSenseHandler: public Handler{
+  public:
+   // CarrierSenseHandler(RMac*);
+   CarrierSenseHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ class ReserveHandler: public Handler{
+  public:
+   // ReserveHandler(RMac*);
+   ReserveHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ class TransmissionHandler: public Handler{
+  public:
+   //TransmissionHandler(RMac*);
+   TransmissionHandler(RMac* p):receiver(0), mac_(p) {};
+   void handle(Event*);
+    int receiver;
+  private: 
+   RMac* mac_;
+ };
+ 
+ 
+ class NDBackoffHandler: public Handler{
+  public:
+   //  NDBackoffHandler(RMac*);
+   NDBackoffHandler(RMac* p):window_(0),counter_(0),mac_(p){};
+   void handle(Event*);
+   void clear();
+   double window_;
+ 
+  private:
+   int counter_;
+   RMac* mac_;
+ };
+ 
+ 
+ 
+ 
+ class ShortNDHandler: public Handler{
+  public:
+   //ShortNDHandler(RMac*);
+   ShortNDHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ class SYNHandler: public Handler{
+  public:
+   SYNHandler(RMac* p): mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ class NDStatusHandler: public Handler{
+  public:
+   // NDStatusHandler(RMac*);
+   NDStatusHandler(RMac* p): status_(SLEEP), mac_(p) {}
+   void SetStatus(TransmissionStatus);
+   void handle(Event*);
+  private:
+   TransmissionStatus status_;     
+   RMac* mac_;
+ };
+ 
+ 
+ 
+ 
+ class ShortAckNDWindowHandler: public Handler{
+  public:
+   //ShortAckNDWindowHandler(RMac*);
+   ShortAckNDWindowHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ class ACKNDHandler: public Handler{
+  public:
+   // ACKNDHandler(RMac*);
+   ACKNDHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ 
+ class PhaseOneHandler: public Handler{
+  public:
+   // PhaseOneHandler(RMac*);
+   PhaseOneHandler(RMac* p):mac_(p){}
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ class PhaseTwoHandler: public Handler{
+  public:
+   // PhaseTwoHandler(RMac*);
+   PhaseTwoHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ class PhaseThreeHandler: public Handler{
+  public:
+   //PhaseThreeHandler(RMac*);
+   PhaseThreeHandler(RMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   RMac* mac_;
+ };
+ 
+ 
+ 
+ class RMac: public UnderwaterMac {
+    
+ public:
+         RMac();
+      
+        	int  command(int argc, const char*const* argv);
+         double  ND_window_;// the window to send ND
+         double  ACKND_window_;// the winddow to send ACK_ND
+         double  PhaseOne_window_; // the time for latency detection
+         double  PhaseTwo_window_; // the time for SYN announcement
+         double SIF_;// interval between two successive data packets
+         double ACKRevInterval_;
+         double PhaseTwo_interval_;// interval between windows of phase two
+         int PhyOverhead_;// the overhead caused by phy layer
+         int arrival_table_index;
+ 	//        int large_latency_table_index;
+         int short_latency_table_index;
+         int period_table_index;
+         int reservation_table_index;
+         int reserved_time_table_index;
+         int ackdata_table_index;
+         int Timer;// number of periodIntervals to backoff
+         //int data_sender; // address of the data sender
+ 
+          // in real world, this is supposed to use bit map
+ 	// to indicate the lost of packet
+ 	  int bit_map[MAXIMUM_BUFFER];
+         
+ 	// these two variables are used to set next hop 
+ 	// SetHopStatus=1 then set next hop using next_hop
+ 	// int setHopStatus;
+         //int next_hop;
+          
+         bool carrier_sense; // sense the channel in the ackrev time slot
+ 	//   bool skip;
+         int num_send; 
+         int num_data;
+         int num_block;
+ 
+         int large_packet_size_;
+         int short_packet_size_;   
+         double duration_; // duration of duty cycle     
+         double IntervalPhase2Phase3_;
+         double next_period;//the start_time of next duty cycle
+         double PeriodInterval_;
+         double max_short_packet_transmissiontime;
+         double max_large_packet_transmissiontime;
+         double transmission_time_error_; //guardian time
+         double theta; //used for precision control
+ 
+         int PhaseOne_cycle_; // number of cycles in phase one
+         int PhaseTwo_cycle_; // number of cycles in phase two 
+ 
+         int PhaseStatus;  
+        // used by the receiver to test if the data packet arrives on time   
+         bool recv_busy; 
+      // used to indicate the status of collecting reservations
+         bool collect_rev;
+       
+         enum MAC_STATUS mac_status;
+ 
+ 	double cycle_start_time; // the begining time of this cycle;  
+         TransmissionBuffer txbuffer;
+          struct  time_record arrival_table[TABLE_SIZE]; 
+          struct forbidden_time_record reserved_time_table[TABLE_SIZE];
+          //struct latency_record large_latency_table[TABLE_SIZE];            
+          struct latency_record short_latency_table[TABLE_SIZE];    
+          struct period_record  period_table[TABLE_SIZE];
+          struct reservation_record reservation_table[TABLE_SIZE];
+          struct reservation_record next_available_table[TABLE_SIZE];
+          struct ackdata_record ackdata_table[TABLE_SIZE];
+          struct buffer_cell * ack_rev_pt;// pointer to the link of ack_rev
+ 
+  void InitPhaseOne(double/*ND window*/,double/*ack_nd window*/,double/* phaseOne window*/); 
+     
+  void InitPhaseTwo(); 
+  void InitPhaseThree();
+  void StartPhaseTwo();
+ 
+      void InitND(double/*ND window*/,double/*ack_nd window*/,double/* phase One window*/);// to detect latency 
+ 
+      void SendND(int);
+      void TxND(Packet*, double);
+      // void ProcessPacket(Packet*);   
+      void ProcessNDPacket(Packet*);   
+      void ProcessDataPacket(Packet*);   
+      // void ProcessLargeACKNDPacket(Packet*);   
+      void ProcessShortACKNDPacket(Packet*);   
+      void ProcessSYN(Packet*);
+      void ProcessSleep();
+      void ProcessRevPacket(Packet*);
+      void ProcessACKRevPacket(Packet*);
+      void ProcessACKDataPacket(Packet*);
+      void ProcessReservedTimeTable();
+      bool ProcessRetransmission();
+      void ProcessListen();
+      void ProcessCarrier();
+ 
+      void ResetReservation();
+      void Wakeup();
+      void TxRev(Event*);
+      void TxACKRev(Packet*);
+      void TxACKData(Event*);
+      void ResetMacStatus();
+      void ScheduleACKREV(int,double,double);
+      void ScheduleACKData(int);
+      //void SendLargeAckND();
+      void SendShortAckND();
+      void StatusProcess(Event*,TransmissionStatus);
+      void SendSYN();
+      void MakeReservation();
+      void ArrangeReservation();
+      void ResetReservationTable();   
+      void SetStartTime(buffer_cell*, double,double);
+      void ClearTxBuffer();
+      void InsertReservedTimeTable(int,double,double);   
+      void SortPeriodTable(struct period_record*);
+      void InsertBackoff();
+      void CopyBitmap(Packet*,int);
+      void UpdateACKDataTable(int,int,int);
+      void ClearReservationTable(int);
+      Packet*  GenerateACKRev(int,/* receiver*/int /* intended receiver's addr*/,
+                          double/* time duration*/);
+      Packet* GenerateSYN();
+      int  SelectReservation();
+      double CalculateOffset(double);
+      double CalculateACKRevTime(double,double,double,double);
+      double CalculateACKRevTime(double,double,double);
+      double DetermineSendingTime(int);
+      double CheckLatency(latency_record*,int);
+      double CheckDifference(period_record*,int);
+   
+    
+      bool IsRetransmission(int);
+      bool NewData();// ture if there exist data needed to send, false otherwise
+      bool IsACKREVWindowCovered(double current_time);
+      bool IsSafe();
+ 
+      //     void MarkBitMap(int);
+  
+      void InsertACKRevLink(Packet*, double);
+      void InsertACKRevLink(Packet*, double*);
+      void TxData(int);
+      void ClearACKRevLink();
+      void StartRECV(double,int,int);
+      void SetNextHop();
+      void DeleteBufferCell(Packet*);
+      void DeleteRecord(int);
+      void CancelReservation();
+      void CancelREVtimeout();
+      void PrintTable();
+      void ResumeTxProcess();
+      void ClearChannel();
+ 
+      //     void InsertNextAvailableTable(int,double);
+      //  void ProcessNextAvailableTable();
+      // double CheckNextAvailableTable(int);
+ 
+          Event large_nd_event;
+          Event short_nd_event;
+          Event status_event;
+ 	 // Event large_acknd_event;
+          Event short_acknd_event;         
+          Event phaseone_event;
+          Event phasetwo_event;
+          Event phasethree_event;
+          Event sleep_event;
+          Event wakeup_event;
+          Event timeout_event;
+          Event transmission_event;
+          Event mac_recv_event;
+          Event clear_channel_event;
+          Event ackwindow_event;
+          Event carrier_sense_event;
+ 
+ 
+          NDStatusHandler status_handler;
+ 	 // LargeNDHandler large_nd_handler;
+          ShortNDHandler short_nd_handler;
+          NDBackoffHandler backoff_handler;
+          
+          ACKNDHandler acknd_handler;
+ 	 //  LargeAckNDWindowHandler large_acknd_window_handler;         
+          ShortAckNDWindowHandler short_acknd_window_handler; 
+ 
+          PhaseOneHandler phaseone_handler;
+          PhaseTwoHandler phasetwo_handler; 
+          PhaseThreeHandler phasethree_handler;
+          SleepHandler sleep_handler;   
+          WakeupHandler wakeup_handler; 
+          ReserveHandler reserve_handler; 
+          ACKDATAHandler ackdata_handler;
+          TimeoutHandler timeout_handler;
+          ACKREVHandler ackrev_handler;
+          TransmissionHandler transmission_handler;
+          MACRECVHandler mac_recv_handler;
+          ClearChannelHandler clear_channel_handler;
+          ACKWindowHandler ackwindow_handler;
+          CarrierSenseHandler carrier_sense_handler;
+          SYNHandler syn_handler;      
+         //Node* node(void) const {return node_;}
+         // to process the incomming packet
+         virtual  void RecvProcess(Packet*);
+       
+        // to process the outgoing packet
+         virtual  void TxProcess(Packet*);
+ 
+ protected:        
+ 	inline int initialized() {
+ 	return  UnderwaterMac::initialized();
+ 	}
+  private:
+ 	//	double interval_ND_ACKND;
+         friend class NDBackoffHandler;
+         friend class AckNDWindowHanlder;
+         friend class NDHandler;
+         friend class Status_handler;
+         friend class PhaseOneHandler;
+         friend class PhaseTwoHandler;
+         friend class PhaseThreeHandler;
+         friend class SleepHandler;
+         friend class ReserveHandler;
+         friend class TimeoutHandler;
+         friend class ACKREVHandler;
+         friend class TransmissionHandler;
+         friend class MACRECVHandler;
+         friend class ACKDATAHanlder;
+         friend class ClearChannelHandler;
+         friend class ACKWindowHandler;
+         friend class CarrierSenseHandler;
+         friend class SYNHandler;
+         
+ };
+ 
+ #endif /* __rmac_h__ */
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/slotted-fama/sfama.cc ns-2.35-aquasim/underwatersensor/uw_mac/slotted-fama/sfama.cc
*** ns-2.35/underwatersensor/uw_mac/slotted-fama/sfama.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/slotted-fama/sfama.cc	2016-09-03 00:44:18.484000000 +0800
***************
*** 0 ****
--- 1,830 ----
+ #include "sfama.h"
+ 
+ 
+ 
+ int hdr_SFAMA::offset_;
+ static class SFAMA_HeaderClass: public PacketHeaderClass{
+ public:
+ 	SFAMA_HeaderClass():PacketHeaderClass("PacketHeader/SFAMA",sizeof(hdr_SFAMA))
+ 	{
+ 		bind_offset(&hdr_SFAMA::offset_);
+ 	}
+ }class_SFAMA_hdr;
+ 
+ 
+ 
+ static class SFAMAClass : public TclClass {
+ public:
+ 	SFAMAClass():TclClass("Mac/UnderwaterMac/SFAMA") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new SFAMA());
+ 	}
+ }class_SFAMA;
+ 
+ 
+ /*expire functions and handle functions*/
+ void SFAMA_Wait_Send_Timer::expire(Event *e)
+ {
+ 	mac_->WaitSendTimerProcess(pkt_);
+ 	pkt_ = NULL;  /*reset pkt_*/
+ }
+ 
+ 
+ void SFAMA_Wait_Reply_Timer::expire(Event* e)
+ {
+ 	mac_->WaitReplyTimerProcess();
+ }
+ 
+ 
+ void SFAMA_Backoff_Timer::expire(Event* e)
+ {
+ 	mac_->BackoffTimerProcess();
+ }
+ 
+ 
+ void SFAMA_CallBackHandler::handle(Event* e)
+ {
+ 	mac_->CallBackProcess(e);
+ }
+ 
+ void SFAMA_MAC_StatusHandler::handle(Event* e)
+ {
+ 	mac_->StatusProcess(slotnum());
+ }
+ 
+ void SFAMA_DataSend_Timer::expire(Event *e)
+ {
+ 	mac_->DataSendTimerProcess();
+ }
+ 
+ void SFAMA_SlotInitHandler::handle(Event* e)
+ {
+ 	mac_->initSlotLen();
+ }
+ 
+ 
+ SFAMA::SFAMA():UnderwaterMac(), status_(IDLE_WAIT), guard_time_(0.00001), slot_len_(0.0),
+ 	is_in_round(false), is_in_backoff(false), max_backoff_slots_(4), max_burst_(1),
+ 	data_sending_interval_(0.0000001), callback_handler(this), status_handler(this), 
+ 	slotinit_handler(this), wait_send_timer(this), 	wait_reply_timer(this), 
+ 	backoff_timer(this), datasend_timer(this)
+ {
+ 	bind("guard_time_", &guard_time_);
+ 	bind("max_backoff_slots_", &max_backoff_slots_);	
+ 	bind("max_burst_", &max_burst_);
+ 	
+ 	Random::seed_heuristically();
+ 
+ 	Scheduler::instance().schedule(&slotinit_handler, 
+ 		&slotinit_event, 0.05 /*callback delay*/);
+ }
+ 
+ 
+ int SFAMA::command(int argc, const char *const *argv)
+ {
+ 	return UnderwaterMac::command(argc, argv);
+ }
+ 
+ 
+ void SFAMA::RecvProcess(Packet *p)
+ {
+ 	hdr_SFAMA* SFAMAh = hdr_SFAMA::access(p);
+ 
+ #ifdef SFAMA_DEBUG
+ 			printf("Time: %f:node %d, %f: node %d recv from node %d\n", 
+ 				   NOW, index_, NOW, HDR_MAC(p)->macDA(), HDR_MAC(p)->macSA());
+ #endif
+ 	
+ 		switch( SFAMAh->packet_type ) {
+ 			case hdr_SFAMA::SFAMA_RTS:
+ 				processRTS(p);
+ 				break;
+ 			case hdr_SFAMA::SFAMA_CTS:
+ 				processCTS(p);
+ 				break;
+ 			case hdr_SFAMA::SFAMA_DATA:
+ 				processDATA(p);
+ 				break;
+ 			case hdr_SFAMA::SFAMA_ACK:
+ 				processACK(p);
+ 				break;
+ 			default:
+ 				/*unknown packet type. error happens*/
+ 				printf("unknown packet type in SFAMA::RecvProcess");
+ 
+ 				break;
+ 		}
+ 	
+ 	
+ 
+ 	Packet::free(p);
+ }
+ 
+ 
+ void SFAMA::TxProcess(Packet *p)
+ {
+ 	//hdr_cmn* cmh = hdr_cmn::access(p);
+ 	//hdr_SFAMA* SFAMAh = hdr_SFAMA::access(p);
+ 
+ 	Scheduler::instance().schedule(&callback_handler, 
+ 		&callback_event, 0.0001 /*callback delay*/);
+ 	
+ 	fillDATA(p);
+ /*
+ 	SFAMAh->SA = index_;
+ 	SFAMAh->DA = cmh->next_hop();
+ 
+ 	cmh->error() = 0;
+ 	cmh->size() += hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_DATA);
+ 	cmh->txtime() = getTxtimeByPktSize(cmh->size());
+ */
+ 
+ #ifdef SFAMA_DEBUG
+ printf("TxProcess(before)\n");
+ printAllQ();
+ #endif
+ 	CachedPktQ_.push(p);
+ #ifdef SFAMA_DEBUG
+ printf("TxProcess(after)\n");
+ printAllQ();
+ #endif
+ 	if( CachedPktQ_.size() == 1 && getStatus() == IDLE_WAIT ) {
+ 		prepareSendingDATA();
+ 	}
+ }
+ 
+ 
+ void SFAMA::initSlotLen()
+ {
+ 	slot_len_ = guard_time_ + 
+ 		getTxTime(hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_CTS)) +
+ 		UnderwaterChannel::Transmit_distance()/1500.0;
+ }
+ 
+ /*
+ Time SFAMA::getTxtimeByPktSize(int pkt_size)
+ {
+ 	return pkt_size*8*encoding_efficiency_/bit_rate_;
+ }
+ */
+ 
+ 
+ Time SFAMA::getTime2ComingSlot(Time t)
+ {
+ 	int numElapseSlot = int(t/slot_len_);
+ 
+ 	return slot_len_*(1+numElapseSlot)-t;	
+ }
+ 
+ 
+ Packet* SFAMA::makeRTS(nsaddr_t recver, int slot_num)
+ {
+ 	Packet* rts_pkt = Packet::alloc();
+ 	hdr_cmn* cmh = HDR_CMN(rts_pkt);
+ 	hdr_mac* mach = HDR_MAC(rts_pkt);
+ 	hdr_SFAMA* SFAMAh= hdr_SFAMA::access(rts_pkt);
+ 
+ 	cmh->size() = hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_RTS);
+ 	cmh->txtime() = getTxTime(cmh->size());
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->ptype() = PT_SFAMA;
+ 
+ 	mach->macSA() = index_;
+ 	mach->macDA() = recver;
+ 	
+ 	SFAMAh->packet_type = hdr_SFAMA::SFAMA_RTS;
+ 	//SFAMAh->SA = index_;
+ 	//SFAMAh->DA = recver;
+ 	SFAMAh->SlotNum = slot_num;
+ 
+ 	rts_pkt->next_ = NULL;
+ 
+ 	return rts_pkt;
+ }
+ 
+ 
+ Packet* SFAMA::makeCTS(nsaddr_t rts_sender, int slot_num)
+ {
+ 	Packet* cts_pkt = Packet::alloc();
+ 	hdr_cmn* cmh = HDR_CMN(cts_pkt);
+ 	hdr_mac* mach = HDR_MAC(cts_pkt);
+ 	hdr_SFAMA* SFAMAh= hdr_SFAMA::access(cts_pkt);
+ 
+ 	cmh->size() = hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_CTS);
+ 	cmh->txtime() = getTxTime(cmh->size());
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->ptype() = PT_SFAMA;
+ 
+ 	mach->macSA() = index_;
+ 	mach->macDA() = rts_sender;
+ 	
+ 	SFAMAh->packet_type = hdr_SFAMA::SFAMA_CTS;
+ 	//SFAMAh->SA = index_;
+ 	//SFAMAh->DA = rts_sender;
+ 	SFAMAh->SlotNum = slot_num;
+ 
+ 	cts_pkt->next_ = NULL;
+ 
+ 	return cts_pkt;
+ }
+ 
+ 
+ Packet* SFAMA::fillDATA(Packet *data_pkt)
+ {
+ 	hdr_cmn* cmh = HDR_CMN(data_pkt);
+ 	hdr_mac* mach = HDR_MAC(data_pkt);
+ 	hdr_SFAMA* SFAMAh = hdr_SFAMA::access(data_pkt);
+ 
+ 	cmh->size() += hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_DATA);
+ 	cmh->txtime() = getTxTime(cmh->size());
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	
+ 	mach->macSA() = index_;
+ 	mach->macDA() = cmh->next_hop();
+ 
+ 	SFAMAh->packet_type = hdr_SFAMA::SFAMA_DATA;
+ 	//SFAMAh->SA = index_;
+ 	//SFAMAh->DA = cmh->next_hop();
+ 
+ 	return data_pkt;
+ }
+ 
+ 
+ Packet* SFAMA::makeACK(nsaddr_t data_sender)
+ {
+ 	Packet* ack_pkt = Packet::alloc();
+ 	hdr_cmn* cmh = HDR_CMN(ack_pkt);
+ 	hdr_mac* mach = HDR_MAC(ack_pkt);
+ 
+ 	hdr_SFAMA* SFAMAh= hdr_SFAMA::access(ack_pkt);
+ 
+ 	cmh->size() = hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_ACK);
+ 	cmh->txtime() = getTxTime(cmh->size());
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->ptype() = PT_SFAMA;
+ 
+ 	mach->macSA() = index_;
+ 	mach->macDA() = data_sender;
+ 
+ 	SFAMAh->packet_type = hdr_SFAMA::SFAMA_ACK;
+ 	//SFAMAh->SA = index_;
+ 	//SFAMAh->DA = data_sender;
+ 	
+ 	return ack_pkt;
+ }
+ 
+ 
+ /*process all kinds of packets*/
+ 
+ void SFAMA::processRTS(Packet *rts_pkt)
+ {
+ 	hdr_SFAMA* SFAMAh = hdr_SFAMA::access(rts_pkt);
+ 	hdr_mac* mach = HDR_MAC(rts_pkt);
+ 
+ 	Time time2comingslot = getTime2ComingSlot(NOW);
+ 
+ 	if( mach->macDA() == index_ ) {
+ 		if ( (getStatus() == IDLE_WAIT ||
+ 			getStatus() == WAIT_SEND_RTS ||
+ 			getStatus() == BACKOFF_FAIR )   		) {
+ 
+ 				stopTimers();		
+ 				setStatus(WAIT_SEND_CTS);
+ 				//reply a cts
+ 				wait_send_timer.pkt_ = makeCTS(mach->macSA(), SFAMAh->SlotNum);
+ 				wait_send_timer.resched(time2comingslot);
+ 		}
+ 	}
+ 	else {
+ 		//do backoff
+ 		Time backoff_time = time2comingslot + 1 /*for cts*/+
+ 			SFAMAh->SlotNum*slot_len_ /*for data*/+ 1 /*for ack*/;
+ 
+ 		stopTimers();		
+ 		setStatus(BACKOFF);
+ 
+ 		backoff_timer.resched(backoff_time);
+ 		
+ 	}
+ }
+ 
+ void SFAMA::processCTS(Packet *cts_pkt)
+ {
+ 	hdr_SFAMA* SFAMAh = hdr_SFAMA::access(cts_pkt);
+ 	hdr_mac* mach = HDR_MAC(cts_pkt);
+ 	Time time2comingslot = getTime2ComingSlot(NOW);
+ 
+ 	if( mach->macDA() == index_ && getStatus() == WAIT_RECV_CTS ) {
+ 
+ 		//send DATA
+ 		stopTimers();		
+ 		setStatus(WAIT_SEND_DATA);
+ 		//send the packet
+ 		wait_send_timer.pkt_ = NULL;
+ 		wait_send_timer.resched(time2comingslot);
+ 		
+ 		Time wait_time = (1+SFAMAh->SlotNum)*slot_len_+time2comingslot;
+ 		if( time2comingslot < 0.1 ) {
+ 			wait_time += slot_len_;
+ 		}
+ 		
+ 		wait_reply_timer.resched(wait_time);
+ 	}
+ 	else {
+ 		//do backoff
+ 		Time backoff_time = SFAMAh->SlotNum*slot_len_ /*for data*/+ 
+ 			1 /*for ack*/+time2comingslot;
+ 
+ 		stopTimers();		
+ 		setStatus(BACKOFF);
+ 
+ 		backoff_timer.resched(backoff_time);
+ 	}
+ 
+ }
+ 
+ void SFAMA::processDATA(Packet* data_pkt)
+ {
+ 	//hdr_SFAMA* SFAMAh = hdr_SFAMA::access(data_pkt);
+ 	hdr_mac* mach = HDR_MAC(data_pkt);
+ 
+ 	if( mach->macDA() == index_ && getStatus() == WAIT_RECV_DATA ) {
+ 		//send ACK
+ 		stopTimers();
+ 		setStatus(WAIT_SEND_ACK);
+ 
+ 		wait_send_timer.pkt_ = makeACK(mach->macSA());
+ 		wait_send_timer.resched(getTime2ComingSlot(NOW));
+ 
+ 		/*send packet to upper layer*/		
+ 		hdr_cmn::access(data_pkt)->size() -= hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_DATA);
+ 		sendUp(data_pkt->copy()); /*the original one will be released*/
+ 	}
+ 	else {
+ 		//do backoff
+ 		Time backoff_time = 1+getTime2ComingSlot(NOW) /*for ack*/;
+ 
+ 		stopTimers();		
+ 		setStatus(BACKOFF);
+ 
+ 		backoff_timer.resched(backoff_time);
+ 	}
+ }
+ 
+ 
+ void SFAMA::processACK(Packet* ack_pkt)
+ {
+ 	//hdr_SFAMA* SFAMAh = hdr_SFAMA::access(ack_pkt);
+ 	hdr_mac* mach = HDR_MAC(ack_pkt);
+ #ifdef SFAMA_DEBUG
+ 	printf("processACK(before) \n");
+ 	printAllQ();
+ 	printf("Status is %d", getStatus());
+ #endif
+ 	if( mach->macDA() == index_ && getStatus() == WAIT_RECV_ACK ) {
+ 		stopTimers();
+ 		setStatus(IDLE_WAIT);
+ 
+ 		//release data packets have been sent successfully
+ 		releaseSentPkts();
+ 
+ 		//start to prepare for sending next DATA packet
+ 		prepareSendingDATA();
+ 	}
+ 	/*
+ 	 * consider the multi-hop case, cannot stop timers here
+ 	else {
+ 		stopTimers();
+ 		setStatus(IDLE_WAIT);
+ 
+ 		//release data packets have been sent successfully
+ 		prepareSendingDATA();	
+ 	}
+ 	*/
+ #ifdef SFAMA_DEBUG
+ 	printf("processACK(after) \n");
+ 	printAllQ();
+ #endif
+ }
+ 
+ 
+ 
+ void SFAMA::stopTimers()
+ {
+ 	wait_send_timer.stop();
+ 	wait_reply_timer.stop();
+ 	backoff_timer.stop();
+ }
+ 
+ 
+ 
+ void SFAMA::releaseSentPkts()
+ {
+ 	Packet* tmp = NULL;
+ 	
+ 	while( !SendingPktQ_.empty() ) {
+ 		tmp = SendingPktQ_.front();
+ 		SendingPktQ_.pop();
+ 		Packet::free(tmp);	
+ 	}
+ }
+ 
+ 
+ void SFAMA::prepareSendingDATA()
+ {
+ 	queue<Packet*> tmpQ_;
+ 	Packet* tmp_pkt;
+ 	nsaddr_t recver_addr;
+ 	int pkt_num = 1;
+ 
+ 	if( SendingPktQ_.empty() && CachedPktQ_.empty() ) {
+ 		return;
+ 	}
+ 
+ 	if( !SendingPktQ_.empty() && getStatus() == IDLE_WAIT  ) {
+ 		recver_addr = HDR_MAC(SendingPktQ_.front())->macDA();
+ 
+ 	} else if( !CachedPktQ_.empty() && getStatus() == IDLE_WAIT ) {
+ #ifdef SFAMA_DEBUG
+ 	printf("prepareSendingDATA(before) \n");
+ 	printAllQ();
+ #endif
+ 		tmp_pkt = CachedPktQ_.front();
+ 		recver_addr = HDR_MAC(tmp_pkt)->macDA();
+ 		CachedPktQ_.pop();
+ 		SendingPktQ_.push(tmp_pkt);
+ 		pkt_num = 1;
+ 
+ 		/*get at most max_burst_ DATA packets with same receiver*/
+ 		while( (pkt_num < max_burst_) && (!CachedPktQ_.empty()) ) {
+ 			tmp_pkt = CachedPktQ_.front();
+ 			CachedPktQ_.pop();
+ 
+ 			if( recver_addr == HDR_MAC(tmp_pkt)->macDA() ) {
+ 				SendingPktQ_.push(tmp_pkt);
+ 				pkt_num ++;
+ 			}
+ 			else {
+ 				tmpQ_.push(tmp_pkt);
+ 			}
+ 		
+ 		}
+ 
+ 		//make sure the rest packets are stored in the original order
+ 		while( !CachedPktQ_.empty() ) {
+ 			tmpQ_.push(CachedPktQ_.front());
+ 			CachedPktQ_.pop();		
+ 		}
+ 
+ 		while( !tmpQ_.empty() ) {
+ 			CachedPktQ_.push(tmpQ_.front());
+ 			tmpQ_.pop();
+ 		}
+ 		
+ #ifdef SFAMA_DEBUG
+ 	printf("prepareSendingDATA(after) \n");
+ 	printAllQ();
+ #endif
+ 	}
+ 	
+ 
+ 	Time additional_txtime = getPktTrainTxTime()-
+ 			getTxTime(hdr_SFAMA::getSize(hdr_SFAMA::SFAMA_CTS));
+ 		
+ 
+ 	scheduleRTS(recver_addr, int(additional_txtime/slot_len_)+1 /*for ceil*/
+ 	+1/*the basic slot*/ );
+ }
+ 
+ 
+ Time SFAMA::getPktTrainTxTime()
+ {
+ 	Time txtime = 0.0;
+ 
+ 	int q_size = SendingPktQ_.size();
+ #ifdef SFAMA_DEBUG
+ 	printf("getPktTrainTxTime(before) \n");
+ 	printAllQ();
+ #endif
+ 	for(int i=0; i<q_size; i++ ) {
+ 		txtime += hdr_cmn::access(SendingPktQ_.front())->txtime();
+ 		SendingPktQ_.push(SendingPktQ_.front());
+ 		SendingPktQ_.pop();
+ 	}
+ #ifdef SFAMA_DEBUG
+ 	printf("getPktTrainTxTime(after) \n");
+ 	printAllQ();
+ #endif
+ 	
+ 	txtime += (q_size-1)*data_sending_interval_;
+ 
+ 	return txtime;
+ }
+ 
+ 
+ 
+ void SFAMA::scheduleRTS(nsaddr_t recver, int slot_num)
+ {
+ 	Time backoff_time = randBackoffSlots()*slot_len_+getTime2ComingSlot(NOW);
+ 	setStatus(WAIT_SEND_RTS);
+ 	wait_send_timer.pkt_ = makeRTS(recver, slot_num);
+ 	wait_send_timer.resched(backoff_time);
+ }
+ 
+ 
+ 
+ int SFAMA::randBackoffSlots()
+ {
+ 	return Random::integer(max_backoff_slots_);
+ }
+ 
+ 
+ void SFAMA::sendPkt(Packet* pkt)
+ {
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 	hdr_SFAMA* SFAMAh = hdr_SFAMA::access(pkt);
+ 
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+ 	double txtime=cmh->txtime();
+ 	Scheduler& s=Scheduler::instance();
+ 
+ 	//status_handler.is_ack() = false;
+ 	if( SFAMAh->packet_type == hdr_SFAMA::SFAMA_CTS ) {
+ 		status_handler.slotnum() = SFAMAh->SlotNum;
+ 	}
+ 	/*else if ( SFAMAh->packet_type == hdr_SFAMA::SFAMA_ACK ) {
+ 		status_handler.is_ack() = true;
+ 	}*/
+ 	
+ 	switch( n->TransmissionStatus() ) {
+ 		case SLEEP:
+ 			Poweron();
+ 		case IDL:
+ 			n->SetTransmissionStatus(SEND); 
+ 			cmh->timestamp() = NOW;
+ 			#ifdef SFAMA_DEBUG
+ 			printf("%f: node %d send to node %d\n", 
+ 				   NOW, HDR_MAC(pkt)->macSA(), HDR_MAC(pkt)->macDA());
+ 			#endif
+ 			sendDown(pkt);
+ 			s.schedule(&status_handler,&status_event,txtime);
+ 			break;
+ 		case RECV:
+ 			printf("RECV-SEND Collision!!!!!\n");
+ 			Packet::free(pkt);
+ 			//do backoff??
+ 			break;
+ 			
+ 		default:
+ 			//status is SEND, send too fast
+ 			printf("node%d send data too fast\n",index_);
+ 			Packet::free(pkt);
+ 			break;
+ 
+ 	}
+ 
+ 	return;
+ }
+ 
+ 
+ 
+ void SFAMA::CallBackProcess(Event *e)
+ {
+ 	callback_->handle(e);
+ }
+ 
+ void SFAMA::StatusProcess(int slotnum)
+ {
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	n->SetTransmissionStatus(IDL);
+ 	
+ 	
+ 	switch(getStatus()) {
+ 	  case WAIT_SEND_RTS:
+ 		slotnum = 1;
+ 		setStatus(WAIT_RECV_CTS);
+ 		break;
+ 	  case WAIT_SEND_CTS:
+ 		//slotnum += 1;
+ 		setStatus(WAIT_RECV_DATA);
+ 		break;
+ 	  case WAIT_SEND_DATA:
+ 		//cannot reach here
+ 		slotnum = 1;
+ 		setStatus(WAIT_RECV_ACK);
+ 		//wait_reply time has been scheduled.
+ 		return;
+ 	  case WAIT_SEND_ACK:
+ 		WaitReplyTimerProcess(true); //go to next round
+ 		return;
+ 	  default:
+ 		#ifdef SFAMA_DEBUG
+ 		switch (getStatus() ) {
+ 		  case IDLE_WAIT:
+ 		  printf("node %d: status error: %s!\n", index_,"IDLE_WAIT");
+ 		  break;
+ 		  case WAIT_RECV_CTS:
+ 			printf("node %d: status error: %s!\n", index_,"WAIT_RECV_CTS");
+ 			break;
+ 		  case WAIT_RECV_DATA:
+ 			printf("node %d: status error: %s!\n", index_,"WAIT_RECV_DATA");
+ 			break;
+ 		  case BACKOFF:
+ 			printf("node %d: status error: %s!\n", index_,"BACKOFF");
+ 			break;
+ 		}
+ 		#endif
+ 		break;
+ 	  
+ 	} 
+ 	
+ // 	Time time2comingslot = getTime2ComingSlot(NOW);
+ // 	if ( time2comingslot <  0.1 ) {
+ // 	  slotnum++; 
+ // 	}
+ 	
+ 	//if( ! status_handler.is_ack() ) {
+ 		wait_reply_timer.resched(slot_len_*slotnum+getTime2ComingSlot(NOW));
+ 	//}
+ 	/*else {
+ 	  status_handler.is_ack() = false;
+ 	}*/
+ 	
+ 	return;
+ }
+ 
+ void SFAMA::BackoffTimerProcess()
+ {
+ 	setStatus(IDLE_WAIT);
+ 	prepareSendingDATA();
+ }
+ 
+ void SFAMA::WaitSendTimerProcess(Packet *pkt)
+ {
+ 		
+ 	if( NULL == pkt ) {
+ 		datasend_timer.resched(0.00001);
+ 	}
+ 	else {
+ 		sendPkt(pkt);
+ 	}
+ }
+ 
+ void SFAMA::WaitReplyTimerProcess(bool directcall)
+ {
+ 	/*do backoff*/
+ 	Time backoff_time = randBackoffSlots()*slot_len_ + getTime2ComingSlot(NOW);
+ 	#ifdef SFAMA_DEBUG
+ 	if( !directcall ) 
+ 	  printf("%f node %d TIME OUT!!!!!\n", NOW, index_);
+ 	#endif  //SFAMA_DEBUG
+ 	if( directcall ) {
+ 		setStatus(BACKOFF_FAIR);
+ 		backoff_timer.resched(getTime2ComingSlot(NOW));
+ 	} else {
+ 		setStatus(BACKOFF);
+ 		backoff_timer.resched(backoff_time);
+ 	}
+ 	
+ 	
+ }
+ 
+ 
+ void SFAMA::DataSendTimerProcess()
+ {	
+   
+ #ifdef SFAMA_DEBUG
+ 	printf("DataSendTimerProcess(before) \n");
+ 	printAllQ();
+ #endif
+ 	if( !SendingPktQ_.empty() ) {
+ 		Packet* pkt = SendingPktQ_.front();
+ 		Time txtime = hdr_cmn::access(pkt)->txtime();
+ 		Backup_SendingPktQ_.push(pkt);
+ 
+ 		SendingPktQ_.pop();
+ 
+ 		sendDataPkt(pkt->copy());
+ 
+ 		datasend_timer.resched(data_sending_interval_+txtime);
+ 	}
+ 	else {
+ 	  while( !Backup_SendingPktQ_.empty() ) {
+ 		//push all packets into SendingPktQ_. After getting ack, release them
+ 		SendingPktQ_.push(Backup_SendingPktQ_.front());
+ 		Backup_SendingPktQ_.pop();
+ 	  }
+ 	  //status_handler.is_ack() = false;
+ 	  Scheduler::instance().schedule(&status_handler,&status_event, 0.0000001);
+ 	  /*
+ 		UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 		n->SetTransmissionStatus(IDL); 
+ 		wait_reply_timer.resched(slot_len_+getTime2ComingSlot(NOW));
+ 			switch(getStatus()) {
+ 			  case WAIT_SEND_RTS:
+ 				setStatus(WAIT_RECV_CTS);
+ 				break;
+ 			  case WAIT_SEND_CTS:
+ 				setStatus(WAIT_RECV_DATA);
+ 				break;
+ 			  case WAIT_SEND_DATA:
+ 				setStatus(WAIT_RECV_ACK);
+ 				break;
+ 			  default:
+ 				printf("status error!\n");
+ 				break;
+ 			  
+ 			} 
+ 			*/
+ 	}
+ #ifdef SFAMA_DEBUG
+ 	printf("DataSendTimerProcess(after) \n");
+ 	printAllQ();
+ #endif
+ }
+ 
+ 
+ void SFAMA::sendDataPkt(Packet* pkt)
+ {
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 	//hdr_FAMA* FAMAh = hdr_FAMA::access(pkt);
+ 
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	
+ 	switch( n->TransmissionStatus() ) {
+ 		case SLEEP:
+ 			Poweron();
+ 		case IDL:
+ 			n->SetTransmissionStatus(SEND); 
+ 			cmh->timestamp() = NOW;
+ 			#ifdef SFAMA_DEBUG
+ 			printf("%f: node %d send to node %d\n", 
+ 				   NOW, HDR_MAC(pkt)->macSA(), HDR_MAC(pkt)->macDA());
+ 			#endif
+ 			sendDown(pkt);
+ 			break;
+ 		case RECV:
+ 			printf("RECV-SEND Collision!!!!!\n");
+ 			Packet::free(pkt);
+ 			//do backoff??
+ 			break;
+ 			
+ 		default:
+ 			//status is SEND, send too fast
+ 			printf("node%d send data too fast\n",index_);
+ 			Packet::free(pkt);
+ 			break;
+ 	}
+ 
+ 	return;
+ }
+ 
+ void SFAMA::setStatus(enum SFAMA_Status status)
+ {
+ 	if( status == BACKOFF ) {
+ 	  status = status;
+ 	}
+     status_ = status;
+ }
+ 
+ enum SFAMA_Status SFAMA::getStatus()
+ {
+     return status_;
+ }
+ 
+ 
+ #ifdef SFAMA_DEBUG
+ void SFAMA::printAllQ(){
+ printf("Time %f node %d . CachedPktQ_:\n", NOW, index_);
+ printQ(CachedPktQ_);
+ printf("\nSendingPktQ_:\n");
+ printQ(SendingPktQ_);
+ printf("\n");
+ 
+   
+ }
+ void SFAMA::printQ(queue< Packet* >& my_q)
+ {
+ 	queue<Packet*> tmp_q;
+ 	while(!my_q.empty()) {
+ 		printf("%d\t", HDR_CMN(my_q.front())->uid());
+ 		tmp_q.push(my_q.front());
+ 		my_q.pop();
+ 	}
+ 	
+ 	while(!tmp_q.empty()) {
+ 	  my_q.push(tmp_q.front());
+ 	  tmp_q.pop();
+ 	}
+ }
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_mac/slotted-fama/sfama.h ns-2.35-aquasim/underwatersensor/uw_mac/slotted-fama/sfama.h
*** ns-2.35/underwatersensor/uw_mac/slotted-fama/sfama.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/slotted-fama/sfama.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,262 ----
+ #ifndef __sfama_h__
+ #define __sfama_h__
+ 
+ #include <packet.h>
+ #include <random.h>
+ #include <timer-handler.h>
+ 
+ #include <mac.h>
+ #include "underwatersensor/uw_mac/underwatermac.h"
+ #include "underwatersensor/uw_mac/underwaterchannel.h"
+ #include "underwatersensor/uw_mac/underwaterpropagation.h"
+ 
+ #include "sfama-pkt.h"
+ 
+ #include <queue>
+ #include <vector>
+ #include <set>
+ using namespace std;
+ 
+ typedef double Time;
+ 
+ //#define SFAMA_DEBUG
+ 
+ class SFAMA;
+ 
+ 
+ 
+ class SFAMA_Wait_Send_Timer: public TimerHandler {
+   friend class SFAMA;
+ public:
+ 	SFAMA_Wait_Send_Timer(SFAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 		pkt_ = NULL;
+ 	}
+ 
+ 	void stop() {
+ 		if( pkt_ != NULL ) {
+ 			Packet::free(pkt_);
+ 			pkt_ = NULL;
+ 		}
+ 		if( this->status() == TIMER_PENDING ) {
+ 			cancel();
+ 		}
+ 	}
+ 
+ protected:
+ 	SFAMA* mac_;
+ 	Packet* pkt_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class SFAMA_Wait_Reply_Timer: public TimerHandler {
+ public:
+ 	SFAMA_Wait_Reply_Timer(SFAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 
+ 	void stop() {
+ 		if( this->status() == TIMER_PENDING ) {
+ 			cancel();
+ 		}
+ 	}
+ 
+ protected:
+ 	SFAMA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class SFAMA_Backoff_Timer: public TimerHandler{
+ public:
+ 	SFAMA_Backoff_Timer(SFAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 
+ 	void stop() {
+ 		if( this->status() == TIMER_PENDING ) {
+ 			cancel();
+ 		}
+ 		
+ 	}
+ 
+ protected:
+ 	SFAMA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ 
+ class SFAMA_CallBackHandler: public Handler{
+ public:
+ 	SFAMA_CallBackHandler(SFAMA* mac): Handler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	SFAMA* mac_;
+ 	virtual void handle(Event* e);
+ };
+ 
+ class SFAMA_SlotInitHandler: public Handler {
+ public:
+ 	SFAMA_SlotInitHandler(SFAMA* mac): Handler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	SFAMA* mac_;
+ 	virtual void handle(Event* e);
+ };
+ 
+ class SFAMA_MAC_StatusHandler: public Handler{
+ public:
+ 	SFAMA_MAC_StatusHandler(SFAMA* mac): Handler() {
+ 		mac_ = mac;
+ 	}
+ 	int& slotnum() { return slotnum_; }
+ protected:
+ 	SFAMA* mac_;
+ 	int		slotnum_;
+ 	virtual void handle(Event* e);
+ };
+ 
+ 
+ class SFAMA_DataSend_Timer: public TimerHandler{
+ public:
+ 	SFAMA_DataSend_Timer(SFAMA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	SFAMA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ enum SFAMA_Status{
+     IDLE_WAIT,  /*do nothing but just wait*/
+     WAIT_SEND_RTS,
+     WAIT_SEND_CTS,
+     WAIT_RECV_CTS,
+     WAIT_SEND_DATA,
+     WAIT_RECV_DATA,
+     WAIT_SEND_ACK,
+     WAIT_RECV_ACK,
+     BACKOFF,
+ 	BACKOFF_FAIR
+ };
+ 
+ class SFAMA: public UnderwaterMac{
+ public:
+ 	SFAMA();
+ 	int  command(int argc, const char*const* argv);
+ 	// to process the incomming packet
+ 	virtual  void RecvProcess(Packet*);
+ 	// to process the outgoing packet
+ 	virtual  void TxProcess(Packet*);
+ 
+ 
+ 	enum SFAMA_Status status_;
+ 
+ 
+ 	void CallBackProcess(Event* e);
+ 	void StatusProcess(int slotnum);
+ 
+ 	void WaitSendTimerProcess(Packet* pkt);
+ 	void BackoffTimerProcess();
+ 	void WaitReplyTimerProcess(bool directcall=false);
+ 	void DataSendTimerProcess();
+ 
+ 	void initSlotLen();
+ 
+ private:
+ 	//index_ is the mac address of this node
+ 	Time guard_time_;  //need to be binded
+ 	Time slot_len_;
+ 
+ 	bool is_in_round;
+ 	bool is_in_backoff;
+ 
+ 	int max_backoff_slots_;
+ 
+ 	int max_burst_; /*maximum number of packets in the train*/
+ 	int data_sending_interval_;
+ 
+ 
+ 	SFAMA_CallBackHandler callback_handler;
+ 	SFAMA_MAC_StatusHandler status_handler;
+ 	SFAMA_SlotInitHandler slotinit_handler;
+ 
+ 	Event	callback_event;
+ 	Event	status_event;	
+ 	Event	slotinit_event;
+ 
+ 	//wait to send pkt at the beginning of next slot
+ 	SFAMA_Wait_Send_Timer wait_send_timer; 
+ 	//wait for the corresponding reply. Timeout if fail to get
+ 	SFAMA_Wait_Reply_Timer wait_reply_timer; 
+ 	//if there is a collision or RTS/CTS not for this node, do backoff
+ 	SFAMA_Backoff_Timer    backoff_timer; 
+ 
+ 	SFAMA_DataSend_Timer	datasend_timer;
+ 
+ 	queue<Packet*> SendingPktQ_;
+ 	queue<Packet*> CachedPktQ_;
+ 	queue<Packet*> Backup_SendingPktQ_;
+ 
+ 	//packet_t UpperLayerPktType;
+ 	
+ protected:
+ 	Packet* makeRTS(nsaddr_t recver, int slot_num);
+ 	Packet* makeCTS(nsaddr_t rts_sender, int slot_num);
+ 	Packet* fillDATA(Packet* data_pkt);
+ 	Packet* makeACK(nsaddr_t data_sender);
+ 
+ 	
+ 	void processRTS(Packet* rts_pkt);
+ 	void processCTS(Packet* cts_pkt);
+ 	void processDATA(Packet* data_pkt);
+ 	void processACK(Packet* ack_pkt);
+ 
+ 	void doBackoff(int backoff_slotnum);
+ 
+ 	void sendPkt(Packet* pkt);
+ 	void sendDataPkt(Packet* pkt);
+ 
+ 	void setStatus(enum SFAMA_Status status);
+ 	enum SFAMA_Status getStatus();
+ 
+ 	void stopTimers();
+ 	void releaseSentPkts();
+ 
+ 	void prepareSendingDATA();
+ 
+ 	Time getPktTrainTxTime();
+ 
+ 	void scheduleRTS(nsaddr_t recver, int slot_num);
+ 
+ 
+ 	//Time getTxtimeByPktSize(int pkt_size);
+ 	Time getTime2ComingSlot(Time t);
+ 
+ 
+ 	int randBackoffSlots();
+ 	
+ 	
+ #ifdef SFAMA_DEBUG
+ 	void printQ(queue<Packet*>& my_q);
+ 	void printAllQ();
+ #endif
+ 	
+ 
+ 
+ 
+ 
+ 	friend class SFAMA_CallBackHandler;
+ 	friend class SFAMA_Backoff_Timer;
+ 	friend class SFAMA_MAC_StatusHandler;
+ 	friend class SFAMA_Wait_Send_Timer;
+ 	friend class SFAMA_Wait_Reply_Timer;
+ 	friend class SFAMA_DataSend_Timer;
+ 
+ };
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_mac/slotted-fama/sfama-pkt.h ns-2.35-aquasim/underwatersensor/uw_mac/slotted-fama/sfama-pkt.h
*** ns-2.35/underwatersensor/uw_mac/slotted-fama/sfama-pkt.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/slotted-fama/sfama-pkt.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,40 ----
+ #ifndef __sfama_pkt_h__
+ #define __sfama_pkt_h__
+ 
+ #include <packet.h>
+ 
+ struct hdr_SFAMA{
+ 	//nsaddr_t SA;
+ 	//nsaddr_t DA;
+ 
+ 	u_int16_t	SlotNum;  //the number of slots required for transmitting the DATA packet
+ 
+ 	enum PacketType {
+ 		SFAMA_RTS,
+ 		SFAMA_CTS,
+ 		SFAMA_DATA,
+ 		SFAMA_ACK
+ 	} packet_type;
+ 
+ 	static int getSize(enum PacketType p_type) {
+ 
+ 		int pkt_size = 2*sizeof(nsaddr_t); //source and destination addr in hdr_mac
+ 
+ 		if( p_type == SFAMA_RTS || p_type == SFAMA_CTS ) {
+ 			pkt_size += sizeof(u_int16_t)+1; //size of packet_type and slotnum
+ 		}
+ 		
+ 		return pkt_size;
+ 	}
+ 
+ 	static int offset_;
+ 	inline static int& offset() {  return offset_; }
+ 
+ 	inline static hdr_SFAMA* access(const Packet*  p) {
+ 		return (hdr_SFAMA*) p->access(offset_);
+ 	}
+ 
+ };
+ 
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_mac/tmac.cc ns-2.35-aquasim/underwatersensor/uw_mac/tmac.cc
*** ns-2.35/underwatersensor/uw_mac/tmac.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/tmac.cc	2016-09-03 00:41:19.280000000 +0800
***************
*** 0 ****
--- 1,2307 ----
+ #include "packet.h"
+ #include "random.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "underwatersensor/uw_routing/vectorbasedforward.h"
+ #include "mac.h"
+ #include "tmac.h"
+ #include "underwaterphy.h"
+ #include "random.h"
+ #include "underwatermac.h"
+ 
+ int hdr_tmac::offset_;
+ 
+ static class TMACHeaderClass: public PacketHeaderClass{
+  public:
+   TMACHeaderClass():PacketHeaderClass("PacketHeader/TMAC",sizeof(hdr_tmac))
+ {
+  bind_offset(&hdr_tmac::offset_);
+ }
+ } class_tmachdr;
+ 
+ 
+ //TBackoffHandler::TBackoffHandler(TMac* p):mac_(p),window_(0),counter_(0){}
+  
+ void TBackoffHandler::handle(Event*e)
+ {
+   counter_++;
+   if(counter_<MAXIMUMBACKOFF)
+     mac_->TxND((Packet*)e, window_);
+   else 
+     {
+     clear();
+   printf("Rmac:backoff:too many backoffs\n");
+   Packet::free((Packet*)e);
+     }
+ }
+  // void SetStartTime(double);
+ void TBackoffHandler::clear(){
+ counter_=0;
+ }
+ 
+ 
+ 
+ //TStatusHandler::TStatusHandler(TMac* p):mac_(p),status_(SLEEP){}
+ void TStatusHandler::handle(Event* e)
+ {
+   if(status_!=SLEEP) mac_->StatusProcess(e,status_);
+   else mac_->Poweroff();
+ }
+ 
+ 
+ void TStatusHandler::SetStatus(TransmissionStatus  status)
+ {
+   status_=status;
+ }
+ 
+ 
+ 
+ //TSYNHandler::TSYNHandler(TMac* p): mac_(p){}
+ 
+ void 
+ TSYNHandler::handle(Event* e)
+ {
+   printf("SYNHandler: node%d handle syn\n",mac_->index_);
+   mac_->TxND((Packet*) e, mac_->PhaseTwo_window_);
+ }
+ 
+ 
+ 
+ //TNDHandler::TNDHandler(TMac* p):mac_(p){}
+ 
+ void TNDHandler::handle(Event* e)
+ {  
+   
+     mac_->cycle_start_time=NOW;
+     mac_->SendND(mac_->short_packet_size_);
+ }
+ 
+ 
+ //TACKNDWindowHandler::TACKNDWindowHandler(TMac* p):mac_(p){}
+ 
+ void TACKNDWindowHandler::handle(Event* e)
+ { 
+    mac_->SendShortAckND();
+ }
+ 
+ 
+ //TACKNDHandler::TACKNDHandler(TMac* p):mac_(p){}
+ 
+ void TACKNDHandler::handle(Event* e)
+ { 
+     mac_->TxND((Packet*) e, mac_->ACKND_window_);
+ }
+ 
+ 
+ 
+ //TPhaseOneHandler::TPhaseOneHandler(TMac* p):mac_(p){}
+ 
+ void TPhaseOneHandler::handle(Event* e)
+ { 
+     mac_->InitPhaseOne(mac_->ND_window_,mac_->ACKND_window_, mac_->PhaseOne_window_);
+ }
+ 
+ 
+ 
+ //TPhaseTwoHandler::TPhaseTwoHandler(TMac* p):mac_(p){}
+ 
+ void TPhaseTwoHandler::handle(Event* e)
+ { 
+     mac_->SendSYN();
+ }
+ 
+ //TPhaseThreeHandler::TPhaseThreeHandler(TMac* p):mac_(p){}
+ 
+ void TPhaseThreeHandler::handle(Event* e)
+ { 
+     mac_->InitPhaseThree();
+ }
+ 
+ 
+ //SilenceHandler::SilenceHandler(TMac* p): mac_(p){}
+ 
+ void 
+ SilenceHandler::handle(Event* e)
+ {
+   printf("SilenceHandler: node%d handle silence\n",mac_->index_);
+   mac_->ProcessSilence();
+ }
+ 
+ 
+ //ACKHandler::ACKHandler(TMac* p): mac_(p){}
+ 
+ void 
+ ACKHandler::handle(Event* e)
+ {
+   mac_->SendACKPacket();
+ }
+ 
+ 
+ 
+ //PoweroffHandler::PoweroffHandler(TMac* p): mac_(p){}
+ 
+ void 
+ PoweroffHandler::handle(Event* e)
+ {
+  mac_->ResetMacStatus();  
+ }
+ 
+ 
+ //TTimeoutHandler::TTimeoutHandler(TMac* p): mac_(p){}
+ 
+ void 
+ TTimeoutHandler::handle(Event* e)
+ {
+   mac_->SetIdle();
+ }
+ 
+ //RTSTimeoutHandler::RTSTimeoutHandler(TMac* p): mac_(p){num=0;}
+ 
+ void 
+ RTSTimeoutHandler::handle(Event* e)
+ {
+   printf("rts_timeout_handler: node %d timeout %d times\n",mac_->index_,num);
+   num++;
+   if(num<2)
+   mac_->SendRTS();
+   else
+     {
+       num=0;
+       mac_->ProcessSleep();
+     }
+ }
+ 
+ 
+ 
+ //TxHandler::TxHandler(TMac* p):mac_(p), receiver(0){}
+  
+ void TxHandler::handle(Event*e)
+ {
+   
+   mac_->TxData(receiver);
+ }
+ 
+ 
+ //TWakeupHandler::TWakeupHandler(TMac* p): mac_(p){}
+ 
+ void 
+ TWakeupHandler::handle(Event* e)
+ {
+   mac_->Wakeup();
+ }
+ 
+ 
+ //RTSHandler::RTSHandler(TMac* p):mac_(p){receiver_addr=0;}
+  
+ void RTSHandler::handle(Event*e)
+ {
+    printf("rts_handler: node %d rts handelr\n",mac_->index_);
+   mac_->TxRTS(e,receiver_addr);
+ }
+ 
+ 
+ /*
+ RTSSilenceHandler::RTSSilenceHandler(TMac* p):mac_(p){start_time=0;duration=0;}
+  
+ void RTSSilenceHandler::handle(Event*e)
+ {
+   mac_->ProcessRTSSilence();
+ }
+ */
+ 
+ 
+ 
+ 
+ //CTSHandler::CTSHandler(TMac* p):mac_(p),num(0){}
+  
+ void CTSHandler::handle(Event*e)
+ {
+   num++;
+   mac_->TxCTS((Packet *)e);
+ }
+ 
+ 
+ 
+ /* ======================================================================
+     TMAC for  underwater sensor
+     Implementation of TMAC in underwater scenarios 
+ 
+    ====================================================================== */
+ static class TMacClass : public TclClass {
+ public:
+  TMacClass():TclClass("Mac/UnderwaterMac/TMac") {}
+    TclObject* create(int, const char*const*) {
+ 	  return (new TMac());
+    }
+ } class_tmac;
+ 
+ 
+ TMac::TMac():UnderwaterMac(),short_nd_handler(this),short_acknd_window_handler(this), status_handler(this), phaseone_handler(this),acknd_handler(this), phasetwo_handler(this), phasethree_handler(this), wakeup_handler(this),timeout_handler(this),transmission_handler(this),ackdata_handler(this), rts_timeout_handler(this),backoff_handler(this),silence_handler(this),ack_handler(this),poweroff_handler(this),rts_handler(this),cts_handler(this),syn_handler(this)
+ {
+   num_send=0;
+   num_data=0;
+   large_packet_size_=30;
+   short_packet_size_=10;
+  
+   short_latency_table_index=0;
+   
+   InitializeSilenceTable();
+  
+ 
+   period_table_index=0;
+ 
+   next_period=0;  
+  
+   last_silenceTime=0;  
+   last_rts_silenceTime=0;
+   
+   
+  for(int i=0;i<TABLE_SIZE;i++){
+ 
+ 
+     short_latency_table[i].node_addr=-1;
+     short_latency_table[i].num=0;
+     short_latency_table[i].last_update_time=0.0;
+ 
+     period_table[i].node_addr=-1;
+     period_table[i].difference=0.0;
+     period_table[i].last_update_time=0.0; 
+   }
+ 
+     arrival_table_index=0; 
+   for(int i=0;i<TABLE_SIZE;i++)
+     arrival_table[i].node_addr=-1;
+  
+   bind("PhaseOne_window_",&PhaseOne_window_);
+   bind("PhaseTwo_window_",&PhaseTwo_window_);
+   bind("duration_",&duration_);
+   bind("ND_window_",&ND_window_); 
+   bind("PhaseTwo_interval_",&PhaseTwo_interval_);
+   bind("ACKND_window_",&ACKND_window_); 
+   bind("PhyOverhead_",&PhyOverhead_);
+   bind("large_packet_size_",&large_packet_size_);
+   bind("short_packet_size_",&short_packet_size_);
+   bind("PhaseOne_cycle_",&PhaseOne_cycle_);
+    bind("PhaseTwo_cycle_",&PhaseTwo_cycle_);
+   bind("IntervalPhase2Phase3_",&IntervalPhase2Phase3_);
+   bind("PeriodInterval_",&PeriodInterval_);
+   bind("transmission_time_error_",&transmission_time_error_);
+   bind("SIF_",&SIF_);
+   
+   bind("ContentionWindow_",&ContentionWindow_);
+   bind ("TransmissionRange_",&TransmissionRange_);
+  
+ 
+    max_short_packet_transmissiontime=((1.0*short_packet_size_)/bit_rate_)*(1+transmission_time_error_);
+    max_large_packet_transmissiontime=((1.0*large_packet_size_)/bit_rate_)*(1+transmission_time_error_);
+       
+    MinBackoffWindow=max_large_packet_transmissiontime;
+   
+ 
+ 
+    max_propagationTime=TransmissionRange_/1500+max_short_packet_transmissiontime;
+    TAduration_=(ContentionWindow_+max_short_packet_transmissiontime
+ 	      +max_propagationTime*2)*1.5;
+   InitPhaseOne(ND_window_,ACKND_window_, PhaseOne_window_);
+   
+ }
+ 
+ void 
+ TMac::InitPhaseOne(double t1,double t2, double t3)
+ {
+   
+    printf("TMac: Phaseone cycle: %d...\n",PhaseOne_cycle_);
+ 
+    if(PhaseOne_cycle_)
+     { 
+     PhaseStatus=PHASEONE;
+     Scheduler& s=Scheduler::instance();
+     InitND(t1,t2,t3);
+     s.schedule(&phaseone_handler,&phaseone_event,t3);
+     PhaseOne_cycle_--;
+     return;
+     }
+   
+  
+    InitPhaseTwo();
+    return;
+ }
+ 
+ /*
+ void 
+ TMac::InitPhaseTwo(){
+ 
+    double delay=Random::uniform()*PhaseTwo_window_;
+    PhaseStatus=PHASETWO;
+ 
+     cycle_start_time=NOW;
+     //  next_period=IntervalPhase2Phase3_+PhaseTwo_window_+delay;
+     next_period=IntervalPhase2Phase3_+PhaseTwo_window_;
+  
+    
+     Scheduler& s=Scheduler::instance();
+     s.schedule(&phasetwo_handler, &phasetwo_event,delay);
+     s.schedule(&phasethree_handler,&phasethree_event,next_period);
+     printf("tmac initphasetwo: the phasethree of node %d is scheduled at %f\n",index_,NOW+next_period);
+  
+     return;
+ }
+ */
+ 
+ 
+ void 
+ TMac::InitPhaseTwo(){
+ 
+   //   double delay=Random::uniform()*PhaseTwo_window_;
+   //  next_period=IntervalPhase2Phase3_+PhaseTwo_cycle_*PhaseTwo_window_+delay;
+   next_period=IntervalPhase2Phase3_+PhaseTwo_cycle_*PhaseTwo_window_;
+    Scheduler& s=Scheduler::instance();
+    s.schedule(&phasethree_handler, &phasethree_event,next_period);
+   
+    StartPhaseTwo();
+     return;  
+ }
+ 
+ void 
+ TMac::StartPhaseTwo()
+ {
+   printf("Phase Two: node %d  and cycle:%d\n",index_, PhaseTwo_cycle_);
+    if(PhaseTwo_cycle_)
+     {     
+      PhaseStatus=PHASETWO;
+      cycle_start_time=NOW;
+     double  delay=Random::uniform()*PhaseTwo_window_; 
+     Packet* pkt=GenerateSYN();
+     Scheduler& s=Scheduler::instance();
+     s.schedule(&syn_handler,(Event*) pkt, delay);    
+     s.schedule(&phasetwo_handler,&phasetwo_event,PhaseTwo_window_+PhaseTwo_interval_);
+     next_period-=PhaseTwo_window_-PhaseTwo_interval_;
+     PhaseTwo_cycle_--;
+     }
+    return;   
+ }
+ 
+ 
+ 
+ Packet*  
+ TMac::GenerateSYN(){
+ 
+        Packet* pkt =Packet::alloc();
+        hdr_tmac* synh = HDR_TMAC(pkt); 
+        hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+        cmh->size()=short_packet_size_;
+        cmh->next_hop()=MAC_BROADCAST;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_RMAC;
+       
+       
+        synh->ptype=P_SYN;
+        synh->pk_num = num_send;
+        synh->sender_addr= node_->address();
+      
+        synh->duration=duration_;
+         num_send++;
+ 
+ 	printf("rmac GenerateSYN:node(%d) generates SYN packet at %f\n", synh->sender_addr,NOW);
+ 	return pkt; 
+ }
+ 
+ 
+ 
+ void 
+ TMac::SendSYN(){
+ 
+        Packet* pkt =Packet::alloc();
+        hdr_tmac* synh = HDR_TMAC(pkt); 
+        hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+        cmh->size()=short_packet_size_;
+        cmh->next_hop()=MAC_BROADCAST;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_TMAC;
+       
+       
+        synh->ptype=P_SYN;
+        synh->pk_num = num_send;
+        synh->sender_addr= node_->address();
+      
+        synh->duration=duration_;
+         num_send++;
+ 
+ 	printf("tmac SendSYN:node(%d) send SYN packet at %f\n", synh->sender_addr,NOW);
+       TxND(pkt, PhaseTwo_window_);  
+ }
+ 
+ 
+ void 
+ TMac::InitND(double t1,double t2, double t3)
+ {  
+  
+   double delay=Random::uniform()*t1;
+   double itval=(t3-t2-t1)/2.0;
+   double delay3=t1+itval;
+  
+   Scheduler& s=Scheduler::instance();
+ 
+    s.schedule(&short_nd_handler, &short_nd_event, delay);
+    s.schedule(&short_acknd_window_handler,&short_acknd_event,delay3);
+   return;
+ }
+ 
+ void 
+ TMac::SendND(int pkt_size)
+ {
+ 
+       Packet* pkt =Packet:: alloc();
+       hdr_tmac* ndh = HDR_TMAC(pkt);
+     
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+    
+      // additional 2*8 denotes the size of type,next-hop of the packet and 
+      // timestamp
+   
+       //       cmh->size()=sizeof(hdr_nd)+3*8;
+       //  printf("old size is %d\n",cmh->size());
+         cmh->size()=pkt_size;
+ 
+        cmh->next_hop()=MAC_BROADCAST;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_TMAC;
+       
+        
+      
+       ndh->ptype=P_ND;
+       ndh->pk_num = num_send;
+       ndh->sender_addr= node_->address();
+ 
+       num_send++;
+ 
+       // iph->src_.addr_=node_->address();
+       // iph->dst_.addr_=node_->address();
+       //iph->dst_.port_=255;     
+ 
+  printf("tmac SendND:node(%d) send ND type is %d at %f\n", ndh->sender_addr,cmh->ptype_, NOW);
+       TxND(pkt, ND_window_);  
+ }
+ 
+ 
+ 
+ 
+ 
+ void 
+ TMac::SendShortAckND()
+ {
+     printf("tmac:SendShortND: node %d\n",index_);
+   if (arrival_table_index==0) return;// not ND received
+ 
+ 
+   while(arrival_table_index>0){ 
+       Packet* pkt = Packet::alloc();
+       hdr_tmac* ackndh = HDR_TMAC(pkt);
+     
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+       
+       ackndh->ptype=P_SACKND;
+       ackndh->pk_num = num_send;
+       ackndh->sender_addr=node_->address();
+       num_send++;
+ 
+       cmh->ptype_=PT_TMAC;
+         
+          int index1=-1;
+         index1=rand()%arrival_table_index; 
+         double t2=-0.1;
+         double t1=-0.1;
+     
+         int receiver=arrival_table[index1].node_addr;
+          t2=arrival_table[index1].arrival_time; 
+          t1=arrival_table[index1].sending_time; 
+ 
+ 	 for(int i=index1;i<arrival_table_index;i++){
+ 	   arrival_table[i].node_addr=arrival_table[i+1].node_addr;
+            arrival_table[i].sending_time=arrival_table[i+1].sending_time;
+            arrival_table[i].arrival_time=arrival_table[i+1].arrival_time;
+ 	 }
+    
+           ackndh->arrival_time=t2;
+           ackndh->ts=t1;
+   // additional 2*8 denotes the size of type,next-hop of the packet and 
+   // timestamp
+     //  cmh->size()=sizeof(hdr_ack_nd)+3*8;
+     
+ 
+       cmh->size()=short_packet_size_;
+       cmh->next_hop()=receiver;
+       cmh->direction()=hdr_cmn::DOWN; 
+       cmh->addr_type()=NS_AF_ILINK;
+ 
+       
+          Scheduler& s=Scheduler::instance();
+          double delay=Random::uniform()*ACKND_window_;
+          s.schedule(&acknd_handler, (Event*) pkt, delay);
+ 
+ 	 arrival_table_index--;
+   }
+ 
+ 
+      arrival_table_index=0; 
+   for(int i=0;i<TABLE_SIZE;i++)
+     arrival_table[i].node_addr=-1;
+ 
+           return; 
+ }
+ 
+ 
+ void 
+ TMac::ProcessShortACKNDPacket(Packet* pkt)
+ {
+   // printf("tmac:ProcessshortACKNDPacket: node %d\n",index_);
+     hdr_tmac* ackndh=HDR_TMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int  sender=ackndh->sender_addr;
+     double t4=NOW;
+     double t3=cmh->ts_;
+     int myaddr=node_->address();
+  
+     double t2=ackndh->arrival_time;
+     double t1=ackndh->ts;
+ 
+ double latency=((t4-t1)-(t3-t2))/2.0;
+ bool newone=true;   
+ 
+ Packet::free(pkt);
+    
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (short_latency_table[i].node_addr==sender)
+       {
+        short_latency_table[i].sumLatency+=latency;
+        short_latency_table[i].num++;
+        short_latency_table[i].last_update_time=NOW;
+        short_latency_table[i].latency = 
+                   short_latency_table[i].sumLatency/short_latency_table[i].num;
+        newone=false;
+       }
+  
+  if(newone)
+ {
+ 
+     if(short_latency_table_index>=TABLE_SIZE){ 
+       printf("tmac:ProcessNDPacket:arrival_table is full\n");
+       return;
+     }
+ 
+     short_latency_table[short_latency_table_index].node_addr=sender;
+     short_latency_table[short_latency_table_index].sumLatency+=latency;
+     short_latency_table[short_latency_table_index].num++;
+     short_latency_table[short_latency_table_index].last_update_time=NOW;
+     short_latency_table[short_latency_table_index].latency = 
+           short_latency_table[short_latency_table_index].sumLatency/short_latency_table[short_latency_table_index].num;
+     short_latency_table_index++;
+ }
+  for(int i=0;i<short_latency_table_index;i++)
+    printf("node (%d) to node (%d) short latency is %f and number is %d\n", myaddr, short_latency_table[i].node_addr, short_latency_table[i].latency,short_latency_table[i].num); 
+  
+  return;
+ 
+ }
+ 
+ 
+ 
+ 
+ void 
+ TMac::ProcessSYN(Packet* pkt)
+ {
+   // printf("rmac:ProcessSYN: node %d\n",index_);
+     hdr_tmac* synh=HDR_TMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int  sender=synh->sender_addr;
+     double interval=synh->interval;
+     double tduration=synh->duration;
+       Packet::free(pkt);
+ 
+ 
+     double t1=-1.0;
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (short_latency_table[i].node_addr==sender)
+      t1=short_latency_table[i].latency;
+ 
+  if(t1==-1.0) {
+    printf("Rmac:ProcessSYN: I receive a SYN from unknown neighbor\n");
+    return; 
+  }
+ 
+  interval-=t1;
+  double t2=next_period-(NOW-cycle_start_time);
+  double d=interval-t2;
+ 
+ if (d>=0.0) {
+    while (d>=PeriodInterval_) d-=PeriodInterval_;
+  }
+  else 
+    {
+      while (d+PeriodInterval_<=0.0) d+=PeriodInterval_;
+    }
+ 
+ 
+ 
+  bool newone=true;     
+  
+  if(d<0) d=d+PeriodInterval_;   
+ 
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (period_table[i].node_addr==sender)
+       {
+        period_table[i].difference=d;
+        period_table[i].last_update_time=NOW;
+        period_table[i].duration =tduration; 
+        newone=false;
+       }
+  
+  if(newone)
+ {
+ 
+     if(period_table_index>=TABLE_SIZE){ 
+       printf("rmac:ProcessSYN:period_table is full\n");
+       return;
+     }
+ 
+ 
+     period_table[period_table_index].node_addr=sender;
+     period_table[period_table_index].difference=d;
+     period_table[period_table_index].last_update_time=NOW;
+     period_table[period_table_index].duration=tduration;
+     period_table_index++;
+ }
+ 
+  for(int i=0;i<period_table_index;i++)
+    printf("node (%d) to node (%d) period difference  is %f \n",index_,period_table[i].node_addr, period_table[i].difference); 
+  
+  return;
+ 
+ }
+ 
+ 
+ 
+ /*
+ void 
+ TMac::ProcessSYN(Packet* pkt)
+ {
+   // printf("tmac:ProcessSYN: node %d\n",index_);
+     hdr_tmac* synh=HDR_TMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int  sender=synh->sender_addr;
+     double interval=synh->interval;
+     double tduration=synh->duration;
+       Packet::free(pkt);
+ 
+ 
+     double t1=-1.0;
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (short_latency_table[i].node_addr==sender)
+      t1=short_latency_table[i].latency;
+ 
+  if(t1==-1.0) {
+    printf("TMac:ProcessSYN: I receive a SYN from unknown neighbor\n");
+    return; 
+  }
+ 
+  interval-=t1;
+  double t2=next_period-(NOW-cycle_start_time);
+  double d=interval-t2;
+ 
+ if (d>=0.0) {
+    while (d>=PeriodInterval_) d-=PeriodInterval_;
+  }
+  else 
+    {
+      while (d+PeriodInterval_<=0.0) d+=PeriodInterval_;
+    }
+ 
+ 
+ 
+  bool newone=true;     
+    
+  for (int i=0;i<TABLE_SIZE;i++)
+  if (period_table[i].node_addr==sender)
+       {
+        period_table[i].difference=d;
+        period_table[i].last_update_time=NOW;
+        period_table[i].duration =tduration; 
+        newone=false;
+       }
+  
+  if(newone)
+ {
+ 
+     if(period_table_index>=TABLE_SIZE){ 
+       printf("tmac:ProcessSYN:period_table is full\n");
+       return;
+     }
+ 
+     period_table[period_table_index].node_addr=sender;
+     period_table[period_table_index].difference=d;
+     period_table[period_table_index].last_update_time=NOW;
+     period_table[period_table_index].duration=tduration;
+     period_table_index++;
+ }
+ 
+  for(int i=0;i<period_table_index;i++)
+    printf("node (%d) to node (%d) period difference  is %f \n",index_,period_table[i].node_addr, period_table[i].difference); 
+  
+  return;
+ 
+ }
+ 
+ */
+ 
+ 
+ void
+ TMac::ProcessSleep()
+ {
+   printf("TMac: ProcessSleep node %d at time %f ...\n",index_,NOW); 
+   mac_status=TMAC_IDLE;
+   Poweroff();
+ }
+ 
+ 
+ 
+ /*
+ void 
+ TMac::TxND(Packet* pkt, double window)
+ {
+   //  printf("TMac TxND node %d\n",index_); 
+   hdr_cmn* cmh=HDR_CMN(pkt);
+    hdr_tmac* synh = HDR_TMAC(pkt); 
+   
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  
+   hdr_cmn::access(pkt)->txtime()=(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+   if(SLEEP==n->TransmissionStatus()) {
+   Poweron();
+   n->SetTransmissionStatus(SEND);
+   cmh->ts_=NOW;
+ 
+ 
+   sendDown(pkt);
+   backoff_handler.clear();
+ 
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==n->TransmissionStatus()){
+   
+   n->SetTransmissionStatus(SEND);
+  
+   //printf("TxND the data type is %d\n",MAC_BROADCAST);
+   //printf("broadcast : I am going to send the packet down tx is %f\n",txtime);
+      cmh->ts_=NOW;
+ 
+ 
+     
+   sendDown(pkt);
+   backoff_handler.clear();
+   //  printf("broadcast %d Tx Idle set timer at %f tx is %f\n",node_->nodeid(),NOW,txtime);
+ 
+    status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==n->TransmissionStatus())
+     {
+       Scheduler& s=Scheduler::instance();
+       double d1=window-(NOW-cycle_start_time);
+  
+       if(d1>0){
+       double backoff=Random::uniform()*d1;
+       backoff_handler.window_=window;
+    // printf("broadcast Tx set timer at %f backoff is %f\n",NOW,backoff);
+       s.schedule(&backoff_handler,(Event*) pkt,backoff);
+       return;
+       }
+       else {
+           backoff_handler.clear();
+           printf("TMac:backoff:no time left \n");
+           Packet::free(pkt);
+       }
+ 
+     }
+ 
+ if (SEND==n->TransmissionStatus())
+ {
+   // this case is supposed not to  happen 
+     printf("tmac: queue send data too fas\n");
+     Packet::free(pkt);
+       return;
+ }
+ 
+ }
+ 
+ */
+ 
+ 
+ void 
+ TMac::TxND(Packet* pkt, double window)
+ {
+    printf("TMac TxND node %d\n",index_); 
+   hdr_cmn* cmh=HDR_CMN(pkt);
+    hdr_tmac* synh = HDR_TMAC(pkt); 
+   
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  
+   hdr_cmn::access(pkt)->txtime()=getTxTime(cmh->size());
+  
+   /*(cmh->size()*encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;*/
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+   if(SLEEP==n->TransmissionStatus()) {
+   Poweron();
+   n->SetTransmissionStatus(SEND);
+   cmh->ts_=NOW;
+ 
+   if(PhaseStatus==PHASETWO){
+ 
+     double t=NOW-cycle_start_time;
+ 
+     synh->interval=next_period-t;
+   }
+ 
+   sendDown(pkt);
+   backoff_handler.clear();
+ 
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==n->TransmissionStatus()){
+   
+   n->SetTransmissionStatus(SEND);
+  
+   //printf("TxND the data type is %d\n",MAC_BROADCAST);
+   //printf("broadcast : I am going to send the packet down tx is %f\n",txtime);
+      cmh->ts_=NOW;
+ 
+   if(PhaseStatus==PHASETWO){
+ 
+    double t=NOW-cycle_start_time;
+    synh->interval=next_period-t; 
+ 
+   }
+ 
+   sendDown(pkt);
+   backoff_handler.clear();
+   //  printf("broadcast %d Tx Idle set timer at %f tx is %f\n",node_->nodeid(),NOW,txtime);
+ 
+    status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==n->TransmissionStatus())
+     {
+       Scheduler& s=Scheduler::instance();
+       double d1=window-(NOW-cycle_start_time);
+  
+       if(d1>0){
+       double backoff=Random::uniform()*d1;
+       backoff_handler.window_=window;
+    // printf("broadcast Tx set timer at %f backoff is %f\n",NOW,backoff);
+       s.schedule(&backoff_handler,(Event*) pkt,backoff);
+       return;
+       }
+       else {
+           backoff_handler.clear();
+           printf("Rmac:backoff:no time left \n");
+           Packet::free(pkt);
+       }
+ 
+     }
+ 
+ if (SEND==n->TransmissionStatus())
+ {
+   // this case is supposed not to  happen 
+     printf("rmac: queue send data too fas\n");
+     Packet::free(pkt);
+       return;
+ }
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ void 
+ TMac::InitPhaseThree()
+ {
+   printf("TMac: this is InitPhaseThree\n"); 
+ 
+    PrintTable();
+ 
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   mac_status=TMAC_SLEEP;
+   /* if(n->TransmissionStatus()==SLEEP)*/
+     Wakeup();  
+     return;
+ }
+ 
+ 
+ void 
+ TMac::ResetMacStatus()
+ {
+ printf("Tmac:ResetMacStatus  node %d at %f...\n",index_,NOW);
+  UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  // the node is receiving some data
+   if(n->TransmissionStatus()==RECV) 
+    {
+    mac_status=TMAC_IDLE;
+    Scheduler &s=Scheduler::instance();
+   s.schedule(&poweroff_handler,&poweroff_event,TAduration_);
+    }
+   else 
+   {
+     mac_status=TMAC_SLEEP;
+     Poweroff();
+   }
+ }
+ 
+ 
+ void 
+ TMac::Wakeup(){
+ printf("\n. ..WakeUp node %d periodic wake up at %f...\n\n",index_,NOW);
+ 
+   Scheduler &s=Scheduler::instance();
+   //   s.cancel(&poweroff_event);
+   //  s.cancel(&wakeup_event); //? necessary?
+ 
+   // s.schedule(&poweroff_handler,&poweroff_event,TAduration_);
+ 
+   s.schedule(&wakeup_handler,&wakeup_event,PeriodInterval_);
+ 
+  if (mac_status==TMAC_SLEEP) 
+ {
+        Poweron();
+ 
+        mac_status=TMAC_IDLE;
+        s.schedule(&poweroff_handler,&poweroff_event,TAduration_);
+    
+         cycle_start_time=NOW;
+           
+         if (NewData())
+                        { 
+        printf("WakeUp: There is new data in node %d and the number of packet is %d\n", 
+                       index_,txbuffer.num_of_packet);
+ 	     SendRTS();
+ 		       }
+ }
+   return;
+ }
+ 
+ 
+ 
+ 
+ void 
+ TMac::ReStart(){
+ printf("\n. ..ReStart node %d re-start up at %f...\n\n",index_,NOW); 
+ 
+    printf("\n. ..Restart  node %d schedule poweroff after %f at%f...\n\n",index_,TAduration_,NOW);
+ 
+   Scheduler &s=Scheduler::instance();
+   s.cancel(&poweroff_event);
+ 
+   // s.cancel(&wakeup_event);
+ 
+   s.schedule(&poweroff_handler,&poweroff_event,TAduration_);
+  
+ 
+   if((mac_status==TMAC_SILENCE)||(mac_status==TMAC_IDLE))
+     {
+             mac_status=TMAC_IDLE;
+                  if (NewData())
+                        { 
+            printf("Restart: There is new data in node %d and the number of packet is %d\n", 
+                       index_,txbuffer.num_of_packet);
+ 	     SendRTS();
+ 		       }
+     }
+   return;
+ }
+ 
+ 
+ void 
+ TMac::PrintTable(){
+ 
+  
+   printf("TMac: the short latency table in node%d...\n",index_); 
+ 
+   for (int i=0;i<TABLE_SIZE;i++)
+ {
+   printf("node addr is%d and short latency is%f\n",short_latency_table[i].node_addr,short_latency_table[i].latency);
+ }
+ 
+ 
+ printf("TMac: the period table in node%d...\n",index_); 
+ 
+   for (int i=0;i<TABLE_SIZE;i++)
+ {
+   printf("node addr is%d and difference is%f\n",period_table[i].node_addr,period_table[i].difference);
+ }
+ 
+ }
+ 
+ bool 
+ TMac::NewData(){
+   return (!txbuffer.IsEmpty());//?think about it
+ }
+ 
+ 
+ void 
+ TMac::ProcessSilence()
+ {
+   printf("TMac: ProcessSilence node%d and num of silence record %d at %f\n",
+            index_,silenceTableIndex,NOW);
+   
+   CleanSilenceTable();
+ 
+   if(silenceTableIndex==0) 
+   {
+      InitializeSilenceTable();
+       ReStart();
+       return;
+   }      
+ 
+   printf("TMac: ProcessSilence node %d: there still exists silence record..\n",index_);
+   double silenceTime=0;
+   silenceTime=silence_table[0].start_time+silence_table[0].duration;
+   for (int i=0;i<silenceTableIndex;i++)
+     {
+       double t1=silence_table[i].start_time;
+       double t2=silence_table[i].duration;
+       if(silenceTime<t1+t2) silenceTime=t1+t2;
+     } 
+   
+   double t=silenceTime-NOW;
+    Scheduler &s=Scheduler::instance();
+    s.cancel(&silence_event);
+    s.schedule(&silence_handler,&silence_event,t);
+    last_silenceTime=NOW+t;    
+   return; 
+ }
+ 
+ void 
+ TMac::CleanSilenceTable()
+ {
+   if(silenceTableIndex==0) return;
+   int i=0;
+  
+   while (i<silenceTableIndex)
+     {
+       double st=silence_table[i].start_time;
+       double du=silence_table[i].duration;
+   
+       if (((silence_table[i].confirm_id==0)||(st+du<=NOW))&&(silence_table[i].node_addr!=-1))
+         {
+    printf("Tmac:CleanSilence : node %d clears the silence record... \n",index_);
+       DeleteSilenceTable(i);
+         }
+   else i++;
+     }
+ 
+ }
+ 
+ 
+ 
+ void
+ TMac::DeleteSilenceTable(int index)
+ {
+   for(int i=index;i<silenceTableIndex;i++)
+     {
+    silence_table[i].node_addr=silence_table[i+1].node_addr;
+    silence_table[i].start_time=silence_table[i+1].start_time;
+    silence_table[i].duration=silence_table[i+1].duration;
+    silence_table[i].confirm_id=silence_table[i+1].confirm_id;
+     }
+    silenceTableIndex--;    
+    return;
+ }
+ 
+ void
+ TMac::DeleteSilenceRecord(int node_addr)
+ {
+   int index=-1;
+   for(int i=0;i<silenceTableIndex;i++)
+   if (silence_table[i].node_addr==node_addr) index=i;
+   
+   if(index!=-1) DeleteSilenceTable(index);
+    return;
+ }
+ 
+ 
+ 
+ void 
+ TMac::InitializeSilenceTable()
+ {
+   for(int i=0;i<TABLE_SIZE;i++)
+     {
+       silence_table[i].node_addr=-1;
+       silence_table[i].start_time=0;
+       silence_table[i].duration=0;
+       silence_table[i].confirm_id=0;
+     }
+   silenceTableIndex=0;
+   return;
+ }
+ 
+ 
+ void 
+ TMac::ConfirmSilenceTable(int sender_addr, double duration)
+ {
+   int index=-1;
+   for(int i=0;i<silenceTableIndex;i++)
+     if(silence_table[i].node_addr==sender_addr) index=i;
+  
+   if(index!=-1)silence_table[index].confirm_id=1;
+   else 
+ {
+  InsertSilenceTable(sender_addr,duration);
+  ConfirmSilenceTable(sender_addr, duration);
+ }
+   return;
+ }
+ 
+ void 
+ TMac::DataUpdateSilenceTable(int sender_addr)
+ {
+   printf("TMac:DataUpdateSilenceTable node %d...\n",index_);
+ 
+   int index=-1;
+ for(int i=0;i<silenceTableIndex;i++)
+   if(silence_table[i].node_addr==sender_addr) index=i;
+   
+ //printf("TMac:DataUpdateSilenceTable node %d index of this record is %d...\n",index_,index);
+  if(index!=-1) silence_table[index].confirm_id=1;
+  else 
+ {
+   // printf("TMac:DataUpdateSilenceTable node %d this is new data record...\n",index_);
+   double t=2*max_propagationTime+max_large_packet_transmissiontime;
+   // InsertSilenceTable(sender_addr,t);
+   ConfirmSilenceTable(sender_addr,t);
+  }
+ }
+ 
+ 
+ 
+ void 
+ TMac::SendRTS()
+ { 
+ printf("tmac SendRTS: node %d ...at %f\n",index_,NOW);
+ 
+      Scheduler& s=Scheduler::instance();
+            
+ 	    rts_timeout_handler.num=0;
+              s.cancel(&rts_timeout_event);
+ 
+  if(mac_status==TMAC_SILENCE) 
+    {
+     printf("tmac SendRTS: node %d  is in TMAC_SILENCE state at %f\n",index_,NOW);       
+ 	     return; 
+    }
+ 
+   Packet* p=txbuffer.head();
+   hdr_cmn*  cmh = HDR_CMN(p);
+   int receiver_addr=cmh->next_hop();
+   
+    txbuffer.LockBuffer();
+    int num=txbuffer.num_of_packet;
+ 
+   printf("tmac SendRTS: node %d lock txbuffer \n",index_);
+ 
+   int sender_addr=index_;
+   double l=CheckLatency(short_latency_table,receiver_addr);
+   double du=num*(((large_packet_size_*encoding_efficiency_+PhyOverhead_)/bit_rate_)+transmission_time_error_);
+   double dt=3.1*l+max_propagationTime+du*2+max_propagationTime-max_short_packet_transmissiontime;      
+     
+   // Generate a RTS Packet
+ 
+       Packet* pkt =Packet::alloc();
+       hdr_tmac* rtsh = HDR_TMAC(pkt);
+       cmh = HDR_CMN(pkt);
+  
+ 
+        cmh->next_hop()=receiver_addr;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_TMAC;
+       
+        rtsh->ptype=P_RTS;
+        rtsh->pk_num = num_send;
+        rtsh->duration=dt;
+        rtsh->sender_addr=index_;
+        rtsh->receiver_addr=receiver_addr;
+        num_send++;
+ 
+        assert(initialized());
+        UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 
+  
+        hdr_cmn::access(pkt)->txtime()=getTxTime(cmh->size());
+ 	   /**encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;*/
+ 
+        double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+        mac_status=TMAC_RTS;
+ 
+        // Scheduler &s=Scheduler::instance();
+        s.cancel(&poweroff_event);
+       
+         double t2=Random::uniform()*ContentionWindow_; 
+    
+         rts_handler.receiver_addr=receiver_addr;  
+         printf("SendRTS, node %d is in  TMAC_RTS at %f will tx RTS in  %f\n",index_,NOW,t2);
+         s.schedule(&rts_handler, (Event*) pkt,t2);
+ 
+ 	//   printf("TxRTS, node %d is in  TMAC_RTS at %f\n",index_,NOW);
+ 
+ }
+ 
+ void 
+ TMac::TxRTS(Event* e,int receiver_addr)
+ {
+      
+   printf("TxRTS, node %d is at %f\n",index_,NOW);
+         Packet* pkt=(Packet*) e;
+  
+        Scheduler &s=Scheduler::instance();  
+        s.cancel(&rts_timeout_event);
+ 	
+ 
+       	if(mac_status==TMAC_SILENCE)
+           {
+   printf("TxRTS, node %d is at silence state quit %f\n",index_,NOW);
+          rts_timeout_handler.num=0;
+ 	  Packet::free(pkt);
+           return;
+ 	  }
+ 
+       
+         hdr_cmn*  cmh = HDR_CMN(pkt);
+ 
+         hdr_cmn::access(pkt)->txtime()=getTxTime(cmh->size());
+ 		/**encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;*/
+ 
+         double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+         double l=CheckLatency(short_latency_table, receiver_addr);
+         double t=2.2*l+MinBackoffWindow*2;
+         UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+  
+          TransmissionStatus status=n->TransmissionStatus();      
+ 
+          if(IDL==status){
+   
+             n->SetTransmissionStatus(SEND);
+  
+               cmh->ts_=NOW;
+              sendDown(pkt);
+      // printf("broadcast %d Tx Idle set timer at %f tx is %f\n",node_->nodeid(),NOW,txtime);
+ 
+       printf("TxRTS, node %d Tx RTS at %f and timeout is %f number of try is %d\n",index_,NOW,t,rts_timeout_handler.num);
+             status_handler.SetStatus(IDL);
+ 	    //    Scheduler& s=Scheduler::instance();
+ 	    // s.cancel(&rts_timeout_event);
+             s.schedule(&status_handler,&status_event,txtime);
+ 	    rts_timeout_handler.num=0;
+              s.schedule(&rts_timeout_handler,&rts_timeout_event,t);
+ 
+                 return;
+ 	 }
+ 
+ 
+  if(RECV==status)
+     {      
+         printf("TxRTS, node %d is in RECV state, backoff...\n",index_);
+ 	// Scheduler &s=Scheduler::instance();
+     
+         double t2=MinBackoffWindow+Random::uniform()*MinBackoffWindow; 
+         rts_handler.receiver_addr=receiver_addr;  
+         s.schedule(&rts_handler, (Event*) pkt,t2);
+ 
+      return;
+     }
+ 
+ if (SEND==status)
+   {
+     printf("tmac: queue send data too fast\n");
+     Packet::free(pkt);
+       return;
+   }
+ 
+ }
+ 
+ 
+ 
+ double 
+ TMac::CheckLatency(latency_record* table,int addr)
+ {
+   int i=0;
+ double d=0.0;
+  
+  while((table[i].node_addr!=addr)&&(i<TABLE_SIZE))
+ {
+   //printf("node addr is%d and latency is%f\n",table[i].node_addr,table[i].latency);
+  i++;
+ }
+  if (i==TABLE_SIZE) return d;
+  else return table[i].latency;
+ }
+ 
+ 
+ 
+ 
+ double 
+ TMac:: CheckDifference(period_record* table,int addr)
+ {
+   int i=0;
+ double d=-0.0;
+  
+  while((table[i].node_addr!=addr)&&(i<TABLE_SIZE))i++;
+ 
+  if (i==TABLE_SIZE) return d;
+  else return table[i].difference;
+ }
+ 
+ 
+ void 
+ TMac::ProcessCTSPacket(Packet* pkt)
+ {
+     
+     printf("TMac:ProcessCTSPacket: node %d at time %f\n",index_,NOW);
+ 
+     hdr_tmac* ctsh=HDR_TMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int sender_addr=ctsh->sender_addr;
+     int receiver_addr=ctsh->receiver_addr;
+     double dt=ctsh->duration; 
+     double  l=CheckLatency(short_latency_table,sender_addr);
+     double t=dt-2*l;
+       
+     Packet::free(pkt);
+ 
+     if(receiver_addr!=index_) 
+       {
+       if(t>0)
+ 	{
+ 	  ConfirmSilenceTable(receiver_addr,t);
+ 	  if(mac_status==TMAC_SILENCE)
+           {
+          printf("tmac:ProcessCTS: node %d, I am already in silence state %d\n", index_,mac_status);  
+ 	    if(last_silenceTime<t+NOW)
+             {
+             printf("tmac:ProcessCTS: node %d, the silence is longer than existing one...\n", index_);  
+             Scheduler& s=Scheduler::instance();
+             s.cancel(&silence_event);
+             s.schedule(&silence_handler,&silence_event,t);
+             last_silenceTime=NOW+t;
+ 	    }
+           }// end of silence state
+           else              
+ 	    {
+       printf("tmac:ProcessCTS: node %d, I am going to be in silence state\n", index_);  
+      
+       Scheduler& s=Scheduler::instance();
+       if(mac_status==TMAC_IDLE) s.cancel(&poweroff_event);
+       s.cancel(&timeout_event);
+       
+       s.schedule(&silence_handler,&silence_event,t);
+        mac_status=TMAC_SILENCE;
+       last_silenceTime=NOW+t;
+ 	    }
+ 	}
+       }// end of no-intended receiver
+     else {
+       if(mac_status!=TMAC_RTS) {
+      printf("tmac:ProcessCTS:status change, I quit this chance\n");  
+      return;
+       }
+ 
+       printf("tmac:ProcessCTS: node %d this CTS is for me \n",index_); 
+  
+       double t=max_propagationTime-l;    
+       Scheduler& s=Scheduler::instance();   
+       s.cancel(&rts_timeout_event);// cancel the timer of RTS
+       rts_timeout_handler.num=0;
+       transmission_handler.receiver=sender_addr;      
+       s.schedule(&transmission_handler,&transmission_event,t);
+     }
+   
+     return;
+     
+ }
+ 
+ 
+ void 
+ TMac::ClearTxBuffer()
+ {
+  printf("TMac: ClearTxBuffer: node %d clear its buffer\n",index_);
+ 
+   Packet*  p1[MAXIMUM_BUFFER];
+   
+   for (int i=0;i<MAXIMUM_BUFFER;i++)p1[i]=NULL;
+   buffer_cell* bp=txbuffer.head_;
+   int i=0;
+   while(bp){
+     p1[i]=bp->packet;
+     bp=bp->next;
+     i++;
+   }
+ 
+  
+ 
+   for (int i=0;i<MAXIMUM_BUFFER;i++){
+     //   printf("ClearTxBuffer the poniter is%d\n",p1[i]);
+     if (bit_map[i]==1) txbuffer.DeletePacket(p1[i]);
+   
+ 
+   }
+  
+   printf("txbuffer is cleared, there are %d packets left\n",txbuffer.num_of_packet);
+ 
+   return; 
+ }
+ 
+ 
+ 
+ void 
+ TMac::ProcessACKDataPacket(Packet* pkt)
+ {
+ printf("tmac:ProcessACKDATAPacket: node %d process ACKDATA packets at time %f duration_=%f\n",index_,NOW,duration_);
+     hdr_tmac* ackh=HDR_TMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+  
+      int dst=cmh->next_hop();
+  
+      if(dst!=index_){
+        Packet::free(pkt);
+    return;
+      }
+ 
+      if(mac_status!=TMAC_TRANSMISSION)
+        {
+ printf("tmac:ProcessACKDATAPacket: node %d not in transmission state, just quit\n",index_);
+  Packet::free(pkt);
+  return;
+        }
+ 
+     Scheduler& s=Scheduler::instance();
+     printf("tmac:ProcessAckData: node %d cancel timeout dutation=%f\n",index_,duration_);    
+       s.cancel(&timeout_event);// cancel the timer of data
+   
+ 
+   
+     
+     for (int i=0;i<MAXIMUM_BUFFER;i++)bit_map[i]=0;
+ 
+     memcpy(bit_map, pkt->accessdata(),sizeof(bit_map));
+   
+   printf("tmac:ProcessACKDATAPacket: node %d received the bitmap is:\n",index_);
+   
+ 
+   for (int i=0;i<MAXIMUM_BUFFER;i++) printf("bmap[%d]=%d ",i,bit_map[i]);
+   printf("\n");
+ 
+   printf("txbuffer will be cleared, there are %d packets in queue and duration=%f\n",txbuffer.num_of_packet,duration_);
+ 
+       Packet::free(pkt);   
+ 
+ 
+  /*
+ !!!!
+ This part should consider the retransmission state, in this implementation, we don't consider the packets loss, therefore, we just ignore it, it should be added later. 
+ 
+   */
+ 
+     ClearTxBuffer(); 
+ 
+     txbuffer.UnlockBuffer();
+   
+ 
+     printf("tmac:ProcessACKDATAPacket: node %d unlock txbuffer duration_=%f\n",index_,duration_);
+     ResumeTxProcess();
+ 
+     mac_status=TMAC_IDLE;
+    
+      ReStart();
+     return;
+ }
+ 
+ 
+ void 
+ TMac::ProcessRTSPacket(Packet* pkt)
+ {
+     
+     printf("TMac:ProcessRTSPacket: node %d is processing rts\n",index_);
+ 
+     hdr_tmac* rtsh=HDR_TMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int sender_addr=rtsh->sender_addr;
+     int receiver_addr=cmh->next_hop();
+    
+     double l=CheckLatency(short_latency_table, sender_addr);
+     double duration=rtsh->duration;
+     double silenceTime=duration-2*l;
+     double t=2*max_propagationTime
+               +2*max_short_packet_transmissiontime+2*MinBackoffWindow;
+     Packet::free(pkt);
+    
+ 
+     if((receiver_addr!=index_)&&(silenceTime>0))
+       {
+    
+   
+       if(mac_status==TMAC_IDLE)
+ 	{
+       printf("TMAC:ProcessRTS: node %d: I am not the intended receiver and will be in silence \n", 
+                 index_);
+        InsertSilenceTable(sender_addr,silenceTime);
+      
+        mac_status=TMAC_SILENCE;
+ 
+       Scheduler &s=Scheduler::instance();
+       s.cancel(&poweroff_event);
+       s.schedule(&silence_handler,&silence_event,t);
+       last_silenceTime=t+NOW;
+       return;
+ 	}
+     if(mac_status==TMAC_SILENCE)
+           {
+        InsertSilenceTable(sender_addr,silenceTime);
+ 	    if(last_silenceTime<t+NOW) 
+             {
+   printf("TMAC:ProcessRTS: node %d: I am not the intended receiver, gets a longer silence...  \n", index_);
+ 
+             Scheduler& s=Scheduler::instance();
+             s.cancel(&silence_event);
+             s.schedule(&silence_handler,&silence_event,t);
+             last_silenceTime=NOW+t;
+ 	    }
+               return;
+ 	  }
+ 
+     if(mac_status==TMAC_RTS)
+       {
+     
+ 	if (sender_addr<index_) 
+             {
+  printf("TMAC:ProcessRTS: node %d: I am not the intended receiver and quits the  RTS state \n", index_);
+          InsertSilenceTable(sender_addr,silenceTime);
+               mac_status=TMAC_SILENCE;
+               Scheduler &s=Scheduler::instance();
+               s.cancel(&poweroff_event);
+               s.cancel(&rts_timeout_event);
+ 	       rts_timeout_handler.num=0;
+               s.schedule(&silence_handler,&silence_event,t);
+               last_silenceTime=t+NOW;
+ 	    }
+       return;
+       }
+     printf("TMac: ProcessRTS node %d : this RTS is not for me and I am in unknow state\n",index_);
+     return;
+       }
+ 
+     if(receiver_addr!=index_) return;
+ 
+     if(mac_status==TMAC_IDLE)
+     {  
+       printf("TMac:ProcessRTSPacket: node %d is in idle state and ready to process the RTS\n",index_);
+       double dt=0;
+    
+       // dt=l+2.5*duration+max_propagationTime;
+       dt=duration-l;
+       double dt1=dt-l-max_short_packet_transmissiontime;
+ 
+       Scheduler &s=Scheduler::instance();
+       s.cancel(&poweroff_event);
+      
+ 
+       Packet* p=GenerateCTS(sender_addr,dt);
+       TxCTS(p);
+           
+          s.cancel(&ack_event);    
+            s.schedule(&ack_handler,&ack_event,dt1);
+ 
+       return;
+     }
+ 
+     if(mac_status==TMAC_CTS)
+       {
+  printf("TMac:ProcessRTSPacket: node %d is in CTS state \n",index_);
+ 	return;
+       }
+ 
+       if(mac_status==TMAC_SILENCE)
+       {
+  printf("TMac:ProcessRTSPacket: node %d is in SILENCE state\n",index_);
+ 	return;
+       }
+ 
+   printf("TMac:ProcessRTSPacket: node %d is in Unknown state\n",index_);  
+ }
+ 
+ void 
+ TMac:: InsertSilenceTable(int sender_addr,double duration)
+ {
+   int index=-1;
+   for(int i=0;i<silenceTableIndex;i++)
+     if(silence_table[i].node_addr==sender_addr) index=i;
+ 
+ 
+   if(index==-1) // this is a new silence record
+  {
+    printf("TMac::InsertSilenceTable: node %d: this silence from node %d is new one,duration is %f at time %f \n",index_,sender_addr,duration,NOW);
+    silence_table[silenceTableIndex].node_addr=sender_addr;
+    silence_table[silenceTableIndex].start_time=NOW;
+    silence_table[silenceTableIndex].duration=duration;
+    silence_table[silenceTableIndex].confirm_id=0;
+    silenceTableIndex++;
+   }
+   else
+     {
+  printf("TMac::InsertSilenceTable: node %d: this silence from node %d is old one, duration=%f at time %f..\n",index_,sender_addr, duration,NOW);
+       silence_table[index].start_time=NOW;
+       silence_table[index].duration=duration;
+       silence_table[index].confirm_id=0;
+     }
+ 
+   return;
+ }
+ 
+ 
+ Packet* 
+ TMac::GenerateCTS(int receiver_addr, double duration){
+ 
+       printf("tmac:GenerateCTS: node %d\n",index_);
+     
+       Packet* pkt =Packet::alloc();
+       hdr_tmac* ctsh = HDR_TMAC(pkt);
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+  
+ 
+        cmh->next_hop()=receiver_addr;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_TMAC;
+        cmh->size()=short_packet_size_;      
+ 
+        ctsh->ptype=P_CTS; 
+        ctsh->pk_num = num_send;
+        ctsh->receiver_addr=receiver_addr;
+        ctsh->duration=duration;
+        ctsh->sender_addr=index_;
+        num_send++;
+        return pkt;         
+ }
+ 
+ 
+ void
+ TMac::TxCTS(Packet *p)
+ {
+   printf("TxCTS, node %d tx CTS %f ...\n",index_,NOW);
+   if(mac_status==TMAC_SILENCE)
+     {
+   printf("TMac:node %d, I am in silence state, I have to quit..\n",index_); 
+        Scheduler& s=Scheduler::instance();    
+        s.cancel(&ack_event);
+        s.cancel(&timeout_event);
+       cts_handler.num=0;
+       Packet::free(p);
+       return;
+     }
+ 
+   if(cts_handler.num==2)
+     {
+       printf("TMac:node %d, I have to try to send CTS twice, I have to quit..\n",index_); 
+       cts_handler.num=0;
+ 
+        Scheduler& s=Scheduler::instance();    
+        s.cancel(&ack_event);
+  
+       Packet::free(p);
+       mac_status=TMAC_IDLE;
+       ReStart();
+       return;
+     }
+   
+   hdr_cmn* cmh=HDR_CMN(p);
+   hdr_tmac* ctsh = HDR_TMAC(p); 
+ 
+          mac_status=TMAC_CTS;
+         hdr_cmn::access(p)->txtime()=getTxTime(cmh->size());
+ 		/**encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;*/
+ 
+         double txtime=hdr_cmn::access(p)->txtime();
+         int receiver_addr=cmh->next_hop();
+ 
+      
+         double l=CheckLatency(short_latency_table, receiver_addr);
+         double t=2.2*l+MinBackoffWindow*2+max_short_packet_transmissiontime
+                                          +max_large_packet_transmissiontime;
+         double t1=transmission_time_error_+ctsh->duration;     
+        
+        for (int i=0;i<MAXIMUM_BUFFER;i++) bit_map[i]=0;
+ 
+        
+          UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+           TransmissionStatus status=n->TransmissionStatus();
+ 
+          if(IDL==status){
+            
+ 
+             n->SetTransmissionStatus(SEND);
+  
+             cmh->ts_=NOW;
+ 
+             sendDown(p);
+ 
+       printf("TxCTS, node %d tx CTS %f and timeout is set at %f\n",index_,NOW,t);
+            
+             status_handler.SetStatus(IDL);
+             Scheduler& s=Scheduler::instance();
+        
+             s.cancel(&timeout_event);
+ 	    cts_handler.num=0;
+             s.schedule(&status_handler,&status_event,txtime);   
+          
+             s.schedule(&timeout_handler,&timeout_event,t);   
+       
+                 return;
+ 	 }
+ 
+   if(RECV==status)
+     { 
+         printf("TxCTS, node %d has to back off \n",index_,NOW);
+         Scheduler &s=Scheduler::instance();
+     
+         double t2=MinBackoffWindow*(1+Random::uniform()); 
+       
+         s.schedule(&cts_handler, (Event*) p,t2);
+ 
+ 
+      return;      
+ 
+     }
+     
+     if (SEND==status)
+     {
+   // this case is supposed not to  happen 
+     printf("tmac: SendCTS is in wrong status\n");
+     Packet::free(p);
+       return;
+ 
+      }
+ }
+ 
+ 
+ void 
+ TMac::SetIdle()
+ {
+ 
+   // sometimes, need to cancel the timer 
+   Scheduler& s=Scheduler::instance();
+   s.cancel(&ack_event);
+ 
+   printf("SetIdle: node %d at %f\n",index_,NOW);
+   if(mac_status==TMAC_SILENCE) return;
+   else 
+    {
+    mac_status=TMAC_IDLE;
+    ReStart();
+    return;
+   }
+ }
+ 
+ 
+ 
+ 
+ 
+ void 
+ TMac::ProcessNDPacket(Packet* pkt)
+ {
+   // printf("tmac:ProcessNDPacket: node %d\n",index_);
+     hdr_tmac* ndh=HDR_TMAC(pkt);
+     hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+     int  sender=ndh->sender_addr;
+     double time=NOW;
+     if(arrival_table_index>=TABLE_SIZE){ 
+       printf("tmac:ProcessNDPacket:arrival_table is full\n");
+       Packet::free(pkt);
+       return;
+     }
+     arrival_table[arrival_table_index].node_addr=sender;
+     arrival_table[arrival_table_index].arrival_time=time;
+     arrival_table[arrival_table_index].sending_time=cmh->ts_;
+     arrival_table_index++;
+     Packet::free(pkt);
+       return;
+ }
+ 
+ 
+ void 
+ TMac::ProcessDataPacket(Packet* pkt)
+ {
+  printf("tmac:ProcessDataPacket: node %d  my status is %d\n",
+          index_,mac_status);
+ 
+   hdr_uwvb* vbh=HDR_UWVB(pkt);
+   hdr_tmac* tmach=HDR_TMAC(pkt);
+   hdr_cmn* cmh=HDR_CMN(pkt);
+ 
+ 
+   int dst=cmh->next_hop();
+   data_sender=tmach->sender_addr;
+   int num=tmach->data_num;
+ 
+   if(dst!=index_) 
+ {
+   if(mac_status==TMAC_SILENCE) DataUpdateSilenceTable(data_sender);
+   else 
+   {
+   printf("tmac:processDataPacket: node %d, I am not in silence state, my state is %d\n", index_,mac_status);
+       
+       double t=2*max_propagationTime+max_large_packet_transmissiontime;
+       Scheduler& s=Scheduler::instance();
+       
+       if(mac_status==TMAC_IDLE) s.cancel(&poweroff_event);
+       s.cancel(&timeout_event);
+       mac_status=TMAC_SILENCE;
+       s.cancel(&silence_event);
+       s.schedule(&silence_handler,&silence_event,t);  
+ 
+   }
+ 
+ return;
+ }
+  
+   if(mac_status==TMAC_CTS) mac_status=TMAC_RECV;
+       Scheduler& s=Scheduler::instance();
+       s.cancel(&timeout_event);
+ 
+         MarkBitMap(num);
+ printf("tmac:ProcessDataPacket: node %d  send up the packet\n",index_);
+     uptarget_->recv(pkt,this);
+     // SendACKPacket();
+       return;
+ }
+ 
+ void 
+ TMac::MarkBitMap(int num){
+   if(num<MAXIMUM_BUFFER) bit_map[num]=1;
+ }
+ 
+ 
+ void 
+ TMac::SendACKPacket()
+ {
+   printf("tmac Send ACK: node %d at %f\n",index_,NOW);
+   
+   if(data_sender<0) {
+     printf("Ramc:ScheduleACKData: invalid sender address\n");
+     return; 
+   }
+ 
+   if(mac_status!=TMAC_RECV) {
+    printf("Ramc:SendACK: invalid state\n");
+      return; 
+   }
+   Packet* pkt=Packet::alloc(sizeof(bit_map)); 
+   hdr_cmn*  cmh = HDR_CMN(pkt);
+    hdr_tmac* revh = HDR_TMAC(pkt);
+  
+        memcpy(pkt->accessdata(),bit_map,sizeof(bit_map));
+ 
+        printf("tmac Schdeule ACKDATA: node %d return bitmap is \n",index_);
+   for(int i=0;i<MAXIMUM_BUFFER;i++) printf("bit_map[%d]=%d ",i,bit_map[i]);
+ 
+        printf("\n");         
+ 
+ 
+  
+        cmh->next_hop()=data_sender;
+        cmh->direction()=hdr_cmn::DOWN; 
+        cmh->addr_type()=NS_AF_ILINK;
+        cmh->ptype_=PT_TMAC;
+        cmh->size()=short_packet_size_;     
+      
+        revh->ptype=P_ACKDATA;
+        revh->pk_num = num_send;
+        revh->sender_addr=index_;
+        num_send++;
+        TxACKData(pkt);
+ }
+ 
+ 
+ void  
+ TMac::TxACKData(Packet* pkt){
+  printf("TMac TxACKData node %d at %f\n",index_,NOW);
+ 
+   hdr_cmn* cmh=HDR_CMN(pkt);
+  
+   assert(initialized());
+   UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+  
+   hdr_cmn::access(pkt)->txtime()=getTxTime(cmh->size());
+   /**encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;*/
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+   mac_status=TMAC_IDLE;
+ 
+   Scheduler &s=Scheduler::instance();
+   s.cancel(&poweroff_event);
+   s.schedule(&poweroff_handler,&poweroff_event,TAduration_);
+ 
+   //  printf("TxACKData, node %d is in  TMAC_IDLE at %f\n",index_,NOW);
+  TransmissionStatus status=n->TransmissionStatus();
+  
+   if(SLEEP==status) {
+   Poweron();
+   n->SetTransmissionStatus(SEND); 
+   cmh->ts_=NOW;
+ 
+   sendDown(pkt);
+ 
+   // printf("TMac TxACKData node %d at %f\n",index_,NOW);
+   status_handler.SetStatus(SLEEP);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(IDL==status){
+    printf("TMac TxACKData node %d is idle state at %f\n",index_,NOW);
+     n->SetTransmissionStatus(SEND);
+  
+      cmh->ts_=NOW;
+ 
+      sendDown(pkt);
+  
+   status_handler.SetStatus(IDL);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&status_handler,&status_event,txtime);
+   return;
+   }
+ 
+   if(RECV==status)
+     {
+ printf("TMac TxACKData node %d is in recv state at %f, will be interrupted\n",index_,NOW);
+       
+       InterruptRecv(txtime);
+       cmh->ts_=NOW;
+       sendDown(pkt);
+ 
+       status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);
+      return;
+     }
+ if (SEND==status)
+   {
+     printf("tmac: node%d send data too fast\n",index_);
+     Packet::free(pkt);
+       return;
+   }
+ 
+ }
+ 
+ 
+ 
+ /*
+  this program is used to handle the received packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ TMac::TxData(int receiver)
+ {
+   printf("TMac:node %d TxData at time %f\n",index_,NOW);
+ 
+   if (txbuffer.IsEmpty()) 
+ {
+ printf("TMac:TxData: what a hell! I don't have data to send\n");
+ return;
+ }
+ 
+ 
+   if((mac_status!=TMAC_RTS)&&(mac_status!=TMAC_TRANSMISSION)) {
+  printf("TMac:TxData: node %d is not in transmission state\n");
+       return;
+   }
+ 
+    UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+    if(n->TransmissionStatus()==SLEEP) Poweron();
+ 
+      mac_status=TMAC_TRANSMISSION;
+ 
+     Packet* pkt=txbuffer.next();
+    
+     hdr_cmn* cmh=hdr_cmn::access(pkt);
+     hdr_tmac* datah =hdr_tmac::access(pkt);
+     hdr_uwvb* hdr2=hdr_uwvb::access(pkt);
+ 
+     // printf("TMac:node %d TxData at time %f data type is %d offset is%d and size is %d and offset is %d and size is%d uwvb offset is %d and size is %d\n",index_,NOW,hdr2->mess_type,cmh,sizeof(hdr_cmn),datah,sizeof(hdr_tmac),hdr2,sizeof(hdr_uwvb));
+          datah->ptype=P_DATA;  
+ 
+          datah->sender_addr=index_;
+    
+          datah->pk_num=num_send;
+          datah->data_num=num_data;
+          num_send++;
+           num_data++;
+   
+           cmh->size()=large_packet_size_;
+ 
+             cmh->next_hop()=receiver;
+ 	   
+             cmh->direction()=hdr_cmn::DOWN; 
+             cmh->addr_type()=NS_AF_ILINK;
+             cmh->ptype_=PT_TMAC; 
+ 
+ 	    
+ 
+   hdr_cmn::access(pkt)->txtime()=getTxTime(cmh->size());
+   /**encoding_efficiency_+
+                                    PhyOverhead_)/bit_rate_;*/
+ 
+   double txtime=hdr_cmn::access(pkt)->txtime();
+ 
+  printf("TMac:node %d TxData at time %f data type is %d packet data_num=%d class data_num=%d \n",index_,NOW,hdr2->mess_type,datah->data_num,num_data);
+   TransmissionStatus status=n->TransmissionStatus();
+ 
+  
+  if(IDL==status)
+  {
+   n->SetTransmissionStatus(SEND); 
+         sendDown(pkt);
+ 	// printf("TMac:node %d TxData at %f\n ",index_,NOW);
+         status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);  
+  }
+ 
+  if(RECV==status)
+     {
+ 
+       printf("TMac:node %d TxData interrupt the receiving status  at %f\n ",index_,NOW);
+      
+       InterruptRecv(txtime);      
+       sendDown(pkt);
+ 
+       status_handler.SetStatus(IDL);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&status_handler,&status_event,txtime);
+     }
+ 
+  if (SEND==status)
+     { 
+     printf("tmac:Txdata: queue send data too fast\n");
+     Packet::free(pkt);
+     }
+ 
+   
+   if (txbuffer.IsEnd()) {
+    
+    
+    printf("tmac:Txdata: node %d is in state MAC_TRANSMISSION\n",index_);
+   
+    // double l=CheckLatency(short_latency_table, receiver);  
+    double dt=((large_packet_size_*encoding_efficiency_+PhyOverhead_)/bit_rate_)+transmission_time_error_;
+    // double t=2.1*max_propagationTime+transmission_time_error_+dt;  
+    double t=2.0*max_propagationTime+2.0*MinBackoffWindow+(2+num_data)*max_large_packet_transmissiontime;
+ 
+    printf("TMac:node %d TxData at %f and timeout is set %f\n ",index_,NOW,t);
+    Scheduler& s=Scheduler::instance();
+    s.cancel(&timeout_event);
+    s.schedule(&timeout_handler,&timeout_event,t);
+    num_data=0;
+   }
+   else {
+   double it=SIF_+txtime;   
+  
+  printf("tmac:Txdata: node%d schedule  next data packet , interval=%f at time%f\n",index_,it,NOW);
+   Scheduler& s=Scheduler::instance();
+   s.schedule(&transmission_handler,&transmission_event,it);
+   }
+ 
+ }
+ 
+ 
+ 
+ void 
+ TMac::ResumeTxProcess(){
+ 
+   printf("tmac:ResumeTxProcess: node %d at %f\n",index_,NOW);
+ 
+   if(!txbuffer.IsFull()) 
+   if(callback_) callback_->handle(&status_event);
+   return;
+ }
+ 
+ 
+ 
+ /*
+  this program is used to handle the transmitted packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ TMac::TxProcess(Packet* pkt){
+ 
+   hdr_uwvb* hdr=HDR_UWVB(pkt);
+ 
+   printf("tmac:TxProcess: node %d type is %d\n",index_,hdr->mess_type);
+  UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+   if (n->setHopStatus){
+    hdr_cmn* cmh=HDR_CMN(pkt);
+    cmh->next_hop()=n->next_hop;
+    cmh->error()=0;// set off the error status;
+    // printf("tmac:TxProcess: node %d set next hop to %d\n",index_,cmh->next_hop());
+   }
+  
+ 
+   txbuffer.AddNewPacket(pkt);
+   printf("tmac:TxProcess: node %d put new data packets in txbuffer\n",index_);
+   if(!txbuffer.IsFull()) 
+   if(callback_) callback_->handle(&status_event);
+   return;
+ }
+ 
+ 
+ void 
+ TMac::RecvProcess(Packet* pkt)
+ {
+  
+    hdr_cmn* cmh=HDR_CMN(pkt);
+    hdr_tmac* cmh1=HDR_TMAC(pkt);
+    int dst=cmh->next_hop();
+    int ptype=cmh1->ptype; 
+    int receiver_addr=cmh1->sender_addr;
+ 
+    if(cmh->error()) 
+  {
+   printf("tmac:node %d  gets a corrupted packet from node %d at  %f \n",
+           index_,receiver_addr,NOW);
+     return;
+    }
+ printf("tmac:node %d  gets a packet from node %d at  %f \n",
+           index_,receiver_addr,NOW);
+ 
+  if(dst==MAC_BROADCAST){
+     if (ptype==P_ND) ProcessNDPacket(pkt); //this is ND packet
+     if (ptype==P_SYN) ProcessSYN(pkt);
+     return;
+   }
+ 
+   
+  
+    if ((ptype==P_SACKND)&&(dst==index_)) 
+     {
+         ProcessShortACKNDPacket(pkt); 
+ 	return;
+     }
+    if (ptype==P_DATA){
+       ProcessDataPacket(pkt);
+       return;
+    }
+    if (ptype==P_ACKDATA) {
+       ProcessACKDataPacket(pkt);
+       return;
+      // printf("underwaterbroadcastmac:this is my packet \n");
+    } 
+ 
+    if(ptype==P_RTS)
+     {
+     ProcessRTSPacket(pkt);
+     return;
+    }
+ 
+    if(ptype==P_CTS)
+       {
+     ProcessCTSPacket(pkt);
+     return;
+       }
+  printf("tmac: node%d this is neither broadcast nor my packet %d, just drop it at %f\n",index_,dst, NOW);
+    Packet::free(pkt);
+    return;
+ }
+ 
+ 
+  
+ void 
+ TMac::StatusProcess(Event* p, TransmissionStatus  state)
+ {
+ 
+    printf("TMac StatusProcess node %d \n",index_);
+  UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+  
+  if(SLEEP==n->TransmissionStatus()) return;
+ 
+     n->SetTransmissionStatus(state);
+ 
+  return;
+ }
+ 
+ 
+ 
+ 
+ int
+ TMac::command(int argc, const char*const* argv)
+ {
+ 
+ 
+      if(argc == 3) {
+ 		TclObject *obj;
+                  if (strcmp(argv[1], "node_on") == 0) {
+ 		   Node* n1=(Node*) TclObject::lookup(argv[2]);
+ 		   if (!n1) return TCL_ERROR;
+ 		   node_ =n1; 
+ 		   return TCL_OK;
+ 		 }
+ 
+ 	
+      }
+ 
+ 	return UnderwaterMac::command(argc, argv);
+ }
diff -crBN ns-2.35/underwatersensor/uw_mac/tmac.h ns-2.35-aquasim/underwatersensor/uw_mac/tmac.h
*** ns-2.35/underwatersensor/uw_mac/tmac.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/tmac.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,530 ----
+ #ifndef ns_tmac_h
+ #define ns_tmac_h
+ 
+ #include "underwatermac.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "uwbuffer.h"
+ 
+ #define TABLE_SIZE 10 // the size of delay table
+ #define MAXIMUMBACKOFF 4 // the maximum times of backoffs
+ #define BACKOFF 1 //deleted later, used by TxProcess
+ 
+ 
+ #define UW_ND 1
+ #define UW_ACK_ND 2
+ 
+ 
+ #define PHASEONE 1
+ #define PHASETWO 2
+ #define PHASETHREE 3
+ 
+ enum TmacPacketType{
+   P_DATA,
+   P_RTS,
+   P_CTS,
+   P_ND,
+   P_SACKND,
+   P_ACKDATA,
+   P_SYN
+ };
+ 
+ 
+ enum MAC_STATUS{
+   TMAC_IDLE,
+   TMAC_RTS,
+   TMAC_CTS,
+   TMAC_RECV,
+   TMAC_TRANSMISSION,
+   TMAC_SILENCE,
+   TMAC_SLEEP
+ };
+ 
+ 
+ 
+ 
+ 
+ struct time_record{
+   int node_addr;// the address of the node
+   double arrival_time;// the time to receive the ND packet from the node
+   double sending_time; // the sending time of ND in local clock
+ };
+ 
+ 
+ 
+ 
+ struct period_record{
+   int node_addr;// the address of the node
+   double difference;// the difference with my period
+   double duration; // duration of duty cycle
+   double last_update_time; // the time last updated
+ };
+ 
+ 
+ 
+ struct silence_record {
+   int node_addr;// the address of the node
+   double start_time;// the start time of the silence
+   double duration; // duration of duty cycle
+   int  confirm_id; // silence is confirmed
+ };
+ 
+ 
+ 
+ 
+ 
+ struct latency_record{
+   int node_addr;      // the address of the node
+   double latency;    // the propagation latency with that node
+   double sumLatency;// the sum of latency
+   int num;         // number of ACKND packets 
+   double last_update_time; // the time of last update
+ };
+ 
+ struct hdr_tmac{
+         int ptype;     //packet type
+         int pk_num;    // sequence number
+         int data_num; 
+         int sender_addr;  //original sender' address
+    	double st;           // Timestamp when pkt is generated.
+         int receiver_addr;
+         double duration;
+         double interval;
+         double arrival_time;
+          double ts;	
+ 
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_tmac* access(const Packet*  p) {
+ 		return (hdr_tmac*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ 
+ 
+ class TMac;
+ 
+ class SilenceHandler: public Handler{
+  public:
+   //SilenceHandler(TMac*);
+   SilenceHandler(TMac* p): mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ class ACKHandler: public Handler{
+  public:
+   // ACKHandler(TMac*);
+   ACKHandler(TMac* p): mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ class TTimeoutHandler: public Handler{
+  public:
+   //  TTimeoutHandler(TMac*);
+   TTimeoutHandler(TMac* p): mac_(p){};
+   void handle(Event*);
+ 
+  private:
+   TMac* mac_;
+ };
+ 
+ class RTSTimeoutHandler: public Handler{
+  public:
+   //RTSTimeoutHandler(TMac*);
+   RTSTimeoutHandler(TMac* p): mac_(p){num=0;};
+   void handle(Event*);
+   int num;
+ 
+  private:
+   TMac* mac_;
+ };
+ 
+ class TSYNHandler: public Handler{
+  public:
+   // TSYNHandler(TMac*);
+   TSYNHandler(TMac* p): mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ class PoweroffHandler: public Handler{
+  public:
+   //PoweroffHandler(TMac*);
+   PoweroffHandler(TMac* p): mac_(p){};
+   void handle(Event*);
+ 
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ class TWakeupHandler: public Handler{
+  public:
+   //TWakeupHandler(TMac*);
+   TWakeupHandler(TMac* p): mac_(p){};
+   void handle(Event*);
+ 
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ class ACKDATAHandler: public Handler{
+  public:
+   ACKDATAHandler(TMac*);
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ class TxHandler: public Handler{
+  public:
+   //  TxHandler(TMac*);
+   
+   TxHandler(TMac* p):mac_(p), receiver(0){};
+   void handle(Event*);
+    int receiver;
+  private: 
+   TMac* mac_;
+ };
+ 
+ 
+ class TBackoffHandler: public Handler{
+  public:
+   //  TBackoffHandler(TMac*);
+   TBackoffHandler(TMac* p):mac_(p),window_(0),counter_(0){};
+   void handle(Event*);
+   void clear();
+   double window_;
+ 
+  private:
+   int counter_;
+   TMac* mac_;
+ };
+ 
+ 
+ class TNDHandler: public Handler{
+  public:
+   // TNDHandler(TMac*);
+   TNDHandler(TMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ class TStatusHandler: public Handler{
+  public:
+   // TStatusHandler(TMac*);
+   TStatusHandler(TMac* p):mac_(p),status_(SLEEP){};
+   void SetStatus(TransmissionStatus);
+   void handle(Event*);
+  private:
+   TransmissionStatus status_;     
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ 
+ class TACKNDWindowHandler: public Handler{
+  public:
+   // TACKNDWindowHandler(TMac*);
+   TACKNDWindowHandler(TMac* p):mac_(p){}
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ class TACKNDHandler: public Handler{
+  public:
+   //  TACKNDHandler(TMac*);
+   TACKNDHandler(TMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ class RTSHandler: public Handler{
+  public:
+   //RTSHandler(TMac*);
+   RTSHandler(TMac* p):mac_(p){receiver_addr=0;};
+   void handle(Event*);
+   int receiver_addr;
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ 
+ class CTSHandler: public Handler{
+  public:
+   //CTSHandler(TMac*);
+   CTSHandler(TMac* p):mac_(p),num(0){};
+   void handle(Event*);
+   int num;
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ 
+ class TPhaseOneHandler: public Handler{
+  public:
+   //  TPhaseOneHandler(TMac*);
+   TPhaseOneHandler(TMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ class TPhaseTwoHandler: public Handler{
+  public:
+   // TPhaseTwoHandler(TMac*);
+   TPhaseTwoHandler(TMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ class TPhaseThreeHandler: public Handler{
+  public:
+   // TPhaseThreeHandler(TMac*);
+   TPhaseThreeHandler(TMac* p):mac_(p){};
+   void handle(Event*);
+  private:
+   TMac* mac_;
+ };
+ 
+ 
+ 
+ class TMac: public UnderwaterMac {
+    
+ public:
+         TMac();
+      
+        	int  command(int argc, const char*const* argv);
+         double  ND_window_;// the window to send ND
+         double  ACKND_window_;// the winddow to send ACK_ND
+         double  PhaseOne_window_; // the time for latency detection
+         double  PhaseTwo_window_; // the time for SYN announcement
+         double SIF_;// interval between two successive data packets
+         double last_silenceTime; // the time for the longest silence  
+         double last_rts_silenceTime;    
+         double PhaseTwo_interval_;// interval between windows of phase two
+ 
+         int PhyOverhead_;// the overhead caused by phy layer
+         int arrival_table_index;
+ 
+         int short_latency_table_index;
+         int period_table_index;
+         int silenceTableIndex;      
+ 
+         int data_sender; // address of the data sender
+         int bit_map[MAXIMUM_BUFFER];// in real world, this is supposed to use bit map to indicate the lost of packet
+ 	// these two variables are used to set next hop 
+ 	// SetHopStatus=1 then set next hop using next_hop
+ 	// int setHopStatus;
+         //int next_hop;
+ 
+         int num_send; 
+         int num_data;
+         int large_packet_size_;
+         int short_packet_size_;   
+         double TransmissionRange_;
+         double duration_; // duration of duty cycle     
+         double IntervalPhase2Phase3_;
+         double next_period;//the start_time of next duty cycle
+         double PeriodInterval_;
+         double max_short_packet_transmissiontime;
+         double max_large_packet_transmissiontime;
+         double transmission_time_error_; // 
+         double max_propagationTime;
+ 
+         double TAduration_;
+         double ContentionWindow_;
+         double MinBackoffWindow;
+         
+ 	// bool overhearData;
+ 
+ 
+        int PhaseOne_cycle_; // number of cycles in phase one
+        int PhaseTwo_cycle_; // number of cycles in phase two 
+         int PhaseStatus;  
+ 
+         enum MAC_STATUS mac_status;
+ 
+ 	double cycle_start_time; // the begining time of this cycle;  
+         TransmissionBuffer txbuffer;
+          struct  time_record arrival_table[TABLE_SIZE]; 
+                 
+          struct latency_record short_latency_table[TABLE_SIZE];    
+          struct period_record  period_table[TABLE_SIZE];
+          struct silence_record silence_table[TABLE_SIZE];
+ 
+  void InitPhaseOne(double/*ND window*/,double/*ack_nd window*/,double/* phaseOne window*/); 
+     
+  void InitPhaseTwo(); 
+  void InitPhaseThree();
+   void StartPhaseTwo();
+ 
+ 
+      void InitND(double/*ND window*/,double/*ack_nd window*/,double/* phase One window*/);// to detect latency 
+ 
+      void SendND(int);
+      void TxND(Packet*, double);
+     
+      void ProcessNDPacket(Packet*);   
+      void ProcessDataPacket(Packet*);   
+      void ProcessShortACKNDPacket(Packet*);   
+      void ProcessSYN(Packet*);
+      void ProcessRTSPacket(Packet*);
+      void ProcessCTSPacket(Packet*);
+      void ProcessSleep();
+      void ProcessSilence();
+      
+      void InitializeSilenceTable();
+      void DeleteSilenceTable(int);
+      void ConfirmSilenceTable(int, double);
+      void DeleteSilenceRecord(int);
+      void DataUpdateSilenceTable(int);
+      void InsertSilenceTable(int, double);
+      void CleanSilenceTable();
+ 
+   
+      Packet* GenerateCTS(int,double);
+      void ProcessACKDataPacket(Packet*);
+      void ClearTxBuffer();
+      void Wakeup();
+      void ReStart();
+      void SendACKPacket(); 
+      void SetIdle();  
+      void SendRTS();
+      void SendCTS();
+      void TxCTS(Packet*);
+ 
+      void TxACKData(Packet*);
+      void ResetMacStatus();
+    
+      void SendShortAckND();
+      void StatusProcess(Event*,TransmissionStatus);
+      void SendSYN();
+      bool NewData();// ture if there exist data needed to send, false otherwise
+     
+      void TxRTS(Event*,int);
+      double CheckLatency(latency_record*,int);
+      double CheckDifference(period_record*,int);
+        
+      void MarkBitMap(int);
+ 
+    
+      void TxData(int);
+      void PrintTable();
+      void ResumeTxProcess();
+    
+      Packet* GenerateSYN();
+ 
+          Event large_nd_event;
+          Event short_nd_event;
+          Event status_event;
+ 
+          Event short_acknd_event;         
+          Event phaseone_event;
+          Event phasetwo_event;
+          Event phasethree_event;
+       
+         
+        
+          Event transmission_event;
+ 
+          Event silence_event;
+          Event ack_event;
+          Event poweroff_event;
+          Event wakeup_event;
+          Event timeout_event;
+          Event rts_timeout_event;
+ 	 // Event rts_silence_event;
+ 
+          TStatusHandler status_handler;
+          TNDHandler short_nd_handler;
+          TBackoffHandler backoff_handler;
+          
+          TACKNDHandler acknd_handler;
+          TACKNDWindowHandler short_acknd_window_handler; 
+ 
+          TPhaseOneHandler phaseone_handler;
+          TPhaseTwoHandler phasetwo_handler; 
+          TPhaseThreeHandler phasethree_handler;
+          
+          ACKHandler ackdata_handler;
+        
+          TxHandler transmission_handler;
+         
+          SilenceHandler silence_handler;
+          ACKHandler   ack_handler;
+          PoweroffHandler poweroff_handler;
+          TWakeupHandler wakeup_handler; 
+          TTimeoutHandler timeout_handler;
+          RTSTimeoutHandler rts_timeout_handler;
+          RTSHandler rts_handler;
+ 	 //     RTSSilenceHandler rts_silence_handler;
+          CTSHandler cts_handler;
+          TSYNHandler syn_handler;   
+         //Node* node(void) const {return node_;}
+         // to process the incomming packet
+         virtual  void RecvProcess(Packet*);
+ 
+       
+        // to process the outgoing packet
+         virtual  void TxProcess(Packet*);
+ 
+ protected:        
+ 	inline int initialized() {
+ 	return  UnderwaterMac::initialized();
+ 	}
+  private:
+ 
+         friend class TBackoffHandler;
+         friend class TACKNDWindowHandler;
+         friend class TNDHandler;
+         friend class TPhaseOneHandler;
+         friend class TPhaseTwoHandler;
+         friend class TPhaseThreeHandler;
+         friend class TACKNDHandler;
+ 
+         friend class TxHandler;
+         friend class TTimeoutHandler;
+         friend class RTSTimeoutHandler;
+         friend class SilenceHandler;
+         friend class ACKHandler;
+         friend class PoweroffHandler;
+         friend class RTSHandler;
+         friend class TStatusHandler;
+         friend class TWakeupHandler;
+         friend class CTSHandler; 
+         friend class TSYNHandler;
+ 
+ 
+ };
+ 
+ #endif /* __tmac_h__ */
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterchannel.cc ns-2.35-aquasim/underwatersensor/uw_mac/underwaterchannel.cc
*** ns-2.35/underwatersensor/uw_mac/underwaterchannel.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterchannel.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,427 ----
+ /* 
+ This program is the modified version of channel.cc, it supports 3-dimensional space and position estimation used by VBF--modified by xp at 2007
+ 
+ */
+ 
+ 
+ #include <float.h>
+ #include "trace.h"
+ #include "delay.h"
+ #include "object.h"
+ #include "packet.h"
+ #include "mac.h"
+ #include "underwaterchannel.h"
+ #include "lib/bsd-list.h"
+ #include "phy.h"
+ #include "mobilenode.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "ip.h"
+ #include "dsr/hdr_sr.h"
+ 
+ #include "underwatersensor/uw_routing/vectorbasedforward.h" // added by peng xie
+ #include "rmac.h"
+ 
+ 
+ 
+ static class UnderwaterChannelClass : public TclClass {
+ public:
+         UnderwaterChannelClass() : TclClass("Channel/UnderwaterChannel") {}
+         TclObject* create(int, const char*const*) {
+                 return (new UnderwaterChannel);
+         }
+ } class_underwaterchannel;
+ 
+ class MobileNode;
+ 
+ double UnderwaterChannel::distCST_ =1100.0;
+ 
+ 
+ UnderwaterChannel::UnderwaterChannel(void) : Channel(), numNodes_(0), 
+ 					 xListHead_(NULL), sorted_(0) {}
+ 
+ int UnderwaterChannel::command(int argc, const char*const* argv)
+ {
+ 	
+ 	if (argc == 3) {
+ 		TclObject *obj;
+ 
+ 		if( (obj = TclObject::lookup(argv[2])) == 0) {
+ 			fprintf(stderr, "%s lookup failed\n", argv[1]);
+ 			return TCL_ERROR;
+ 		}
+ 		if (strcmp(argv[1], "add-node") == 0) {
+ 			addNodeToList((MobileNode*) obj);
+ 			return TCL_OK;
+ 		}
+ 		else if (strcmp(argv[1], "remove-node") == 0) {
+ 			removeNodeFromList((MobileNode*) obj);
+ 			return TCL_OK;
+ 		}
+ 	}
+ 	return Channel::command(argc, argv);
+ }
+ 
+ 
+ void
+ UnderwaterChannel::sendUp(Packet* p, Phy *tifp)
+ {
+   //	 printf("underwaterchannel sendup\n");
+ 	Scheduler &s = Scheduler::instance();
+ 	Phy *rifp = ifhead_.lh_first;
+ 	Node *tnode = tifp->node();
+ 	Node *rnode = 0;
+ 	Packet *newp;
+ 	double propdelay = 0.0;
+ 	struct hdr_cmn *hdr = HDR_CMN(p);
+ 
+ 	 hdr->direction() = hdr_cmn::UP;
+ 	 //	 printf("underwaterchannel the direction is set %d real is%d\n",hdr_cmn::UP,hdr->direction());
+                   // use list-based improvement
+ 	 //printf("Underwaterchannel: the distCST is %f\n",distCST_);
+ 	         MobileNode *mtnode = (MobileNode *) tnode;
+ 		 MobileNode **affectedNodes;// **aN;
+ 		 int numAffectedNodes = -1, i;
+ 		 
+ 		 if(!sorted_){
+ 			 sortLists();
+ 		 }
+        affectedNodes = getAffectedNodes(mtnode, distCST_ , &numAffectedNodes); 
+       
+ 			 //  printf("underwaterchannel the affected number of node is %d\n",numAffectedNodes);
+ 		 for (i=0; i < numAffectedNodes; i++) {
+ 			 rnode = affectedNodes[i];
+ 			 
+ 
+ 		   double d1=distance(tnode,rnode);
+ 
+ 		    if((rnode == tnode)||(d1>distCST_))
+ 			{
+ 			  //printf("channel they are same\n");
+                           	 continue;
+ 			}
+ 
+ 
+ 			 newp = p->copy();
+ 		     
+                          // add by peng Xie
+ 		      
+                          calculatePosition(tnode,rnode,newp);
+ 			 propdelay = get_pdelay(tnode, rnode);	      
+  
+ 			 rifp = (rnode->ifhead()).lh_first;
+ 	
+ 			 for(; rifp; rifp = rifp->nextnode()){	
+ 			 
+ 			   //   	 printf("channel :node %d and node %d distance is %f propdelay is %f at time %f\n",mtnode->nodeid(),rnode->nodeid(),d1,propdelay,NOW);		  
+ 			   s.schedule(rifp, newp, propdelay);
+ 			 }
+ 		 
+ 		 }
+ 	 
+ 		 delete [] affectedNodes;
+ 			
+ 	          	 Packet::free(p);   
+ }
+ 
+ 
+ double
+ UnderwaterChannel::distance(Node *sender,Node* receiver)
+ {
+        	MobileNode *s1,*r1;
+          
+ 	 s1=(MobileNode*)sender;
+          r1=(MobileNode*)receiver;
+  
+ 	 // printf("underwater channel calculateposition1: :(%f,%f,%f) and  (%f,%f,%f)\n", s1->X(),s1->Y(),s1->Z(),r1->X(),r1->Y(),r1->Z());
+         double dx,dy,dz,d;
+ 	dx=r1->X()-s1->X();
+ 	dy=r1->Y()-s1->Y();
+ 	dz=r1->Z()-s1->Z();
+         d=sqrt((dx*dx)+(dy*dy)+(dz*dz));
+       
+ 	// printf("channel :node %d and node %d distance is %f \n",s1->address(),r1->address(),d);
+   return d;
+ }
+ 
+ 
+ 
+ // this is used by VBF routing protocol
+ void
+ UnderwaterChannel::calculatePosition(Node *sender,Node* receiver, Packet* p)
+ {
+ 	MobileNode *s1,*r1;
+          hdr_uwvb* vbh=HDR_UWVB(p);
+          
+ 	 s1=(MobileNode*)sender;
+          r1=(MobileNode*)receiver;
+  
+ 	 //	  printf("channel calculateposition :(%f,%f,%f) and  (%f,%f,%f)\n", s1->X(),s1->Y(),s1->Z(),r1->X(),r1->Y(),r1->Z());
+         double dx,dy,dz;
+ 	dx=r1->X()-s1->X();
+ 	dy=r1->Y()-s1->Y();
+ 	dz=r1->Z()-s1->Z();
+         
+       
+         vbh->info.dx=dx;
+         vbh->info.dy=dy;
+         vbh->info.dz=dz;
+       
+ 
+       // printf("channel calculateposition2: :(%f,%f,%f) \n",dx,dy,dz);
+ 
+ }
+ 
+ void
+ UnderwaterChannel::addNodeToList(MobileNode *mn)
+ {
+ 	MobileNode *tmp;
+ 	//  printf("channel: new node :(%f,%f,%f)\n",mn->X(),mn->Y(),mn->Z());
+ 	// create list of mobilenodes for this channel
+ 	if (xListHead_ == NULL) {
+ 		fprintf(stderr, "INITIALIZE THE LIST xListHead\n");
+ 		xListHead_ = mn;
+ 		xListHead_->nextX_ = NULL;
+ 		xListHead_->prevX_ = NULL;
+ 	} else {
+ 		for (tmp = xListHead_; tmp->nextX_ != NULL; tmp=tmp->nextX_);
+ 		tmp->nextX_ = mn;
+ 		mn->prevX_ = tmp;
+ 		mn->nextX_ = NULL;
+ 	}
+ 	numNodes_++;
+ }
+ 
+ void
+ UnderwaterChannel::removeNodeFromList(MobileNode *mn) {
+ 	
+ 	MobileNode *tmp;
+ 	// Find node in list
+ 	for (tmp = xListHead_; tmp->nextX_ != NULL; tmp=tmp->nextX_) {
+ 		if (tmp == mn) {
+ 			if (tmp == xListHead_) {
+ 				xListHead_ = tmp->nextX_;
+ 				if (tmp->nextX_ != NULL)
+ 					tmp->nextX_->prevX_ = NULL;
+ 			} else if (tmp->nextX_ == NULL) 
+ 				tmp->prevX_->nextX_ = NULL;
+ 			else {
+ 				tmp->prevX_->nextX_ = tmp->nextX_;
+ 				tmp->nextX_->prevX_ = tmp->prevX_;
+ 			}
+ 			numNodes_--;
+ 			return;
+ 		}
+ 	}
+ 	fprintf(stderr, "Channel: node not found in list\n");
+ }
+ 
+ void
+ UnderwaterChannel::sortLists(void) {
+ 	bool flag = true;
+ 	MobileNode *m, *q;
+ 
+ 	sorted_ = true;
+ 	
+ 	fprintf(stderr, "SORTING LISTS ...");
+ 	/* Buble sort algorithm */
+ 	// SORT x-list
+ 	while(flag) {
+ 		flag = false;
+ 		m = xListHead_;
+ 		while (m != NULL){
+ 			if(m->nextX_ != NULL)
+ 				if ( m->X() > m->nextX_->X() ){
+ 					flag = true;
+ 					//delete_after m;
+ 					q = m->nextX_;
+ 					m->nextX_ = q->nextX_;
+ 					if (q->nextX_ != NULL)
+ 						q->nextX_->prevX_ = m;
+ 			    
+ 					//insert_before m;
+ 					q->nextX_ = m;
+ 					q->prevX_ = m->prevX_;
+ 					m->prevX_ = q;
+ 					if (q->prevX_ != NULL)
+ 						q->prevX_->nextX_ = q;
+ 
+ 					// adjust Head of List
+ 					if(m == xListHead_) 
+ 						xListHead_ = m->prevX_;
+ 				}
+ 			m = m -> nextX_;
+ 		}
+ 	}
+ 	
+ 	fprintf(stderr, "DONE!\n");
+ }
+ 
+ void
+ UnderwaterChannel::updateNodesList(class MobileNode *mn, double oldX) {
+ 	
+ 	MobileNode* tmp;
+ 	double X = mn->X();
+ 	bool skipX=false;
+ 	
+ 	if(!sorted_) {
+ 		sortLists();
+ 		return;
+ 	}
+ 	
+ 	/* xListHead cannot be NULL here (they are created during creation of mobilenode) */
+ 	
+ 	/***  DELETE ***/
+ 	// deleting mn from x-list
+ 	if(mn->nextX_ != NULL) {
+ 		if(mn->prevX_ != NULL){
+ 			if((mn->nextX_->X() >= X) && (mn->prevX_->X() <= X)) skipX = true; // the node doesn't change its position in the list
+ 			else{
+ 				mn->nextX_->prevX_ = mn->prevX_;
+ 				mn->prevX_->nextX_ = mn->nextX_;
+ 			}
+ 		}
+ 		
+ 		else{
+ 			if(mn->nextX_->X() >= X) skipX = true; // skip updating the first element
+ 			else{
+ 				mn->nextX_->prevX_ = NULL;
+ 				xListHead_ = mn->nextX_;
+ 			}
+ 		}
+ 	}
+ 	
+ 	else if(mn->prevX_ !=NULL){
+ 		if(mn->prevX_->X() <= X) skipX = true; // skip updating the last element
+ 		else mn->prevX_->nextX_ = NULL;
+ 	}
+ 
+ 	/*** INSERT ***/
+ 	//inserting mn in x-list
+ 	if(!skipX){
+ 		if(X > oldX){			
+ 			for(tmp = mn; tmp->nextX_ != NULL && tmp->nextX_->X() < X; tmp = tmp->nextX_);
+ 			//fprintf(stdout,"Scanning the element addr %d X=%0.f, next addr %d X=%0.f\n", tmp, tmp->X(), tmp->nextX_, tmp->nextX_->X());
+ 			if(tmp->nextX_ == NULL) { 
+ 				//fprintf(stdout, "tmp->nextX_ is NULL\n");
+ 				tmp->nextX_ = mn;
+ 				mn->prevX_ = tmp;
+ 				mn->nextX_ = NULL;
+ 			} 
+ 			else{ 
+ 				//fprintf(stdout, "tmp->nextX_ is not NULL, tmp->nextX_->X()=%0.f\n", tmp->nextX_->X());
+ 				mn->prevX_ = tmp->nextX_->prevX_;
+ 				mn->nextX_ = tmp->nextX_;
+ 				tmp->nextX_->prevX_ = mn;  	
+ 				tmp->nextX_ = mn;
+ 			} 
+ 		}
+ 		else{
+ 			for(tmp = mn; tmp->prevX_ != NULL && tmp->prevX_->X() > X; tmp = tmp->prevX_);
+ 				//fprintf(stdout,"Scanning the element addr %d X=%0.f, prev addr %d X=%0.f\n", tmp, tmp->X(), tmp->prevX_, tmp->prevX_->X());
+ 			if(tmp->prevX_ == NULL) {
+ 				//fprintf(stdout, "tmp->prevX_ is NULL\n");
+ 				tmp->prevX_ = mn;
+ 				mn->nextX_ = tmp;
+ 				mn->prevX_ = NULL;
+ 				xListHead_ = mn;
+ 			} 
+ 			else{
+ 				//fprintf(stdout, "tmp->prevX_ is not NULL, tmp->prevX_->X()=%0.f\n", tmp->prevX_->X());
+ 				mn->nextX_ = tmp->prevX_->nextX_;
+ 				mn->prevX_ = tmp->prevX_;
+ 				tmp->prevX_->nextX_ = mn;  	
+ 				tmp->prevX_ = mn;		
+ 			}
+ 		}
+ 	}
+ }
+ 
+ 
+ MobileNode **
+ UnderwaterChannel::getAffectedNodes(MobileNode *mn, double radius,
+ 				  int *numAffectedNodes)
+ {
+ 	double xmin, xmax, ymin, ymax;
+         double zmin,zmax;// add by peng xie
+ 	int n = 0;
+ 	MobileNode *tmp, **list, **tmpList;
+ 
+ 	if (xListHead_ == NULL) {
+ 		*numAffectedNodes=-1;
+ 		fprintf(stderr, "xListHead_ is NULL when trying to send!!!\n");
+ 		return NULL;
+ 	}
+ 	//printf( "channel:mn(%d) is(%f,%f,%f) and radius is %f\n",mn->address() ,mn->X(),mn->Y(),mn->Z(),radius);	
+ 	xmin = mn->X() - radius;
+ 	xmax = mn->X() + radius;
+ 	ymin = mn->Y() - radius;
+ 	ymax = mn->Y() + radius;
+ 	 
+ 	// added by peng xie
+         zmin = mn->Z() - radius;
+ 	zmax = mn->Z() + radius;
+ 	// end of addition 
+ 
+ 	// First allocate as much as possibly needed
+ 	tmpList = new MobileNode*[numNodes_];
+ 	
+ 	//	printf("channel: the min and max is%f and %fabd raduid is%f\n",zmin,zmax,radius);
+ 
+ 	for(tmp = mn; tmp != NULL && tmp->X() >= xmin; tmp=tmp->prevX_){
+ 	  //	printf("channel: put one is the list is (%f, %f,%f)\n",tmp->X(),tmp->Y(),tmp->Z());	
+ 		if(tmp->Y() >= ymin && tmp->Y() <= ymax){
+ 			//  	printf("channel2: (%f,%f,%f)\n",tmp->X(),tmp->Y(),tmp->Z());
+ 			// added by peng xie
+ 	       	if(tmp->Z() >= zmin && tmp->Z() <= zmax)  tmpList[n++] = tmp;
+ 
+ 		}
+ 		//	printf("channel: put one is the list is (%f, %f,%f)\n",tmp->X(),tmp->Y(),tmp->Z());	
+ }
+       for(tmp = mn->nextX_; tmp != NULL && tmp->X() <= xmax; tmp=tmp->nextX_){
+ 		if(tmp->Y() >= ymin && tmp->Y() <= ymax){  
+ 			//	printf("channel2: (%f,%f,%f)\n",tmp->X(),tmp->Y(),tmp->Z());
+        	if(tmp->Z() >= zmin && tmp->Z() <= zmax) { 
+ 			
+                     tmpList[n++] = tmp;}
+        //	tmpList[n++] = tmp;
+ 		}
+ 		//	printf("channel2: put one is the list is (%f, %f,%f)\n",tmp->X(),tmp->Y(),tmp->Z());
+       }
+ 
+ 	list = new MobileNode*[n];
+ 	memcpy(list, tmpList, n * sizeof(MobileNode *));
+ 	delete [] tmpList;
+          
+ 	*numAffectedNodes = n;
+ 	return list;
+ }
+  
+ 	
+ double
+ UnderwaterChannel::get_pdelay(Node* tnode, Node* rnode)
+ {
+ 	// Scheduler	&s = Scheduler::instance();
+ 	UnderwaterSensorNode* tmnode = (UnderwaterSensorNode*)tnode;
+ 	UnderwaterSensorNode* rmnode = (UnderwaterSensorNode*)rnode;
+ 	double propdelay = 0;
+ 	
+ 	propdelay = tmnode->propdelay(rmnode);
+ 
+ 	assert(propdelay >= 0.0);
+        
+ 	//if (propdelay == 0.0) {
+ 		/* if the propdelay is 0 b/c two nodes are on top of 
+ 		   each other, move them slightly apart -dam 7/28/98 */
+ 		//propdelay = 2 * DBL_EPSILON;
+ 		//printf ("propdelay 0: %d->%d at %f\n",
+ 		//	tmnode->address(), rmnode->address(), s.clock());
+ 	//	}
+ 	return propdelay;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterchannel.h ns-2.35-aquasim/underwatersensor/uw_mac/underwaterchannel.h
*** ns-2.35/underwatersensor/uw_mac/underwaterchannel.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterchannel.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,44 ----
+ /* 
+ This program is the modified version of channel.h, it supports 3-dimensional space and position estimation used by VBF--modified by xp at 2007
+ 
+ */
+ #ifndef __ns_underwaterchannel_h__
+ #define __ns_underwaterchannel_h__
+ 
+ #include <string.h>
+ #include <mac/channel.h>
+ #include "object.h"
+ #include "packet.h"
+ #include "phy.h"
+ #include "node.h"
+ 
+ 
+ class UnderwaterChannel : public Channel {
+ 	friend class Topography;
+ public:
+ 	UnderwaterChannel(void);
+ 	virtual int command(int argc, const char*const* argv);
+         static double Transmit_distance(){return distCST_;}; 
+ private:
+ 	void sendUp(Packet* p, Phy *txif);
+ 	double get_pdelay(Node* tnode, Node* rnode);
+ 	
+ 	/* For list-keeper, channel keeps list of mobilenodes 
+ 	   listening on to it */
+ 	int numNodes_;
+ 	MobileNode *xListHead_;
+ 	bool sorted_;
+         void calculatePosition(Node* sender,Node* receiver, Packet* p);
+         double distance(Node* ,Node*);
+ 	void addNodeToList(MobileNode *mn);
+ 	void removeNodeFromList(MobileNode *mn);
+ 	void sortLists(void);
+ 	void updateNodesList(class MobileNode *mn, double oldX);
+ 	MobileNode **getAffectedNodes(MobileNode *mn, double radius, int *numAffectedNodes);
+        
+ 	
+ protected:
+ 	static double distCST_;        
+ };
+ 
+ #endif //_underwaterchannel_h_
diff -crBN ns-2.35/underwatersensor/uw_mac/underwatermac.cc ns-2.35-aquasim/underwatersensor/uw_mac/underwatermac.cc
*** ns-2.35/underwatersensor/uw_mac/underwatermac.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwatermac.cc	2016-09-03 00:34:50.408000000 +0800
***************
*** 0 ****
--- 1,428 ----
+ 
+ //#include "delay.h"
+ //#include "connector.h"
+ #include "packet.h"
+ //#include "random.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "rmac.h"
+ #include "mac.h"
+ #include "underwatermac.h"
+ #include "underwaterphy.h"
+ //#include "underwatersensor/uw_routing/vectorbasedforward.h"
+ 
+ void 
+ IncommingChannel::AddNewPacket(Packet* p){
+   IncommingPacket* t1;
+   IncommingPacket* t2;
+   t1=new IncommingPacket;
+   t1->next=NULL;
+   t1->packet=p;
+   t1->status=RECEPTION;
+   
+   // insert this packet at the head of the link
+   t2=head_;
+   head_=t1;
+   t1->next=t2;
+   //
+   
+   num_of_active_incomming_packet++;
+   //  printf("IncommingChannel: number of packet is %d\n",num_of_active_incomming_packet);
+   TotalSignalStrength=TotalSignalStrength+p->txinfo_.RxPr;
+   UpdatePacketStatus();
+ }
+ 
+ 
+ int
+ IncommingChannel::DeleteIncommingPacket(Packet* p){
+   IncommingPacket* t2;
+   
+   // insert this packet at the head of the link
+   t2=head_;
+ 
+   if (!t2) return 0;//0 no such point, 1:delete this point
+ 
+   if (p==t2->packet){
+     //    printf("underwatermac: the packet is at the head of list\n");
+     head_=t2->next;
+     num_of_active_incomming_packet--;
+     TotalSignalStrength=TotalSignalStrength-p->txinfo_.RxPr;
+     delete t2;
+     return 1;
+ }
+   
+   int modified=0;
+   while(t2->next){
+     if ((t2->next)->packet!=p) t2=t2->next;
+     else{
+      IncommingPacket* t1;
+   
+      t1=t2->next;
+      t2->next=t1->next;
+      num_of_active_incomming_packet--;
+     TotalSignalStrength=TotalSignalStrength-p->txinfo_.RxPr;
+     delete t1;
+     modified=1;
+     }
+   }
+   
+   return modified;
+ }
+ 
+ IncommingPacket* 
+ IncommingChannel::lookup(Packet* p){
+   IncommingPacket* t2;
+   t2=head_;  
+   while((t2->packet!=p)&&(!t2)) t2=t2->next;
+   return t2;
+ }
+ 
+ 
+ void 
+ IncommingChannel::InvalidateIncommingPacket(){
+   IncommingPacket* t2;
+   //printf("underwatermac IncommingChannel: node %d invalidate buffer %f\n",index_,NOW);  
+   t2=head_;  
+   while(t2) {
+    t2->status=INVALID;
+  t2=t2->next;
+   }
+ }
+ 
+ 
+ 
+ enum PacketStatus 
+ IncommingChannel::Status(Packet* p){
+ 
+   IncommingPacket* t2;
+   
+   t2=head_;
+  
+   while ((t2->packet!=p)&&(t2)) t2=t2->next;
+ 
+   if (!t2) {
+     printf("IncommingChannel:oops! no such packet\n");
+     return INVALID;
+   }
+   else return t2->status;
+ }
+ 
+ 
+ void
+ IncommingChannel::UpdatePacketStatus(){
+   IncommingPacket * t1;
+   t1=head_;
+ 
+   while(t1)
+     {
+ 	// printf("!!!IncommingChannel: Total is %f and packe Rxpr is %f\n",TotalSignalStrength,(t1->packet)->txinfo_.RxPr);
+       double noise=TotalSignalStrength-(t1->packet)->txinfo_.RxPr;
+       double t2=(t1->packet)->txinfo_.RxPr;     
+       double alpha=0.00000001;
+ 
+       if (TotalSignalStrength<t2) {
+ 	  //   printf("IncommingChannel what a hell %f\n",noise);
+ 	 //  printf("RECEPTION\n");
+ 	     t1->status=RECEPTION;
+ 	     return;
+       }
+ 
+     if (fabs(TotalSignalStrength-t2)<alpha){
+ 	//      printf("IncommingChannel noise is zero %f \n",noise);      //       printf("RECEPTION\n");
+ 	        t1->status=RECEPTION;
+ 		// return;
+     }
+     else {
+       // printf("IncommingChannel: current packet RX is %f and noise is %f and CPThresh is %f\n",(t1->packet)->txinfo_.RxPr,noise,(t1->packet)->txinfo_.CPThresh);
+       if (((t1->packet)->txinfo_.RxPr)/noise >= (t1->packet)->txinfo_.CPThresh)
+ 	{/*printf("RECEPTION\n");*/	t1->status=RECEPTION;}
+       else {//printf("COLLISION noise=%f \n",noise); 
+                t1->status=COLLISION;}
+     }
+       t1=t1->next;
+     }
+ }
+ 
+ RecvHandler::RecvHandler(UnderwaterMac* p):mac_(p){}
+ 
+ void RecvHandler::handle(Event* e)
+ {
+   // printf("Recv_handler\n");
+   mac_->IncommingChannelProcess(e);
+ }
+ 
+ 
+ 
+ 
+ /* ======================================================================
+    Base class for underwater sensor MAC
+    ====================================================================== */
+ static class UnderwaterMacClass : public TclClass {
+ public:
+ 	UnderwaterMacClass() : TclClass("Mac/UnderwaterMac") {}
+ 	TclObject* create(int, const char*const*) {
+ 	  return (new UnderwaterMac());
+ 
+ 	}
+ } class_underwatermac;
+ 
+ 
+ UnderwaterMac::UnderwaterMac() : Mac(),recv_handler(this)
+ {
+   bit_rate_=100;
+   encoding_efficiency_=1;
+   bind("bit_rate_",&bit_rate_);
+   bind("encoding_efficiency_",&encoding_efficiency_);
+   callback_=NULL;
+ }
+ 
+ /*
+  this program is used to handle the received packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ UnderwaterMac::RecvProcess(Packet* p){
+  printf("uwmac: there is no implementation of RecvHandler!\n");
+ }
+ 
+ 
+ 
+ 
+ void 
+ UnderwaterMac::sendUp(Packet* p){
+ 	assert(initialized());
+ 	uptarget_->recv(p,this);
+ }
+ 
+ 
+ void 
+ UnderwaterMac::sendDown(Packet* p){
+ 	assert(initialized());
+ 	//  printf("uwmac: node %d sendDown\n",index_);
+ 	downtarget_->recv(p,this);
+ }
+ 
+ 
+ 
+ 
+ /*
+  this program is used to handle the transmitted packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ UnderwaterMac::TxProcess(Packet* p){
+   printf("uwmac: there is no implementation of TxHandle\n");
+ }
+ 
+ 
+ 
+ void
+ UnderwaterMac::recv(Packet *p, Handler *h)
+ {
+ 	struct hdr_cmn *hdr = HDR_CMN(p);
+ 	int direction=hdr->direction();      
+     
+     //struct hdr_uwvb* hdr2=HDR_UWVB(p);
+     //int sender=hdr2->sender_id.addr_;
+         /*
+ 	 * Sanity Check
+ 	 */
+ 
+ 	// printf("underwatermac I (%d) receive a packet  direction is %d down=%d at %f\n",node_->nodeid(),direction,hdr_cmn::DOWN,NOW);
+ 
+ 	assert(initialized());
+ 
+ 
+ 
+ 	/*
+ 	 *  Handle outgoing packets.
+ 	 */
+ 
+ 	if(direction == hdr_cmn::DOWN) {
+           callback_=h;
+ 		  TxProcess(p);
+ 	  //  printf("underwatermac I am done with sending down\n");
+ 		  return;
+ 	}
+ 
+ 	/*
+ 	 *  Handle incoming packets.
+ 	 *
+ 	 *  We just received the 1st bit of a packet on the network
+ 	 *  interface.
+ 	 *
+ 	 */
+ 
+ 	recv_channel.AddNewPacket(p);
+     double txtime=hdr_cmn::access(p)->txtime();
+     UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+     n->SetTransmissionStatus(RECV);
+ 	n->SetCarrierSense(true);
+ 	
+ 	Scheduler& s=Scheduler::instance();
+ 	s.schedule(&recv_handler,p,txtime);     
+ 	return;
+ 	
+ }
+ 
+ 
+ int
+ UnderwaterMac::command(int argc, const char*const* argv)
+ {
+ 
+ 
+ 	if(argc == 3) {
+ 
+ 		if (strcmp(argv[1], "node_on") == 0) {
+ 		   Node* n1=(Node*) TclObject::lookup(argv[2]);
+ 		   if (!n1) return TCL_ERROR;
+ 		   node_ =n1; 
+ 		   return TCL_OK;
+ 		 }
+      }
+ 
+ 	return Mac::command(argc, argv);
+ }
+ 
+ 
+ void
+ UnderwaterMac::IncommingChannelProcess(Event* e){
+ 
+     //  printf("underwatermac recv(%d) :process incommingchannel at %f\n",node_->nodeid(),NOW); 
+  
+   //IncommingPacket* p;
+   Packet*  target;
+            target=(Packet*) e;
+ 	   enum PacketStatus status=recv_channel.Status(target);
+ 
+  UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+        
+ 
+ 
+    struct hdr_cmn *hdr = HDR_CMN(target);
+ 
+ 	   //  p=recv_channel.lookup(target);
+    if (COLLISION==status) {
+       printf("underwater: the packet is interfered at node %d\n",node_->nodeid()); 
+             recv_channel.DeleteIncommingPacket(target);
+             ResetTransmissionStatus();
+             hdr->error()=1; //set error flag
+             RecvProcess(target);
+ 	    // Packet::free(target);  
+ 	    // return;
+   }
+ 
+   if (INVALID==status) {
+     printf("underwater:the packet is invalidated at node %d\n",node_->nodeid()); 
+             recv_channel.DeleteIncommingPacket(target);
+             ResetTransmissionStatus();
+              hdr->error()=1; //set error flag
+              RecvProcess(target);
+ 	    // Packet::free(target);  
+ 	     // return;
+   }
+  
+  if (RECEPTION==status) {
+      // printf("underwater:the packet is correctly received at node %d\n",node_->nodeid()); 
+             recv_channel.DeleteIncommingPacket(target);
+             ResetTransmissionStatus();
+             RecvProcess(target);
+ 	    // return;
+  }
+ 
+  if(recv_channel.num_of_active_incomming_packet==0) n->ResetCarrierSense();
+  return;
+ }
+ 
+ 
+ 
+ void 
+ UnderwaterMac::Poweron()
+ {
+    assert(initialized());
+    UnderwaterPhy* phy;
+    //phy=(UnderwaterPhy*) downtarget_;
+    phy = (UnderwaterPhy*) netif_;
+ 
+    UnderwaterSensorNode* n;
+ 
+ 	n=(UnderwaterSensorNode*) node_ ;         
+         n->SetTransmissionStatus(IDL);
+         phy->power_on();       
+ }
+ 
+ 
+ double UnderwaterMac::getSyncHdrLen()
+ {
+ 	UnderwaterPhy* phy = (UnderwaterPhy*) netif_;
+ 	return phy->sync_hdr_len();
+ }
+ 
+ double UnderwaterMac::getForwardingDelay()
+ {
+ 	UnderwaterPhy* phy = (UnderwaterPhy*) netif_;
+ 	return phy->forwarding_delay();
+ }
+ 
+ void 
+ UnderwaterMac::Poweroff(){
+  	assert(initialized());
+        UnderwaterPhy* phy;
+         //phy=(UnderwaterPhy*) downta_;
+         phy = (UnderwaterPhy*) netif_;
+ 
+         UnderwaterSensorNode* n;
+ 
+         recv_channel.InvalidateIncommingPacket();
+ 	n=(UnderwaterSensorNode*) node_ ;         
+         n->SetTransmissionStatus(SLEEP);
+         phy->power_off();       
+         
+ }
+ 
+ void 
+ UnderwaterMac::ResetTransmissionStatus()
+ {
+   UnderwaterSensorNode* n;
+ 	assert(initialized());
+ 	n=(UnderwaterSensorNode*) node_ ;
+         if (0!=recv_channel.num_of_active_incomming_packet)
+            {
+ 	     //printf("UnderwaterMac: there exist %d packets\n",recv_channel.num_of_active_incomming_packet); 
+ return;}
+       
+ 	if (RECV==n->TransmissionStatus())
+ 	{
+ 	    n->SetTransmissionStatus(IDL);
+ 	}
+ 	return;
+ }
+ 
+ double UnderwaterMac::getTxTime(int pkt_len) {
+ 	UnderwaterPhy* phy = (UnderwaterPhy*)netif_;
+ 	
+ 	return phy->sync_hdr_len()+ pkt_len*8*encoding_efficiency_/bit_rate_;
+ }
+ 
+ double UnderwaterMac::getTxTime(Packet* pkt) {
+ 	return getTxTime(hdr_cmn::access(pkt)->size());
+ }
+ 
+ void 
+ UnderwaterMac::InterruptRecv(double txtime){
+        assert(initialized());
+        UnderwaterPhy* phy;
+        //phy=(UnderwaterPhy*) downtarget_;
+        phy = (UnderwaterPhy*)netif_;
+        UnderwaterSensorNode* n;
+ 	n=(UnderwaterSensorNode*) node_ ;  
+         n->SetTransmissionStatus(SEND);
+ 
+ 	if (RECV==n->TransmissionStatus()){ 
+         recv_channel.InvalidateIncommingPacket();   
+         phy->status_shift(txtime);       
+ 	}
+ }
diff -crBN ns-2.35/underwatersensor/uw_mac/underwatermac.h ns-2.35-aquasim/underwatersensor/uw_mac/underwatermac.h
*** ns-2.35/underwatersensor/uw_mac/underwatermac.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwatermac.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,107 ----
+ #ifndef ns_underwatermac_h
+ #define ns_underwatermac_h
+ 
+ 
+ 
+ enum PacketStatus{RECEPTION,COLLISION,INVALID};
+ 
+ struct IncommingPacket{
+ 	Packet* packet;
+ 	enum  PacketStatus status;
+ 	IncommingPacket* next;
+ };
+ 
+ 
+ class IncommingChannel{
+ public: 
+ 	IncommingChannel(){
+ 		head_=NULL; 
+ 		num_of_active_incomming_packet=0;
+ 		TotalSignalStrength=0;
+ 	};
+ 
+ 	void AddNewPacket(Packet*);
+ 	int  DeleteIncommingPacket(Packet*);
+ 	void InvalidateIncommingPacket();
+ 	IncommingPacket * lookup(Packet*);
+ 	enum PacketStatus Status(Packet*);
+ 
+ 	int num_of_active_incomming_packet;// number of incomming packets
+ 	double TotalSignalStrength; // total amount of incomming transmission power
+ 
+ 
+ private:
+ 	IncommingPacket* head_;
+ 	void UpdatePacketStatus();
+ };
+ 
+ 
+ class UnderwaterMac;
+ 
+ class RecvHandler: public Handler{
+ public:
+ 	RecvHandler(UnderwaterMac*);
+ 	void handle(Event*);
+ private:
+ 	UnderwaterMac* mac_;
+ };
+ 
+ 
+ class UnderwaterMac: public Mac {
+ 
+ public:
+ 	UnderwaterMac();
+ 
+ 	double  bit_rate_; // bit rate of the MAC
+ 	double  encoding_efficiency_; //ratio of encoding    //change these two parameters as static value!!!
+ 
+ 
+ 	int  command(int argc, const char*const* argv);
+ 	IncommingChannel recv_channel;
+ 	RecvHandler recv_handler;
+ 	Handler* callback_;  // for the upper layer protocol      
+ 
+ 
+ 	Node* node(void) const {return node_;}
+ 	// to process the incomming packet
+ 	virtual   void RecvProcess(Packet*);
+ 
+ 	// to process the outgoing packet
+ 	virtual  void TxProcess(Packet*);
+ 
+ 	// to receive packet from upper layer and lower layer 
+ 	virtual void recv(Packet*,Handler*); 
+ 
+ 
+ 	virtual  void sendUp(Packet*);
+ 	virtual  void sendDown(Packet*);
+ 
+ 	//void whoareyou();
+ 	void ResetTransmissionStatus();   
+ 	void IncommingChannelProcess(Event*); // process packet collision 
+ 	void Poweroff();
+ 	void Poweron();
+ 	void InterruptRecv(double);
+ 	double getTxTime(int pkt_len); //pkt_len is in byte
+ 	double getTxTime(Packet* pkt);
+ 	// The sending process can stop receiving process and change the transmission
+ 	// status of the node since underwatermac is half-deplex
+ 
+ 	//added by Yibo Zhu to get the sync hdr len from physical layer
+ 	double getSyncHdrLen();
+ 	double getForwardingDelay();
+ protected:
+ 	Node*	node_;// the node this mac is attached
+ 	bool	IsOFDMPhy_;
+ 
+ 
+ 	inline int initialized() {
+ 		return  (node_&&Mac::initialized());
+ 	}
+ private:
+ 
+ 	friend class RecvHandler;
+ };
+ 
+ #endif /* __uwmac_h__ */
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterphy.cc ns-2.35-aquasim/underwatersensor/uw_mac/underwaterphy.cc
*** ns-2.35/underwatersensor/uw_mac/underwaterphy.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterphy.cc	2016-09-03 00:34:05.968000000 +0800
***************
*** 0 ****
--- 1,488 ----
+ /*
+ This program is the modified version of phy.cc, it supports the periodic operation of sensor nodes---modified by xp at 2007
+ */
+ 
+ #include <math.h>
+ #include <packet.h>
+ #include <phy.h>
+ #include "underwaterpropagation.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include <modulation.h>
+ 
+ #include  "underwaterphy.h"
+ #include <packet.h>
+ #include "rmac.h"
+ #include "random.h"
+ 
+ void Underwater_Idle_Timer::expire(Event *) {
+ 	a_->UpdateIdleEnergy();
+ }
+ 
+ 
+ /* ======================================================================
+ UnderwaterPhy Interface
+ ====================================================================== */
+ static class UnderwaterPhyClass: public TclClass {
+ public:
+ 	UnderwaterPhyClass() : TclClass("Phy/UnderwaterPhy") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new UnderwaterPhy);
+ 	}
+ } class_UnderwaterPhy;
+ 
+ 
+ UnderwaterPhy::UnderwaterPhy() : Phy(), idle_timer_(this)
+ /*,sense_handler(this)*/
+ {
+ 	/*
+ 	*  It sounds like 10db should be the capture threshold.
+ 	*
+ 	*  If a node is presently receiving a packet a a power level
+ 	*  Pa, and a packet at power level Pb arrives, the following
+ 	*  comparion must be made to determine whether or not capture
+ 	*  occurs:
+ 	*
+ 	*    10 * log(Pa) - 10 * log(Pb) > 10db
+ 	*
+ 	*  OR equivalently
+ 	*
+ 	*    Pa/Pb > 10.>ResetSenseStatus();
+ 	*
+ 	*/
+ 	initTransitTime();
+ 	
+ 	
+ 	bind("CPThresh_", &CPThresh_);
+ 	bind("CSThresh_", &CSThresh_);
+ 	bind("RXThresh_", &RXThresh_);
+ 	bind("Pt_", &Pt_);
+ 	bind("freq_", &freq_);
+ 	bind("L_", &L_);
+ 	bind("K_", &K_);
+ 	bind("TurnOnEnergy", &Energy_turn_on_);
+ 	bind("TurnOffEnergy", &Energy_turn_off_);
+ 	
+ 	
+ 	bind("sync_hdr_len", &sync_hdr_len_);
+ 	bind("fowarding_delay", &fowarding_delay_);
+ 	
+ 	/*
+ 	bind("time_idle2send", &TransitTime[IDL][SEND]);
+ 	bind("time_send2idle", &TransitTime[SEND][IDL]);
+ 	bind("time_idle2recv", &TransitTime[IDL][RECV]);
+ 	bind("time_recv2idle", &TransitTime[RECV][IDL]);
+ 	bind("time_send2recv", &TransitTime[SEND][RECV]);
+ 	bind("time_recv2send", &TransitTime[RECV][SEND]);
+ 	*/
+ 	
+ 	bind("bit_error_rate", &bit_error_rate_);
+ 	
+ 	node_ = 0;
+ 	propagation_ = 0;
+ 	modulation_ = 0;
+ 	ant_=0;
+ 
+ 
+ 	Pt_consume_ = 0.660;  // 1.6 W drained power for transmission
+ 	Pr_consume_ = 0.395;  // 1.2 W drained power for reception
+ 	P_idle_ = 0.0;// 0 W drained power for idle
+ 
+ 	update_energy_time_ = NOW;
+ 
+ 	power_status=1;
+ 	// 	printf("underwaterphy: schedule update energy at %f\n",NOW);
+ 	idle_timer_.resched(1.0);
+ 	//Energy_turn_on_ = 0.0;
+ 	//Energy_turn_off_ = 0.0;
+ }
+ 
+ int
+ UnderwaterPhy::command(int argc, const char*const* argv)
+ {
+ 	TclObject *obj; 
+ 
+ 	if (argc==2) {
+ 		if (strcasecmp(argv[1], "PowerOn") == 0) {
+ 			if (em() == NULL) 
+ 				return TCL_OK;
+ 			power_on();
+ 			return TCL_OK;
+ 		}
+ 		else if (strcasecmp(argv[1], "PowerOff") == 0) {
+ 			if (em() == NULL) 
+ 				return TCL_OK;
+ 			power_off();
+ 			return TCL_OK;
+ 		}
+ 
+ 	} else if(argc == 3) {
+ 		if (strcasecmp(argv[1], "setTxPower") == 0) {
+ 			Pt_consume_ = atof(argv[2]);
+ 			//   printf("wireless-phy.cc: Pt_consume_=%f\n",Pt_consume_);
+ 			return TCL_OK;
+ 		} else if (strcasecmp(argv[1], "setRxPower") == 0) {
+ 			Pr_consume_ = atof(argv[2]);
+ 			return TCL_OK;
+ 		} else if (strcasecmp(argv[1], "setIdlePower") == 0) {
+ 			P_idle_ = atof(argv[2]);
+ 			return TCL_OK;
+ 		} else if( (obj = TclObject::lookup(argv[2])) == 0) {
+ 			fprintf(stderr,"UnderwaterPhy: %s lookup of %s failed\n", 
+ 				argv[1], argv[2]);
+ 			return TCL_ERROR;
+ 		} else if (strcmp(argv[1], "propagation") == 0) {
+ 			assert(propagation_ == 0); 
+ 			propagation_ = (Propagation*) obj;
+ 			return TCL_OK;
+ 		} else if (strcmp(argv[1], "antenna") == 0) {
+ 			assert(ant_ == 0); 
+ 			ant_ = (Antenna*) obj;
+ 			return TCL_OK;
+ 		} else if (strcasecmp(argv[1], "node") == 0) {
+ 			assert(node_ == 0);
+ 			node_ = (Node *)obj;
+ 			return TCL_OK;
+ 		}
+ 	}
+ 	return Phy::command(argc,argv);
+ }
+ 
+ void 
+ UnderwaterPhy::sendDown(Packet *p)
+ {
+ 	UnderwaterSensorNode* n1;
+ 	//int it=hdr_cmn::access(p)->next_hop();
+ 	//printf("ok, node %d is underwaterphy senddown to node %d at %f pidel is%f pt=%f and pr=%f\n",node_->address(),it,NOW,P_idle_,Pt_consume_,Pr_consume_);
+ 
+ 	//hdr_cmn* cmnh=HDR_CMN(p);
+ 
+ 	// printf("underwater phy: node %d, got the down packet  ptytype=%d at %f\n", node_->address(),cmnh->ptype_,NOW);   
+ 
+ 	/*
+ 	* Sanity Check
+ 	*/
+ 
+ 	assert(initialized());
+ 
+ 	n1=(UnderwaterSensorNode*) node_;
+ 
+ 
+ 	// this part is moved from routing protocol by peng xie at 12-20-06
+ 
+ 	if (n1->failure_status()==1){
+ 		printf ("underwaterphy %d: fails!!!!\n ", node_->address());
+ 		Packet::free(p);
+ 		return;
+ 	}
+ 
+ 
+ 	TransmissionStatus status=n1->TransmissionStatus(); 
+ 	// printf("underwater phy node %d: sendDown status is %d\n",
+ 	//         node_->address(),status);
+ 	if (em()){ 
+ 		if ((status==SLEEP) || (em()->energy()<=0)) {
+ 			Packet::free(p);
+ 			return;
+ 		}
+ 	}
+ 	// node is power-on and energy is greater 
+ 	switch (status){
+ 
+ 	  case SEND:
+ 		  {
+ 			  //  printf("underwater phy node %d: I am in sending state\n",node_->address());
+ 			  double txtime = hdr_cmn::access(p)->txtime();
+ 
+ 			  double start_time = NOW;
+ 			  double end_time = NOW+txtime;
+ 
+ 			  // update energy
+ 			  if (start_time >= update_energy_time_) {
+ 				  em()->DecrIdleEnergy(start_time - 
+ 					  update_energy_time_, P_idle_);
+ 				  update_energy_time_ = start_time;
+ 			  }
+ 			  else printf("underwater phy node %d: overlappd transmission %f and %f\n",node_->address(),start_time,update_energy_time_ );
+ 
+ 			  //minus the forwarding delay part
+ 			  //suppose modem cannot recv when the packet is experiencing forwarding delay
+ 			  em()->DecrIdleEnergy(forwarding_delay(), P_idle_);
+ 			  
+ 			  em()->DecrTxEnergy(txtime-forwarding_delay(), Pt_consume_);
+ 			  update_energy_time_ =end_time;
+ 			  break;
+ 		  }
+ 	  case IDL:
+ 		  {
+ 			  /* something wrong in this case since the transmitter is 
+ 			  transmitting some packet while a new packet arrives. 
+ 			  In this simulator, we can't handle this case
+ 			  */
+ 			  printf("UnderwaterPhy node(%d):mac forget to change the status at time %f\n",node_->address(),NOW);
+ 
+ 			  break;
+ 		  }
+ 	  case SLEEP: printf("underwaterphy: I am sleeping!!\n");
+ 		  break;
+ 	  default: printf("underwaterphy: no such default at all\n");
+ 	}//end of switch 
+ 
+ 
+ 	/*
+ 	*  Stamp the packet with the interface arguments
+ 	*/
+ 	if (!ant_) printf("ok, there is no antenna\n");
+ 	p->txinfo_.stamp((MobileNode*)node(), ant_->copy(), Pt_, lambda_);
+ 
+ 	channel_->recv(p, this);
+ }
+ 
+ 
+ 
+ 
+ int 
+ UnderwaterPhy::sendUp(Packet *p)
+ {
+ 	/*
+ 	* Sanity Check
+ 	*/
+ 
+ 	UnderwaterSensorNode* n1;
+ 	hdr_cmn* cmnh=HDR_CMN(p);
+ 
+ 	//  printf("underwater phy: node %d, got the upgoing packet  ptytype=%d at %f\n", node_->address(),cmnh->ptype_,NOW);
+ 	assert(initialized());
+ 
+ 	double rcvtime = hdr_cmn::access(p)->txtime();
+ 
+ 
+ 	n1=(UnderwaterSensorNode*) node_;  
+ 
+ 	// this part is moved from routing protocol by peng xie at 12-20-06 
+ 
+ 	if (n1->failure_status()==1){
+ 		printf ("underwaterphy %d: fails!!!!\n ", node_->address());
+ 		Packet::free(p);
+ 		return 0;
+ 	}
+ 	// mark the error on the incoming packet with probability recv_pro
+ 	/*here only set the percent of error packets*/
+ 	double recv_pro=n1->failure_pro();
+ 	double error_pro=Random::uniform();
+ 	if(error_pro<=recv_pro) cmnh->error()=1;       
+ 
+ 	TransmissionStatus status=n1->TransmissionStatus(); 
+ 	PacketStamp s;
+ 	double Pr;
+ 	int pkt_recvd = 0;
+ 
+ 	// if the node is in sleeping mode, drop the packet simply
+ 
+ 	if (em()) 
+ 		if ((status==SEND || status==SLEEP)||(em()->energy()<=0)) 
+ 		{
+ 			printf("receive failure: SEND, SLEEP or NO-ENERGY\n");
+ 			return pkt_recvd;
+ 		}
+ 
+ 		if(propagation_) {
+ 			s.stamp((MobileNode*)node(), ant_, 0, lambda_);
+ 			Pr = propagation_->Pr(&p->txinfo_, &s, this);
+ 			if (Pr < CSThresh_) {
+ 				printf("underwaterphy: Pr<CSThresh_,signal is too weak\n");
+ 				return pkt_recvd;		       
+ 			}
+ 
+ 		}
+ 
+ 		if(modulation_) {
+ 			hdr_cmn *hdr = HDR_CMN(p);
+ 			hdr->error() = modulation_->BitError(Pr);
+ 		}
+ 		else {
+ 			hdr_cmn *hdr = HDR_CMN(p);
+ 			hdr->error() = DefaultBitError(hdr->size());
+ 		}
+ 
+ 
+ 
+ 		p->txinfo_.RxPr = Pr;
+ 		p->txinfo_.CPThresh = CPThresh_;
+ 
+ 		double start_time =NOW;
+ 		double end_time = NOW+rcvtime;
+ 
+ 		if (start_time > update_energy_time_) {
+ 			em()->DecrIdleEnergy(start_time-update_energy_time_,P_idle_);
+ 			em()->DecrRcvEnergy(rcvtime,Pr_consume_);
+ 			update_energy_time_ = end_time;
+ 		}
+ 		else{
+ 			/* In this case, this node is receiving some packet*/ 
+ 			if(end_time>update_energy_time_){
+ 				em()->DecrRcvEnergy(end_time-update_energy_time_,Pr_consume_);
+ 				update_energy_time_ = end_time;
+ 			}
+ 		}
+ 
+ 		if (Pr < RXThresh_) {
+ 
+ 			/*
+ 			* We can detect, but not successfully receive
+ 			* this packet.
+ 			*/
+ 			printf("underwaterphy: Pr<RXThresh_,signal is too weak\n");
+ 			return pkt_recvd;		     		      
+ 		}
+ 
+ 		if (em()->energy() <= 0) {  
+ 			// saying node died
+ 			em()->setenergy(0);
+ 			((MobileNode*)node())->log_energy(0);
+ 		}
+ 	//	printf("underwaterphy: received!!!!\n");
+ 
+ 		return 1;
+ }
+ 
+ 
+ int UnderwaterPhy::DefaultBitError(int pktsize)
+ {
+ 	double pkt_correct_pro = pow(1-bit_error_rate_, pktsize);
+ 	
+ 	if( Random::uniform() < pkt_correct_pro )
+ 		return 0;
+ 	else
+ 		return 1;
+ }
+ 
+ 
+ void 
+ UnderwaterPhy::ResetSenseStatus()
+ {
+ 	return;
+ 
+ 	/*
+ 	since we move the sense carrier to mac layer, this function 
+ 	does nothing. 
+ 
+ 	UnderwaterSensorNode* n1=(UnderwaterSensorNode*) node_;
+ 	n1->ResetCarrierSense(); 
+ 	*/
+ }
+ 
+ 
+ void
+ UnderwaterPhy::power_on()
+ {
+ 	power_status=1;
+ 	if (em() == NULL)
+ 		return;	
+ 	//minus the energy consumed by power on, Added by Yibo
+ 	if( em()->energy() < Energy_turn_on_ )
+ 		em()->setenergy(0.0);
+ 	else
+ 		em()->setenergy(em()->energy() - Energy_turn_on_);
+ 
+ 	if (NOW > update_energy_time_) {
+ 		update_energy_time_ = NOW;
+ 	}
+ }
+ 
+ void 
+ UnderwaterPhy::power_off()
+ {
+ 	power_status=0;
+ 	if (em() == NULL)
+ 		return;
+ 
+ 	//minus the energy consumed by power on. Added by Yibo
+ 	if( em()->energy() < Energy_turn_off_ )
+ 		em()->setenergy(0.0);
+ 	else
+ 		em()->setenergy(em()->energy() - Energy_turn_off_);
+ 
+ 	if (NOW > update_energy_time_) {
+ 		em()->DecrIdleEnergy(NOW-update_energy_time_,
+ 			P_idle_);
+ 		update_energy_time_ = NOW;
+ 	}
+ 
+ 	printf("node %d is poweroff energy is %f at %f\n",node_->address(),em()->energy(),NOW);
+ 
+ 
+ }
+ 
+ void
+ UnderwaterPhy::dump(void) const
+ {
+ 	Phy::dump();
+ 	fprintf(stdout,
+ 		"\tPt: %f, Gt: %f, Gr: %f, lambda: %f, L: %f\n",
+ 		Pt_, ant_->getTxGain(0,0,0,lambda_), ant_->getRxGain(0,0,0,lambda_), lambda_, L_);
+ 	//fprintf(stdout, "\tbandwidth: %f\n", bandwidth_);
+ 	fprintf(stdout, "--------------------------------------------------\n");
+ }
+ 
+ 
+ void UnderwaterPhy::UpdateIdleEnergy()
+ {
+ 	if(power_status==0) return;
+ 	if (em() == NULL) {
+ 		return;
+ 	}
+ 	if (NOW > update_energy_time_ && em()->node_on()) {
+ 		em()-> DecrIdleEnergy(NOW-update_energy_time_,
+ 			P_idle_);
+ 		update_energy_time_ = NOW;
+ 	}
+ 
+ 	// log node energy
+ 	if (em()->energy() > 0) {
+ 		((MobileNode *)node_)->log_energy(1);
+ 	} else {
+ 		((MobileNode *)node_)->log_energy(0);   
+ 	}
+ 
+ 	//    printf("underphy: schedule energy update at %f \n",NOW);
+ 	idle_timer_.resched(1.0);
+ }
+ 
+ void 
+ UnderwaterPhy::status_shift(double  txtime)
+ {
+ 
+ 	//   double txtime = hdr_cmn::access(p)->txtime();
+ 	double end_time=NOW+txtime;
+ 	/*  The receiver is receiving a packet when the 
+ 	transmitter begins to transmit a data. 
+ 	We assume the half-duplex mode, the transmitter 
+ 	stops the receiving process and begins the sending
+ 	process.
+ 	*/
+ 
+ 	if(update_energy_time_<end_time)
+ 	{
+ 		double  overlap_time=update_energy_time_-NOW;
+ 		double  actual_txtime=end_time-update_energy_time_;
+ 		em()->DecrTxEnergy(overlap_time,
+ 			Pt_consume_-Pr_consume_);
+ 		em()->DecrTxEnergy(actual_txtime,Pt_consume_); 
+ 		update_energy_time_=end_time;
+ 	}
+ 	else {
+ 		double overlap_time=txtime;
+ 		em()->DecrTxEnergy(overlap_time,
+ 			Pt_consume_-Pr_consume_);
+ 	}
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterphy.h ns-2.35-aquasim/underwatersensor/uw_mac/underwaterphy.h
*** ns-2.35/underwatersensor/uw_mac/underwaterphy.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterphy.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,148 ----
+ /*
+ This program is the modified version of phy.h, it supports the periodic operation of sensor nodes---modified by xp at 2007
+ 
+ */
+ 
+ #ifndef ns_underwaterphy_h
+ #define ns_underwaterphy_h
+ 
+ #include "propagation.h"
+ #include "underwaterpropagation.h"
+ #include "modulation.h"
+ #include "phy.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "timer-handler.h"
+ 
+ class Phy;
+ class UnderwaterPropagation;
+ class UnderwaterPhy;
+ 
+ 
+ 
+ 
+ 
+ class Underwater_Idle_Timer : public TimerHandler {
+ public:
+ 	Underwater_Idle_Timer(UnderwaterPhy *a) : TimerHandler() { a_ = a; }
+ protected:
+ 	virtual void expire(Event *e);
+ 	UnderwaterPhy *a_;
+ };
+ 
+ class UnderwaterPhy : public Phy {
+ public:
+ 	UnderwaterPhy();
+ 
+ 	void sendDown(Packet *p);
+ 	int sendUp(Packet *p);
+ 
+ 	inline double getEnergyspread(){ return K_;} 
+ 	inline double getFrequency(){return freq_;}   
+ 	inline double getL() const {return L_;}
+ 	//inline double getLambda() const {return lambda_;}
+ 	inline Node* node(void) const { return node_; }
+ 	inline double getPtconsume() { return Pt_consume_; }
+ 	// inline PhyStatus getPhyStatus(){return status_;}
+ 	virtual int command(int argc, const char*const* argv);
+ 	virtual void dump(void) const;
+ 
+ 	void ResetSenseStatus();
+ 	void power_on();
+ 	void power_off();
+ 	void status_shift(double);
+ 
+ 	/* -NEW- */
+ 	inline double getAntennaZ() { return ant_->getZ(); }
+ 	inline double getPt() { return Pt_; }
+ 	inline double getRXThresh() { return RXThresh_; }
+ 	inline double getCSThresh() { return CSThresh_; }
+ 	/* End -NEW- */
+ 
+ 	inline double getLambda() { return lambda_; }
+ 	inline Antenna* getAntenna() { return ant_; }
+ 	inline void txtime();
+ 	
+ 	inline double sync_hdr_len() { return sync_hdr_len_; }
+ 	inline double forwarding_delay() { return fowarding_delay_; }
+ 
+ 	void initTransitTime() {
+ 		int i, j;
+ 		for( i=0; i<NStatus; i++ ) 
+ 			for( j=0; j<NStatus; j++ ) 
+ 				TransitTime[i][j] = 0.0;
+ 	}
+ 	
+ 	inline double getTransitTime(enum TransmissionStatus current_status, 
+ 							   enum TransmissionStatus new_status)		{
+ 		return TransitTime[current_status][new_status];	  
+ 	}
+ 	
+ 	int DefaultBitError(int pktsize);
+ 	
+ protected:
+ 	double Pt_;		// transmitted signal power (W)
+ 	double Pt_consume_;	// power consumption for transmission (W)
+ 	double Pr_consume_;	// power consumption for reception (W)
+ 	double P_idle_;         // idle power consumption (W)
+ 	//double last_send_time_;	// the last time the node sends somthing.
+ 	//double channel_idle_time_;	// channel idle time.
+ 	double update_energy_time_;	// the last time we update energy.
+ 
+ 	double freq_;           // frequency
+ 	double K_;              // energy spread factor
+ 	double lambda_;		// wavelength (m), we don't use it anymore
+ 	double L_;		// system loss default factor
+ 
+ 	double RXThresh_;	// receive power threshold (W)
+ 	double CSThresh_;	// carrier sense threshold (W)
+ 	double CPThresh_;	// capture threshold (db)
+ 	
+ 	//added by Yibo Zhu to simulation the syncronization header of modems
+ 	//the txtime of the syncronization header of the packet (sec)
+ 	//default value: 0
+ 	double sync_hdr_len_;		//in seconds
+ 	double fowarding_delay_;
+ 	//transition delays
+ 
+ 
+ 	Antenna *ant_;
+ 	// we don't use it anymore, however we need it as an arguments
+ 	Propagation *propagation_;	// Propagation Model
+ 	Modulation *modulation_;	// Modulation Schem
+ 
+ 
+ 	double TransitTime[NStatus][NStatus];  //the transition time between 
+ 
+ 	Underwater_Idle_Timer idle_timer_;
+ 
+ 	//Added by Yibo.
+ 	double Energy_turn_on_;	//energy consumption for turning on the modem (J)
+ 	double Energy_turn_off_; //energy consumption for turning off the modem (J)
+ 	
+ 	double bit_error_rate_;  //default value: 0.0
+ 
+ 	// SenseHandler sense_handler;
+ 
+ 	// Event sense_event;
+ 	//UnderwaterPhy_Status_Timer status_timer;
+ 	// Event  status_update;  	
+ 	//	PhyStatus status_;
+ //private:    //to make sure its sub-class use the member of this class
+ 			  //sufficiently, I change private to protected
+ protected:
+ 	inline int initialized() {
+ 		return (node_ && uptarget_ && downtarget_ && propagation_);
+ 	}
+ 	void UpdateIdleEnergy();
+ 	int power_status;  //1: power on 0:power off
+ 	// void ResetStatus();
+ 	// Convenience method
+ 	EnergyModel* em() { return node()->energy_model(); }
+ 
+ 	friend class Underwater_Idle_Timer;
+ 	//        friend class SenseHandler;
+ 	// friend class UnderwaterPhy_Status_Timer;
+ };
+ 
+ #endif /* !ns_UnderwaterPhy_h */
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterpropagation.cc ns-2.35-aquasim/underwatersensor/uw_mac/underwaterpropagation.cc
*** ns-2.35/underwatersensor/uw_mac/underwaterpropagation.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterpropagation.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,97 ----
+ 
+ #include <stdio.h>
+ #include <topography.h>
+ #include "underwaterpropagation.h"
+ #include  "underwaterphy.h"
+ 
+ class PacketStamp;
+ 
+ 
+ static class UnderwaterPropagationClass: public TclClass {
+ public:
+   UnderwaterPropagationClass() : TclClass("Propagation/UnderwaterPropagation") {}
+         TclObject* create(int, const char*const*) {
+                 return (new UnderwaterPropagation);
+         }
+ } class_underwaterpropagation;
+ 
+ 
+ 
+ 
+ int
+ UnderwaterPropagation::command(int argc, const char*const* argv)
+ {
+   TclObject *obj;  
+ 
+   if(argc == 3) 
+     {
+       if( (obj = TclObject::lookup(argv[2])) == 0) 
+ 	{
+ 	  fprintf(stderr, "Propagation: %s lookup of %s failed\n", argv[1],
+ 		  argv[2]);
+ 	  return TCL_ERROR;
+ 	}
+ 
+       if (strcasecmp(argv[1], "topography") == 0) 
+ 	{
+ 	  topo = (Topography*) obj;
+ 	  return TCL_OK;
+ 	}
+     }
+   return TclObject::command(argc,argv);
+ }
+  
+ double
+ UnderwaterPropagation::Pr(PacketStamp * t, PacketStamp * r, UnderwaterPhy * ifp)
+ {
+ 	double F = ifp->getFrequency();	     // frequency range
+ 	double K = ifp->getEnergyspread();   // spreading factor
+    
+ 	double Xt, Yt, Zt;		// location of transmitter
+ 	double Xr, Yr, Zr;		// location of receiver
+ 
+ 	t->getNode()->getLoc(&Xt, &Yt, &Zt);
+ 	r->getNode()->getLoc(&Xr, &Yr, &Zr);
+  
+ 
+ 
+ 	double dX = Xr - Xt;
+ 	double dY = Yr - Yt;
+ 	double dZ = Zr - Zt;
+ 	double d = sqrt(dX * dX + dY * dY + dZ * dZ);
+ 
+ 
+ 	// calculate receiving power at distance
+ 
+ 	double Pr = t->getTxPr()/Attenuation(d,K,F);
+ 	//   printf("underwaterpropagation: original power is %f and the received power is %f\n",t->getTxPr(),Pr); 
+ 	return Pr;
+ }
+ 
+ 
+ double 
+ UnderwaterPropagation::Attenuation(double d, double k, double f)
+ {
+ 
+ 
+   /* the distance unit used for absorption coefficient is km,  
+      but for the attenuation, the used unit is meter 
+    */
+ 
+   //printf("the distance is %f and k is %f and frequency is %f\n",d,k,f);
+   double d1=d/1000.0; // convert to km 
+   double t1=pow(d,k);
+   double alpha_f=Thorp(f);
+   //printf("the alpha_f is %f\n",alpha_f);
+   double alpha=pow(10.0,(alpha_f/10.0));
+   //printf("the alpha is %f\n",alpha);
+   double t3=pow(alpha,d1);
+   // printf("t1 is %f and  t3  is %f and attenuation is %f\n",t1,t3,t1*t3);
+   return t1*t3;
+ }
+ 
+ double
+ UnderwaterPropagation::Thorp(double f){
+   return 0.11*((f*f)/(1.0+(f*f)))+44.0*((f*f)/(4100.0+(f*f)))
+     +2.75*((f*f)/10000.0)+0.0003;
+ }
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterpropagation.h ns-2.35-aquasim/underwatersensor/uw_mac/underwaterpropagation.h
*** ns-2.35/underwatersensor/uw_mac/underwaterpropagation.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterpropagation.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,37 ----
+ 
+ 
+ #ifndef ns_underwaterpropagation_h
+ #define ns_underwaterpropagation_h
+ 
+ 
+ 
+ #define SPEED_OF_SOUND_IN_WATER	1500  //actual speed of sound in water
+ 
+ #include <topography.h>
+ #include <packet-stamp.h>
+ #include "underwaterphy.h"
+ 
+ class PacketStamp;
+ class UnderwaterPhy;
+ 
+ class UnderwaterPropagation : public TclObject {
+ 
+ public:
+   UnderwaterPropagation() : name(NULL), topo(NULL) {}
+ 
+   // calculate the Pr by which the receiver will get a packet sent by
+   // the node that applied the tx PacketStamp for a given inteface 
+   // type
+   
+   double  Attenuation(double, double, double);
+   double  Thorp(double);
+   virtual double Pr(PacketStamp *tx, PacketStamp *rx, UnderwaterPhy *);
+   virtual int command(int argc, const char*const* argv);
+ 
+ protected:
+   char *name;
+   Topography *topo;
+ };
+ 
+ #endif /* __underwaterpropagation_h__ */
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterstaticmac.cc ns-2.35-aquasim/underwatersensor/uw_mac/underwaterstaticmac.cc
*** ns-2.35/underwatersensor/uw_mac/underwaterstaticmac.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterstaticmac.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,341 ----
+ 
+ 
+ #include "delay.h"
+ #include "connector.h"
+ #include "packet.h"
+ #include "random.h"
+ #include "mobilenode.h"
+ 
+ // #define DEBUG 99
+ 
+ #include "arp.h"
+ #include "ll.h"
+ #include "mac.h"
+ #include "mac-timers.h"
+ #include "uwstaticmac.h"
+ #include "cmu-trace.h"
+ 
+ // Added by Sushmita to support event tracing
+ #include "agent.h"
+ #include "basetrace.h"
+ 
+ 
+ 
+ void
+ IncommingChannel::AddNewPacket(Packet* p){
+   Packet* t1;
+   IncommingPacket* t2;
+   t1=new IncommingPacket;
+   t1->next=NULL;
+   t1->packet=p;
+   t1->status=RECEPTION;
+   
+   // insert this packet at the head of the link
+   t2=head;
+   head=t1;
+   t1->next=t2;
+   //
+   TotalSignalStrength=TotalSignalStrength+p->txinfo_.RxPr;
+   UpdatePacketStatus();
+ }
+ 
+ int
+ IncommingChannel::DeletePacket(Packet* p){
+   Packet* t1;
+   IncommingPacket* t2;
+   
+   // insert this packet at the head of the link
+   t2=head;
+ 
+   if (!t2) return 0;//0 no such point, 1:delete this point
+ 
+   if (t2==p){
+     head=t2->next;
+     num_of_active_incomming_packet--;
+     TotalSignalStrength=TotalSignalStrength-p->txinfo_.RxPr;
+     delete t2;
+     return 1;
+ }
+  
+   int modified=0;
+   while(t2->next){
+     if ((t2->next)->packet!=p) t2=t2->next;
+     else{
+      IncommingPacket* t1;
+   
+      t1=t2->next;
+      t2->next=t1->next;
+      num_of_active_incomming_packet--;
+     TotalSignalStrength=TotalSignalStrength-p->txinfo_.RxPr;
+     delete t2;
+     modify=1;
+     }
+   }
+   
+   return modified;
+ }
+ 
+ int
+ IncommingChannel::Packetstatus(Packet* p){
+   Packet* t1;
+   IncommingPacket* t2;
+   
+   t2=head;
+ 
+ 
+  
+   while(t2->packet!=p)&&(!t2) t2=t2->next;
+ 
+   if (!t2) {
+     printf("IncommingChannel:oops! no such packet\n");
+ return INVALID;
+   }
+   else return t2->status;
+ }
+ 
+ void
+ IncommingChannel::UpdatePacketStatus(){
+   InCommingPacket * t1;
+   t1=head;
+   while(!t1)
+     {
+       double noise=TotalSignalStrength-(t1->packet)->txinfo_.RxPr;
+       if (noise<0) {
+          printf("IncommingChannel: what a hell!\n");
+ 	 exit(0);
+       }
+ 
+   if ((t1->packet)->txinfo_.RxPr/noise >= (t1->packet)->txinfo_.CPThresh))
+       t1->status=RECEPTION
+ 	else t1->status=COLLISION;
+ }
+ 
+ void RecvHandler::handle(Event* e)
+ {
+   mac->RecvProcess(Event* e);
+ }
+ 
+ 
+ void
+ UWMac::RecvProcess(Event* e){
+   IncommingPacket* p;
+   Packet* target=(Packet*) e;
+      
+   p=recv_channel.lookup(target);
+   if (COLLISION==p.PacketStatus()) {
+             recv_channel.DeletePacket(p);
+ 	    Packet::free(p);  
+ 	    return;
+   }
+ 
+   if (INVALID==p.PacketStatus()) {
+             recv_channel.DeletePacket(p);
+ 	    Packet::free(p);  
+ 	    return;
+   }
+  
+  if (RECEPTION==p.PacketStatus()) {
+             recv_channel.DeletePacket(p);
+             RecvHandler(p);
+  }
+ }
+ 
+ 
+ /*
+  this program is used to handle the received packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ UwMac::RecvHandler(Packet* p){
+ }
+ 
+ 
+ /*
+  this program is used to handle the transmitted packet, 
+ it should be virtual function, different class may have 
+ different versions.
+ */
+ 
+ void 
+ UWStaticMac::TxHandler(Packet* p){
+ }
+ 
+ 
+ 
+ void
+ UwStaticMac::recv(Packet *p, Handler *h)
+ {
+ 	struct hdr_cmn *hdr = HDR_CMN(p);
+ 	
+         /*
+ 	 * Sanity Check
+ 	 */
+ 
+ 	assert(initialized());
+ 
+ 
+ 
+ 	/*
+ 	 *  Handle outgoing packets.
+ 	 */
+ 
+ 	if(hdr->direction() == hdr_cmn::DOWN) {
+ 	  TxHandler(p);
+                 return;
+         }
+ 
+ 	/*
+ 	 *  Handle incoming packets.
+ 	 *
+ 	 *  We just received the 1st bit of a packet on the network
+ 	 *  interface.
+ 	 *
+ 	 */
+ 
+ 
+ 	recv_channel.AddNewPacket(p);
+         double txtime=har_cmn::access(p)->txtime();
+         Scheduler& s=Scheduler::instance();
+         s.schedule(recv_handler,p,txtime);     
+ }
+ 
+ 
+ 
+ 
+ /* ======================================================================
+    TCL Hooks for the simulator
+    ====================================================================== */
+ static class Mac802_11Class : public TclClass {
+ public:
+ 	Mac802_11Class() : TclClass("Mac/802_11") {}
+ 	TclObject* create(int, const char*const*) {
+ 	// change wrt Mike's code
+ 	// return (new Mac802_11(&PMIB, &MMIB));
+ 	return (new Mac802_11());
+ 	// Mike change ends!
+ 
+ }
+ } class_mac802_11;
+ 
+ 
+ Mac802_11::Mac802_11() : Mac(), mhIF_(this), mhNav_(this), mhRecv_(this), mhSend_(this), mhDefer_(this), mhBackoff_(this),macmib_(this), phymib_(this), mhBeacon_(this)
+ // Mike change ends
+ {
+ 	// change wrt Mike
+ 	//macmib_ = m;
+ 	//phymib_ = p;
+ 	// change ends
+ 	
+ 	nav_ = 0.0;
+ 	
+ 	tx_state_ = rx_state_ = MAC_IDLE;
+ 	tx_active_ = 0;
+ 
+ 	// change wrt Mike
+ 	eotPacket_ = NULL;
+ 	// change ends
+ 
+ 
+ 	pktRTS_ = 0;
+ 	pktCTRL_ = 0;
+ 		
+ 	// change wrt Mike's code
+ 	//cw_ = phymib_->CWMin;
+ 	cw_ = phymib_.getCWMin();
+ 	// change ends
+ 
+ 
+ 	ssrc_ = slrc_ = 0;
+ 
+ 	// change wrt Mike's code
+ 
+ 	//sifs_ = phymib_->SIFSTime;
+ 	//pifs_ = sifs_ + phymib_->SlotTime;
+ 	//difs_ = sifs_ + 2*phymib_->SlotTime;
+ 	
+ 	// see (802.11-1999, 9.2.10) 
+ 	//eifs_ = sifs_ + (8 * ETHER_ACK_LEN / phymib_->PLCPDataRate) + difs_;
+ 	
+ 	//tx_sifs_ = sifs_ - phymib_->RxTxTurnaroundTime;
+ 	//tx_pifs_ = tx_sifs_ + phymib_->SlotTime;
+ 	//tx_difs_ = tx_sifs_ + 2 * phymib_->SlotTime;
+ 
+ 	// Added by Sushmita
+         et_ = new EventTrace();
+ 	
+ 	sta_seqno_ = 1;
+ 	cache_ = 0;
+ 	cache_node_count_ = 0;
+ 	
+ 	// chk if basic/data rates are set
+ 	// otherwise use bandwidth_ as default;
+ 	
+ 	Tcl& tcl = Tcl::instance();
+ 	tcl.evalf("Mac/802_11 set basicRate_");
+ 	if (strcmp(tcl.result(), "0") != 0) 
+ 		bind_bw("basicRate_", &basicRate_);
+ 	else
+ 		basicRate_ = bandwidth_;
+ 
+ 	tcl.evalf("Mac/802_11 set dataRate_");
+ 	if (strcmp(tcl.result(), "0") != 0) 
+ 		bind_bw("dataRate_", &dataRate_);
+ 	else
+ 		dataRate_ = bandwidth_;
+ 
+ 	// change wrt Mike
+         EOTtarget_ = 0;
+        	bss_id_ = IBSS_ID;
+ 	//-ak-----------
+ 	//printf("bssid in constructor %d\n",bss_id_);
+ 
+ 
+ 	// change ends
+ 	//	printf("mac-802_11.datarateis %f, abd bandwidth is%f\n",dataRate_,bandwidth_);
+ 
+ }
+ 
+ 
+ int
+ Mac802_11::command(int argc, const char*const* argv)
+ {
+ 	if (argc == 3) {
+ 		// change wrt Mike
+ 		//if (strcmp(argv[1], "log-target") == 0) {
+ 		 if (strcmp(argv[1], "eot-target") == 0) {
+                          EOTtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+                          if (EOTtarget_ == 0)
+                                  return TCL_ERROR;
+                          return TCL_OK;
+                } else if (strcmp(argv[1], "bss_id") == 0) {
+                        bss_id_ = atoi(argv[2]);
+ 
+ //-ak-----		       
+ //printf("in command bssid %d \n",bss_id_);
+ 
+                        return TCL_OK;
+                  } else if (strcmp(argv[1], "log-target") == 0) {
+ 		// change ends
+  
+  		logtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+ 			if(logtarget_ == 0)
+ 				return TCL_ERROR;
+ 			return TCL_OK;
+ 		} else if(strcmp(argv[1], "nodes") == 0) {
+ 			if(cache_) return TCL_ERROR;
+ 			cache_node_count_ = atoi(argv[2]);
+ 			cache_ = new Host[cache_node_count_ + 1];
+ 			assert(cache_);
+ 			bzero(cache_, sizeof(Host) * (cache_node_count_+1 ));
+ 			return TCL_OK;
+ 		} else if(strcmp(argv[1], "eventtrace") == 0) {
+ 			// command added to support event tracing by Sushmita
+                         et_ = (EventTrace *)TclObject::lookup(argv[2]);
+                         return (TCL_OK);
+                 }
+ 	}
+ 	return Mac::command(argc, argv);
+ }
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/underwaterstaticmac.h ns-2.35-aquasim/underwatersensor/uw_mac/underwaterstaticmac.h
*** ns-2.35/underwatersensor/uw_mac/underwaterstaticmac.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/underwaterstaticmac.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,78 ----
+ #ifndef ns_uwmac_h
+ #define ns_uwmac_h
+ 
+ enum PacketStatus{RECEPTION,COLLISION,/*SENSED,*/ INVALID};
+ struct IncommingPacket{
+   Packet* pakcet;
+   PacketStatus status;
+   IncommingPacket* next;
+ }
+ 
+ 
+ 
+ class IncommingChannel{
+  public: 
+        IncommingChannel(){
+                   head_=NULL; 
+                   num_of_active_incomming_packet=0;
+                   TotalSignakStrength=0;
+                           };
+       
+     void AddNewPacket(Packet*);
+     int  DeletePacket(Packet*);
+     PacketStatus PacketStatus();
+     int num_of_active_incomimng_packet;// number of incomming packets
+     double TotalSignalStrength;// total amount of incomming transmission power
+  private:
+         Incommingpacket* head;
+         void UpdatePacketStatus();
+ };
+ 
+ 
+ Class RecvHandler: public Handler{
+  public:
+   RecvHandler(UwStaticMac* p):mac(p){}
+   void handle(Event*);
+  private:
+   UnderwaterPhy* mac;
+ }
+ 
+ class UWMac: public Mac {
+ 
+ public:
+          UWMac();
+         PacketQueue tx_buffer;
+         InCommingChannel recv_channel;
+         RecvHandler recv_handler;
+         void RecvProcess();
+ 
+ 
+ protected:
+ 
+ private:
+ 	int		command(int argc, const char*const* argv);
+ 
+ 
+ 
+ 	inline int initialized() {
+ 	return (cache_ && logtarget_
+                         && Mac::initialized());
+ 
+ 	}
+ 
+ 
+ 	inline void mac_log(Packet *p) {
+                 logtarget_->recv(p, (Handler*) 0);
+         }
+ 
+ 
+ 
+ protected:
+ 
+ 
+ private:
+ 
+ };
+ 
+ #endif /* __uwmac_h__ */
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/uwaloha/uwaloha.cc ns-2.35-aquasim/underwatersensor/uw_mac/uwaloha/uwaloha.cc
*** ns-2.35/underwatersensor/uw_mac/uwaloha/uwaloha.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwaloha/uwaloha.cc	2016-09-03 00:44:56.244000000 +0800
***************
*** 0 ****
--- 1,372 ----
+ #include "packet.h"
+ #include "random.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "mac.h"
+ #include "uwaloha.h"
+ #include "../underwaterphy.h"
+ 
+ 
+ int hdr_UWALOHA::offset_;
+ static class UWALOHA_HeaderClass: public PacketHeaderClass{
+ public:
+ 	UWALOHA_HeaderClass():PacketHeaderClass("PacketHeader/UWALOHA",sizeof(hdr_UWALOHA))
+ 	{
+ 		bind_offset(&hdr_UWALOHA::offset_);
+ 	}
+ }class_UWALOHA_hdr;
+ 
+ 
+ static class UWALOHAClass : public TclClass {
+ public:
+ 	UWALOHAClass():TclClass("Mac/UnderwaterMac/UWALOHA") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new UWALOHA());
+ 	}
+ }class_UWALOHA;
+ 
+ 
+ 
+ /*===========================UWALOHA Timer===========================*/
+ long UWALOHA_ACK_RetryTimer::id_generator = 0;
+ 
+ void UWALOHA_ACK_RetryTimer::expire(Event* e)
+ {
+ 	  mac_->processRetryTimer(this);
+ }
+ 
+ void UWALOHA_BackoffTimer::expire(Event *e)
+ {
+ 	mac_->sendDataPkt();
+ }
+ 
+ void UWALOHA_WaitACKTimer::expire(Event *e) //WaitACKTimer expire
+ {
+ 	mac_->doBackoff();	
+ }
+ 
+ 
+ 
+ //construct function
+ UWALOHA::UWALOHA(): UnderwaterMac(), bo_counter(0), UWALOHA_Status(PASSIVE), Persistent(1.0),
+ 		ACKOn(1), Min_Backoff(0.0), Max_Backoff(1.5), MAXACKRetryInterval(0.05), 
+ 		blocked(false), BackoffTimer(this), WaitACKTimer(this),
+ 		CallBack_handler(this), status_handler(this)
+ {
+ 	MaxPropDelay = UnderwaterChannel::Transmit_distance()/1500.0;
+ 
+ 	bind("Persistent",&Persistent);
+ 	bind("ACKOn",&ACKOn);
+ 	bind("Min_Backoff",&Min_Backoff);
+ 	bind("Max_Backoff",&Max_Backoff);
+ 	bind("WaitACKTime",&WaitACKTime);
+ }
+ 
+ 
+ void UWALOHA::doBackoff()
+ {
+ //	printf("node %d doBackoff at %f \n", index_,NOW);
+ 	  Time BackoffTime=Random::uniform(Min_Backoff,Max_Backoff);
+ 	  bo_counter++;
+ 	  if (bo_counter < MAXIMUMCOUNTER) {
+ 		  UWALOHA_Status = BACKOFF;
+ 		  BackoffTimer.resched(BackoffTime);
+ 	  }
+ 	  else {
+ 		  bo_counter=0;
+ 		  printf("backoffhandler: too many backoffs\n");
+ 		  Packet::free(PktQ_.front());
+ 		  PktQ_.pop();
+ 		  processPassive();		
+ 	  }
+ }
+ 
+ 
+ void UWALOHA::processPassive()
+ {
+ 	if (UWALOHA_Status == PASSIVE && !blocked) {
+ 		if (!PktQ_.empty() )
+ 			sendDataPkt();
+ 	}
+ }
+ 
+ 
+ void UWALOHA_StatusHandler::handle(Event *e)//What's this?
+ {
+ 	mac_->StatusProcess(is_ack_);
+ }
+ 
+ void UWALOHA_CallBackHandler::handle(Event* e)
+ {
+ 	mac_->CallbackProcess(e);
+ }
+ 
+ void UWALOHA::StatusProcess(bool is_ack)
+ {
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	n->SetTransmissionStatus(IDL);
+ 	
+ 	if( blocked ) {
+ 		blocked = false;
+ 		processPassive();
+ 		return;
+ 	}
+ 	
+ 	if( !ACKOn ) {
+ 		/*Must be DATA*/
+ 		UWALOHA_Status = PASSIVE;
+ 		processPassive();
+ 	}
+ 	else if (ACKOn && !is_ack ) {
+ 		UWALOHA_Status = WAIT_ACK;
+ 	}
+ 	
+ }
+ 
+ void UWALOHA::CallbackProcess(Event* e)
+ {
+ 	callback_->handle(e);
+ }
+ 
+ 
+ /*===========================Send and Receive===========================*/
+ 
+ void UWALOHA::TxProcess(Packet* pkt)
+ {
+ 	Scheduler::instance().schedule(&CallBack_handler, &callback_event, CALLBACK_DELAY);
+ 
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_UWALOHA* UWALOHAh = hdr_UWALOHA::access(pkt);
+ 	cmh->size() += hdr_UWALOHA::size();
+ 	cmh->txtime() = getTxTime(cmh->size());
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 
+ 	Time t = NOW;
+ 	if( t > 500 ) 
+ 	  t = NOW;
+ 	UWALOHAh->packet_type = hdr_UWALOHA::DATA;
+ 	UWALOHAh->SA = index_;
+ 	
+ 	if( cmh->next_hop() == (nsaddr_t)IP_BROADCAST ) {
+ 		UWALOHAh->DA = MAC_BROADCAST;
+ 	}
+ 	else {
+ 		UWALOHAh->DA = cmh->next_hop();
+ 	}
+ 
+ 	PktQ_.push(pkt);//push packet to the queue
+ 	
+ 	//fill the next hop when sending out the packet;
+ 	if(UWALOHA_Status == PASSIVE 
+ 		&& PktQ_.size() == 1 && !blocked ) 
+ 	{
+ 		sendDataPkt();
+ 	}
+ }
+ 
+ 
+ void UWALOHA::sendDataPkt()
+ {	
+ 	double P = Random::uniform(0,1);
+ 	Packet* tmp = PktQ_.front();
+ 	nsaddr_t recver = HDR_CMN(tmp)->next_hop();
+ 	
+ 	UWALOHA_Status = SEND_DATA;
+ 	
+ 	if( P<=Persistent ) {
+ 		if( HDR_CMN(tmp)->next_hop() == recver )// {
+ 			sendPkt(tmp->copy());
+ 	}
+ 	else {
+ 		//Binary Exponential Backoff
+ 		bo_counter--;
+ 		doBackoff();
+ 	}
+ 
+ 	return;
+ 
+ }
+ 
+ 
+ void UWALOHA::sendPkt(Packet *pkt)
+ {
+ 	hdr_cmn* cmh=HDR_CMN(pkt);	//what's this?
+ 	hdr_UWALOHA* UWALOHAh = hdr_UWALOHA::access(pkt);
+ 
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	
+ 	double txtime=cmh->txtime();
+ 	Scheduler& s=Scheduler::instance();
+ 
+ 	switch( n->TransmissionStatus() ) {
+ 		case SLEEP:
+ 			Poweron();
+ 			
+ 		case IDL:
+ 		  
+ 			n->SetTransmissionStatus(SEND); 
+ 			cmh->timestamp() = NOW;//why?
+ 			cmh->direction() = hdr_cmn::DOWN;
+ 			
+ 			//ACK doesn't affect the status, only process DATA here
+ 			if (UWALOHAh->packet_type == hdr_UWALOHA::DATA) {
+ 				//must be a DATA packet, so setup wait ack timer 
+ 				if ((UWALOHAh->DA != (nsaddr_t)MAC_BROADCAST) && ACKOn) {
+ 					UWALOHA_Status = WAIT_ACK;
+ 					WaitACKTimer.resched(WaitACKTime+txtime);
+ 				}
+ 				else {
+ 					Packet::free(PktQ_.front());
+ 					PktQ_.pop();
+ 					UWALOHA_Status = PASSIVE;
+ 				}
+ 				status_handler.is_ack() = false;
+ 			}
+ 			else{
+ 				status_handler.is_ack() = true;
+ 			}
+ 			sendDown(pkt);		//UnderwaterMAC.cc
+ 			
+ 			blocked = true;
+ 			s.schedule(&status_handler,&status_event,txtime+0.01);
+ 			break;
+ 			
+ 		case RECV:
+ 			printf("RECV-SEND Collision!!!!!\n");
+ 			if( UWALOHAh->packet_type == hdr_UWALOHA::ACK ) 
+ 				retryACK(pkt);
+ 			else
+ 				Packet::free(pkt);
+ 			
+ 			UWALOHA_Status = PASSIVE;
+ 			break;
+ 			
+ 		default:
+ 		//status is SEND
+ 			printf("node%d send data too fast\n",index_);
+ 			if( UWALOHAh->packet_type == hdr_UWALOHA::ACK ) 
+ 				retryACK(pkt);
+ 			else
+ 				Packet::free(pkt);
+ 			UWALOHA_Status = PASSIVE;
+ 	}
+ }
+ 
+ void UWALOHA::RecvProcess(Packet *pkt)
+ {
+ 	hdr_UWALOHA* UWALOHAh = hdr_UWALOHA::access(pkt);
+ 	hdr_cmn* cmh=HDR_CMN(pkt);
+ 	nsaddr_t recver = UWALOHAh->DA;
+ 
+ 	if( cmh->error() ) 
+ 	{
+ 	  if(drop_	&&	recver==index_) {
+ 		  drop_->recv(pkt,"Error/Collision");
+ 	  }
+ 	  else
+ 		  Packet::free(pkt);	
+ 	  
+ 	  //processPassive();
+ 	  return;
+ 	}
+ 
+ 	if( UWALOHAh->packet_type == hdr_UWALOHA::ACK ) {
+ 			//if get ACK after WaitACKTimer, ignore ACK
+ 			if( recver == index_ && UWALOHA_Status == WAIT_ACK) {
+ 				WaitACKTimer.cancel();
+ 				bo_counter=0;
+ 				Packet::free(PktQ_.front());
+ 				PktQ_.pop();
+ 				UWALOHA_Status=PASSIVE;
+ 				processPassive();
+ 			}
+ 	}
+ 	else if(UWALOHAh->packet_type == hdr_UWALOHA::DATA) {
+ 			//process Data packet
+ 			if( recver == index_ || recver == (nsaddr_t)MAC_BROADCAST ) {
+ 				cmh->size() -= hdr_UWALOHA::size();
+ 				sendUp(pkt->copy());	//UnderwaterMAC.cc
+ 				if ( ACKOn && (recver != (nsaddr_t)MAC_BROADCAST))
+ 					replyACK(pkt->copy());
+ 				else 
+ 					processPassive();
+ 			}
+ 
+ 	}
+ 	Packet::free(pkt);	
+ }
+ 
+ void UWALOHA::replyACK(Packet *pkt)//sendACK
+ {
+ 	nsaddr_t Data_Sender = hdr_UWALOHA::access(pkt)->SA;
+ 	
+ 	sendPkt(makeACK(Data_Sender));
+ 	bo_counter=0;
+ 	Packet::free(pkt);
+ }
+ 
+ Packet* UWALOHA::makeACK(nsaddr_t Data_Sender)
+ {
+ 	Packet* pkt = Packet::alloc();
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_UWALOHA* UWALOHAh = hdr_UWALOHA::access(pkt);
+ 
+ 	cmh->size() = hdr_UWALOHA::size();
+ 	cmh->txtime() = getTxTime(cmh->size());
+ 	cmh->error() = 0;
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	cmh->next_hop() = Data_Sender;
+ 	cmh->ptype() = PT_UWALOHA;
+ 
+ 	UWALOHAh->packet_type = hdr_UWALOHA::ACK;
+ 	UWALOHAh->SA = index_;
+ 	UWALOHAh->DA = Data_Sender;
+ 
+ 	return pkt;
+ }
+ 
+ 
+ void UWALOHA::processRetryTimer(UWALOHA_ACK_RetryTimer* timer)
+ {
+ 	Packet* pkt = timer->pkt();
+ 	if( RetryTimerMap_.count(timer->id()) != 0 ) {
+ 		RetryTimerMap_.erase(timer->id());
+ 	} else {
+ 		printf("error: cannot find the ack_retry timer\n");
+ 	}
+ 	delete timer;
+ 	sendPkt(pkt);
+ }
+ 
+ 
+ void UWALOHA::retryACK(Packet* ack)
+ {
+ 	UWALOHA_ACK_RetryTimer* timer = new UWALOHA_ACK_RetryTimer(this, ack);
+ 	timer->resched(MAXACKRetryInterval*Random::uniform());
+ 	RetryTimerMap_[timer->id()] = timer;
+ }
+ 
+ 
+ 
+ 
+ int UWALOHA::command(int argc, const char *const *argv)
+ {
+ 	return UnderwaterMac::command(argc, argv);
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/uwaloha/uwaloha.h ns-2.35-aquasim/underwatersensor/uw_mac/uwaloha/uwaloha.h
*** ns-2.35/underwatersensor/uw_mac/uwaloha/uwaloha.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwaloha/uwaloha.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,223 ----
+ #ifndef __UWALOHA_H__
+ #define __UWALOHA_H__
+ 
+ #include <packet.h>
+ #include <random.h>
+ #include <math.h>
+ 
+ #include <timer-handler.h>
+ 
+ #include <mac.h>
+ #include "../underwatermac.h"
+ #include "../underwaterchannel.h"
+ #include "../underwaterpropagation.h"
+ 
+ 
+ #include <queue>
+ #include <map>
+ 
+ using namespace std;
+ 
+ typedef double Time;
+ #define CALLBACK_DELAY 0.001	//the interval between two consecutive sendings
+ #define MAXIMUMCOUNTER 4
+ #define Broadcast -1
+ class UWALOHA;
+ 
+ struct hdr_UWALOHA{
+ 	nsaddr_t SA;
+ 	nsaddr_t DA;
+ 
+ 	enum PacketType {
+ 		DATA,
+ 		ACK		
+ 	} packet_type;
+ 	static int offset_;
+ 	inline static int& offset() {  return offset_; }
+ 	
+ 	inline static int size() {
+ 		return sizeof(nsaddr_t)*2 + 1 /*for packet_type*/;
+ 	}
+ 
+ 	inline static hdr_UWALOHA* access(const Packet*  p) {
+ 		return (hdr_UWALOHA*) p->access(offset_);
+ 	}
+ 
+ };
+ 
+ class UWALOHA_DataSendTimer: public TimerHandler{
+ public:
+ 	UWALOHA_DataSendTimer(UWALOHA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	//void resched(double delay);
+ 	Packet* pkt_;
+ 
+ protected:
+ 	UWALOHA* mac_;
+ 	virtual void expire(Event *e);
+ };
+ 
+ class UWALOHA_WaitACKTimer: public TimerHandler{
+ public:
+ 	UWALOHA_WaitACKTimer(UWALOHA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 		ack_times_ = 30;
+ 	}
+ 	//void resched(double delay);
+ 
+ protected:
+ 	UWALOHA* mac_;
+ 	int	 ack_times_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class UWALOHA_BackoffTimer: public TimerHandler{
+ public:
+ 	UWALOHA_BackoffTimer(UWALOHA* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	//void resched(double delay);
+ 
+ protected:
+ 	UWALOHA* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class UWALOHA_ACK_RetryTimer: public TimerHandler{
+ public:
+ 	UWALOHA_ACK_RetryTimer(UWALOHA* mac, Packet* pkt=NULL) {
+ 		mac_ = mac;
+ 		pkt_ = pkt;
+ 		id_ = id_generator++;
+ 	}
+ 	
+ 	Packet*& pkt() {
+ 		return pkt_;
+ 	}
+ 	
+ 	long id() {
+ 		return id_;
+ 	}
+ 	
+ protected:
+ 	UWALOHA* mac_;
+ 	Packet* pkt_;
+ 	long	id_;
+ 	static long id_generator;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class UWALOHA_StatusHandler: public Handler{
+ public:
+ 	UWALOHA_StatusHandler(UWALOHA* mac): Handler() {
+ 		mac_ = mac;
+ 	}
+ 	bool&	is_ack() {
+ 		return is_ack_;
+ 	}
+ protected:
+ 	UWALOHA* mac_;
+ 	bool	is_ack_;
+ 	virtual void handle(Event* e);
+ };
+ 
+ 
+ class UWALOHA_CallBackHandler: public Handler{
+ public:
+ 	UWALOHA_CallBackHandler(UWALOHA* mac): Handler() {
+ 		mac_ = mac;
+ 	}
+ protected:
+ 	UWALOHA* mac_;
+ 	virtual void handle(Event* e);
+ };
+ 
+ 
+ class UWALOHA: public UnderwaterMac{
+ public:
+ 	UWALOHA();
+ 	int  command(int argc, const char*const* argv);
+ 	void TxProcess(Packet* pkt);
+ 	void RecvProcess(Packet* pkt);
+ 	int bo_counter;
+ 	
+ 	void	processRetryTimer(UWALOHA_ACK_RetryTimer* timer);
+ protected:
+ 
+ 	enum {
+ 		PASSIVE,
+ 		BACKOFF,
+ 		SEND_DATA,
+ 		WAIT_ACK,
+ 	}UWALOHA_Status;
+ 
+ 	double	Persistent;
+ 	int		ACKOn;
+ 	Time	Min_Backoff;
+ 	Time 	Max_Backoff;
+ 	Time	WaitACKTime;
+ 	Time	MAXACKRetryInterval;
+ 	
+ 	bool	blocked;
+ 
+ 	int	seq_n;
+ 	
+ 	UWALOHA_BackoffTimer		BackoffTimer;
+ 	UWALOHA_WaitACKTimer		WaitACKTimer;
+ 
+ 	UWALOHA_CallBackHandler		CallBack_handler;
+ 	UWALOHA_StatusHandler		status_handler;
+ 
+ 	Time MaxPropDelay;
+ 	Time DataTxTime;
+ 	Time ACKTxTime;
+ 
+ 
+ 	queue<Packet*>	PktQ_;
+ 	map<long, UWALOHA_ACK_RetryTimer*> RetryTimerMap_;   //map timer id to the corresponding pointer
+ 
+ 	Event	status_event;
+ 	Event 	Forward_event;
+ 	Event	callback_event;
+ 
+ 	Packet* makeACK(nsaddr_t RTS_Sender);
+ 
+ 	void	replyACK(Packet* pkt);
+ 
+ 	void	sendACK(Time DeltaTime);
+ 
+ 	void	sendPkt(Packet* pkt);//why?
+ 	void	sendDataPkt();
+ //	void 	DropPacket(Packet*);
+ 	void	doBackoff();
+ //	void	processDataSendTimer(Event *e);
+ 	void	processWaitACKTimer(Event *e);
+ 	void	processPassive();
+ //	void	processBackoffTimer();
+ 
+ 	
+ 	void	retryACK(Packet* ack);
+ 
+ 	void	StatusProcess(bool is_ack);
+ 	void	BackoffProcess();
+ 	void	CallbackProcess(Event* e);
+ 
+ 	bool	CarrierDected();
+ //	void	doBackoff(Event *e);
+ 
+ 
+ 	friend class UWALOHA_BackoffTimer;
+ 	friend class UWALOHA_WaitACKTimer;
+ 	friend class UWALOHA_CallBackHandler;
+ 	friend class UWALOHA_StatusHandler;
+ 	friend class UWALOHA_ForwardHandler;
+ 
+ };
+ 
+ #endif
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac.cc ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac.cc
*** ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac.cc	2016-09-03 00:42:03.528000000 +0800
***************
*** 0 ****
--- 1,514 ----
+ #include "uwan-mac.h"
+ #include "underwatersensor/uw_routing/vectorbasedforward.h"
+ 
+ 
+ 
+ void UWAN_MAC_CallbackHandler::handle(Event* e)
+ {
+ 	mac_->CallbackProcess(e);
+ }
+ 
+ 
+ void UWAN_MAC_StatusHandler::handle(Event* e) {
+ 	mac_->StatusProcess(e);
+ }
+ 
+ void UWAN_MAC_WakeTimer::expire(Event *e)
+ {
+ 	mac_->wakeup(ScheT_->node_id_);
+ }
+ 
+ void UWAN_MAC_SleepTimer::expire(Event *e)
+ {
+ 	mac_->sleep();
+ }
+ 
+ 
+ void UWAN_MAC_PktSendTimer::expire(Event *e) {
+ 	mac_->TxPktProcess(e, this);
+ }
+ 
+ void UWAN_MAC_StartTimer::expire(Event* e) {
+ 	mac_->start();
+ }
+ 
+ //bind the tcl object
+ static class UWANMacClass : public TclClass {
+ public:
+ 	UWANMacClass():TclClass("Mac/UnderwaterMac/UWANMac") {}
+ 	TclObject* create(int, const char*const*) {
+ 		return (new UWAN_MAC());
+ 	}
+ }class_uwan_mac;
+ 
+ 
+ Time UWAN_MAC::InitialCyclePeriod_ = 10.0;
+ Time UWAN_MAC::MaxPropTime_ = UnderwaterChannel::Transmit_distance()/1500.0;
+ Time UWAN_MAC::MaxTxTime_ = 0.0;
+ Time UWAN_MAC::ListenPeriod_ = 0.0;		//the length of listening to the channel after transmission.
+ Time UWAN_MAC::hello_tx_len = 0.0;
+ Time UWAN_MAC::WakePeriod_ = 0.0;
+ 
+ 
+ UWAN_MAC::UWAN_MAC(): UnderwaterMac(), callback_handler(this),
+ 		/*pkt_send_timer(this),*/ status_handler(this),
+ 		sleep_timer(this), start_timer_(this),
+ 		WakeSchQueue_(this)
+ {
+ 	CycleCounter_ = 1;
+ 	NumPktSend_ = 0;
+ 	bind("AvgCyclePeriod", &AvgCyclePeriod_);
+ 	bind("StdCyclePeriod", &StdCyclePeriod_);
+ 	start_timer_.resched(0.001);	
+ 	next_hop_num = 0;
+ } 
+ 
+ 
+ void UWAN_MAC::send_info() {
+ 	FILE* result_f = fopen("send.data", "a");
+ 	fprintf(result_f, "MAC(%d) : num_send = %d\n", index_, NumPktSend_); 
+ 	printf("MAC(%d) : num_send = %d\n", index_, NumPktSend_);
+ 	fclose(result_f);
+ }
+ 
+ 
+ void UWAN_MAC::sendFrame(Packet* p, bool IsMacPkt, Time delay)
+ {
+ 	hdr_cmn* cmh = HDR_CMN(p);
+ 	cmh->direction() = hdr_cmn::DOWN; 
+ 	cmh->txtime() = cmh->size()*encoding_efficiency_/bit_rate_;
+ 
+ 	UWAN_MAC_PktSendTimer *tmp = new UWAN_MAC_PktSendTimer(this);
+ 	tmp->tx_time() = HDR_CMN(p)->txtime();
+ 	tmp->p_ = p;
+ 	tmp->resched(delay);
+ 	PktSendTimerSet_.insert(tmp);
+ 
+ 	//pkt_send_timer.tx_time() = HDR_CMN(p)->txtime();
+ 	//pkt_send_timer.p_ = p;
+ 	//pkt_send_timer.resched(delay);  //set transmission status when this timer expires
+ 
+ 	//Scheduler::instance().schedule(downtarget_, p, delay+0.0001);
+ 	/*if( !IsMacPkt ) {
+ 		Scheduler::instance().schedule(&callback_handler, 
+ 						&callback_event, delay_time+UWAN_MAC_CALLBACK_DELAY);
+ 	}*/
+ 	//callback_handler ????????? 
+ }
+ 
+ 
+ void UWAN_MAC::TxPktProcess(Event *e, UWAN_MAC_PktSendTimer* pkt_send_timer)
+ {
+ 	Packet* p = pkt_send_timer->p_;
+ 	pkt_send_timer->p_ = NULL;
+ 	if( ((UnderwaterSensorNode*) node_)->TransmissionStatus() == SEND
+ 			|| ((UnderwaterSensorNode*) node_)->TransmissionStatus() == RECV ) {
+ 		//if the status is not IDLE (SEND or RECV), the scheduled event cannot be 
+ 		//execute on time. Thus, drop the packet.
+ 		if(drop_) 
+ 			drop_->recv(p,"Schedule Failure");
+ 		else 
+ 			Packet::free(p);
+ 		PktSendTimerSet_.erase(pkt_send_timer);
+ 		return;
+ 	}
+ 
+ 	
+ 	((UnderwaterSensorNode*) node_)->SetTransmissionStatus(SEND);
+ 	sendDown(p);
+ 	Scheduler::instance().schedule(&status_handler, 
+ 				&status_event, pkt_send_timer->tx_time() );
+ 
+ 	PktSendTimerSet_.erase(pkt_send_timer);
+ }
+ 
+ 
+ void UWAN_MAC::CallbackProcess(Event* e)
+ {
+ 	callback_->handle(e);
+ }
+ 
+ 
+ void UWAN_MAC::StatusProcess(Event *e)
+ {
+ 	UnderwaterSensorNode* n=(UnderwaterSensorNode*) node_;
+ 	if( SEND == n->TransmissionStatus() ){
+ 		n->SetTransmissionStatus(IDL);
+ 	}
+   	return;
+ }
+ 
+ 
+ Packet* UWAN_MAC::makeSYNCPkt(Time CyclePeriod, nsaddr_t Recver)
+ {
+ 	Packet* p = Packet::alloc();
+ 	hdr_SYNC *hdr_s = hdr_SYNC::access(p);
+ 	hdr_s->cycle_period() = CyclePeriod;
+ 
+ 	hdr_cmn* cmh = HDR_CMN(p);
+     
+ 	cmh->size() = hdr_SYNC::size();
+ 
+     cmh->next_hop() = Recver;  //the sent packet??
+     cmh->direction()=hdr_cmn::DOWN; 
+     cmh->addr_type()=NS_AF_ILINK;
+     cmh->ptype()=PT_UWAN_SYNC;
+ 
+ 	hdr_mac* mh=hdr_mac::access(p);
+ 	mh->macDA() = Recver;
+ 	mh->macSA() = index_;
+ 
+ 	return p;
+ }
+ 
+ 
+ Packet* UWAN_MAC::fillMissingList(Packet* p)
+ {
+ 	hdr_cmn* cmh = HDR_CMN(p);
+ 	set<nsaddr_t> ML_;
+ 	set_difference(neighbors_.begin(), neighbors_.end(), 
+ 		CL_.begin(), CL_.end(), 
+ 		insert_iterator<set<nsaddr_t> >(ML_, ML_.begin()));
+ 
+ 	p->allocdata( sizeof(uint) + ML_.size()*sizeof(nsaddr_t) );
+ 	cmh->size() += 8*( sizeof(uint) + ML_.size()*sizeof(nsaddr_t) );
+ 
+     unsigned char* walk = (unsigned char*)p->accessdata();
+     *(uint*)walk = ML_.size();
+     walk += sizeof(uint);
+ 
+     for( set<nsaddr_t>::iterator pos=ML_.begin();
+          pos != ML_.end(); pos++)
+     {
+         *(nsaddr_t*)walk = *pos;
+         walk += sizeof(nsaddr_t);
+     }
+ 
+     return p;
+ }
+ 
+ 
+ 
+ Packet* UWAN_MAC::fillSYNCHdr(Packet *p, Time CyclePeriod)
+ {
+ 	hdr_cmn* cmh = HDR_CMN(p);
+ 	hdr_SYNC *hdr_s = hdr_SYNC::access(p);
+ 	hdr_s->cycle_period() = CyclePeriod;
+ 
+ 	cmh->size() += hdr_s->size();
+ 
+ 	return p;
+ }
+ 
+ 
+ void UWAN_MAC::wakeup(nsaddr_t node_id)
+ {
+ 	Time now = Scheduler::instance().clock();
+ 	
+ 	if( ((UnderwaterSensorNode*)node_)->TransmissionStatus() == SLEEP )
+ 		Poweron();
+ 
+ 	WakeSchQueue_.clearExpired(now);
+ 
+ 	if( node_id == index_ ) {
+ 		//generate the time when this node will send out next packet
+ 		CycleCounter_ = (++CycleCounter_) % 10;
+ 		
+ 		switch( CycleCounter_ ) {
+ 			case 0:
+ 				//This node would keep awake for InitialCyclePeriod_.
+ 				//And this is set in start().
+ 				SYNCSchedule();  //node keeps awake in this period
+ 				return;
+ /*
+ 			case 9:
+ 				NextCyclePeriod_ = InitialCyclePeriod_ + now;
+ 				break;
+ */
+ 			default:
+ 				//not this node's SYNC period, just send out the data packet
+ 				NextCyclePeriod_ = genNxCyclePeriod();		
+ 				break;
+ 		}
+ 
+ 		if( ! WakeSchQueue_.checkGuardTime(NextCyclePeriod_, 2*MaxPropTime_, MaxTxTime_) ) {
+ 			NextCyclePeriod_ = 
+ 				WakeSchQueue_.getAvailableSendTime(now+WakePeriod_, 
+ 										NextCyclePeriod_, 2*MaxPropTime_, MaxTxTime_);
+ 		}
+ 		
+ 		WakeSchQueue_.push(NextCyclePeriod_, index_, NextCyclePeriod_-now);
+ 		//WakeSchQueue_.print(2*MaxPropTime_, MaxTxTime_, true, index_);
+ 		if( PacketQueue_.empty() )
+ 			sendFrame(makeSYNCPkt(NextCyclePeriod_-now),true);
+ 		else
+ 			sendoutPkt(NextCyclePeriod_);
+ 	}
+ 	else {
+ 		CL_.erase(node_id);
+ 	}
+ 
+ 	//set the sleep timer
+ 	if( sleep_timer.IsPending() )
+ 		sleep_timer.cancel();
+ 
+ 	setSleepTimer(WakePeriod_);
+ 
+ }
+ 
+ 
+ void UWAN_MAC::sleep()
+ {
+ 	//if( setWakeupTimer() ) {   //This node set the timer to wake up itself
+ 	//	Poweroff();
+ 	//	((UnderwaterSensorNode*)Node_)->SetTransmissionStatus(SLEEP);
+ 	//}
+ 	Poweroff();
+ }
+ 
+ 
+ 
+ void UWAN_MAC::setSleepTimer(Time Interval)
+ {
+ 	sleep_timer.resched(Interval);
+ }
+ 
+ 
+ 
+ Time UWAN_MAC::genNxCyclePeriod()
+ {
+ 	//return NextCyclePeriod_ + Random::normal(AvgCyclePeriod_, StdCyclePeriod_);
+ 	return NextCyclePeriod_ + Random::uniform(AvgCyclePeriod_-StdCyclePeriod_,
+ 						AvgCyclePeriod_+StdCyclePeriod_);
+ }
+ 
+ 
+ /* 
+  *process the incoming packet
+  */
+ void UWAN_MAC::RecvProcess(Packet *p)
+ {
+ 	Time now = Scheduler::instance().clock();
+ 	hdr_mac* mh=hdr_mac::access(p);
+ 	int dst = mh->macDA();
+ 	int src = mh->macSA();
+ 	hdr_cmn* cmh=HDR_CMN(p);
+ 
+ 
+     if( cmh->error() ) 
+     {
+      	//printf("broadcast:node %d  gets a corrupted packet at  %f\n",index_,NOW);
+      	if(drop_)
+ 			drop_->recv(p,"Error/Collision");
+      	else
+ 			Packet::free(p);
+ 
+      	return;
+     }
+ 
+ 	neighbors_.insert(src);		//update the neighbor list
+ 	CL_.insert(src);			//update the contact list
+ 	
+ 	hdr_SYNC* SYNC_h = hdr_SYNC::access(p);
+ 	SYNC_h->cycle_period() -= PRE_WAKE_TIME;
+ 
+ 	if( cmh->ptype() == PT_UWAN_HELLO || cmh->ptype() == PT_UWAN_SYNC ) {
+ 		//the process to hello packet is same to SYNC packet
+ 		WakeSchQueue_.push(SYNC_h->cycle_period()+now, src, SYNC_h->cycle_period());
+ 		//WakeSchQueue_.print(2*MaxPropTime_, MaxTxTime_, false, index_);
+ 	}
+ 	else {
+ 		/*
+ 		 * it must be data packet. we should extract the SYNC hdr & missing list
+ 		 */
+ 			/*either unicasted or broadcasted*/
+ 			//need overhearing!
+ 			//update the schedule queue
+ 			//then send packet to upper layers
+ 			if( index_ == dst )
+ 				printf("node(%d) recv %s\n", index_, packet_info.name(cmh->ptype()));
+ 
+ 			WakeSchQueue_.push(SYNC_h->cycle_period_+now, src, SYNC_h->cycle_period() );
+ 			//WakeSchQueue_.print(2*MaxPropTime_, MaxTxTime_, false, index_);
+ 
+ 			//extract Missing list
+ 			processMissingList(p->accessdata(), src);  //hello is sent to src in this function
+ 
+ 			if( dst == index_ || (u_int32_t)dst == MAC_BROADCAST ) {
+ 				sendUp(p);
+ 				return;
+ 			}
+ 
+ 	}
+ 
+ 	//packet sent to other nodes will be freed
+ 	Packet::free(p);
+ }
+ 
+ 
+ /*
+  * process the outgoing packet
+  */
+ void UWAN_MAC::TxProcess(Packet *p)
+ {
+ 	/* because any packet which has nothing to do with this node is filtered by
+ 	 * RecvProcess(), p must be qualified packet.
+ 	 * Simply cache the packet to simulate the pre-knowledge of next transmission time
+ 	 */
+ 	
+ 
+ 	HDR_CMN(p)->size() = 1600;
+ 	PacketQueue_.push(p);
+ 	Scheduler::instance().schedule(&callback_handler, 
+ 						&callback_event, UWAN_MAC_CALLBACK_DELAY);
+ }
+ 
+ 
+ void UWAN_MAC::SYNCSchedule(bool initial)
+ {
+ 	//time is not well scheduled!!!!!
+ 	Time now = Scheduler::instance().clock();
+ 	NextCyclePeriod_ = InitialCyclePeriod_ + now;
+ 	if( initial ) {
+ 		Time RandomDelay = Random::uniform(0, InitialCyclePeriod_);
+ 		WakeSchQueue_.push(NextCyclePeriod_+RandomDelay, index_, NextCyclePeriod_+RandomDelay-now);
+ 		//WakeSchQueue_.print(2*MaxPropTime_, MaxTxTime_, true, index_);
+ 		sendFrame(makeSYNCPkt(NextCyclePeriod_-now), true, RandomDelay);
+ 		return; 
+ 	}
+ 
+ 	//NextCyclePeriod_ = genNxCyclePeriod();
+ 	//check whether next cycle period is available.
+ 	if( ! WakeSchQueue_.checkGuardTime(NextCyclePeriod_, 2*MaxPropTime_, MaxTxTime_) ) {
+ 		//if it overlaps with others, re-generate a cycle period
+ 		NextCyclePeriod_ = WakeSchQueue_.getAvailableSendTime(now+WakePeriod_, 
+ 						NextCyclePeriod_, 2*MaxPropTime_, MaxTxTime_);
+ 	}
+ 	
+ 	WakeSchQueue_.push(NextCyclePeriod_, index_, NextCyclePeriod_-now);
+ 	//WakeSchQueue_.print(2*MaxPropTime_, MaxTxTime_, true, index_);
+ 	sendFrame(makeSYNCPkt(NextCyclePeriod_-now),true);
+ }
+ 
+ 
+ void UWAN_MAC::start()
+ {
+ 	//init WakeSchQueue. Before sleep, Wake Schedule Queue will pop this value.
+ 	//WakeSchQueue_.push(0.0, index_, -1); //the timer will not start
+ 	((UnderwaterSensorNode*)node_)->SetTransmissionStatus(IDL);
+ 
+ 	Random::seed_heuristically();
+ 
+ 	SYNCSchedule(true);
+ 	MaxTxTime_ = 1610*encoding_efficiency_/bit_rate_;
+ 	hello_tx_len = (hdr_SYNC::size())*8*encoding_efficiency_/bit_rate_;
+ 	ListenPeriod_ = 10*hello_tx_len + 2*MaxPropTime_ + MaxTxTime_;
+ 	WakePeriod_ = ListenPeriod_ + MaxTxTime_;
+ }
+ 
+ 
+ /*
+  * send out one packet from upper layer
+  */ 
+ void UWAN_MAC::sendoutPkt(Time NextCyclePeriod)
+ {
+ 	if( PacketQueue_.empty() ) {
+ 			return; /*because there is no packet, this node cannot sendout packet.
+ 					 * This is due to the stupid idea proposed by the authors of this protocol.
+ 					 * They think mac protocol cannot when it will sendout the next packet.
+ 					 * However, even a newbie knows it is impossible.
+ 					 */
+ 	}
+ 
+ 	Time now = Scheduler::instance().clock();
+ 	//get a packet cached in the queue
+ 	Packet* pkt = PacketQueue_.front();
+ 	PacketQueue_.pop();
+ 	NumPktSend_++;
+ 	//send_info();
+ 	
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	hdr_uwvb* vbh = hdr_uwvb::access(pkt);
+ 	/*next_hop() is set in IP layerequal to the */
+ 
+ 	//fill the SYNC & Missing list header
+ 	fillSYNCHdr(pkt, NextCyclePeriod-now);
+ 	//whether backoff?
+ 	fillMissingList(pkt);
+ 
+     cmh->direction()=hdr_cmn::DOWN; 
+     cmh->addr_type()=NS_AF_ILINK;
+ 
+ 	nsaddr_t next_hop = MAC_BROADCAST;
+ 
+ 	if( neighbors_.size() != 0 ) {
+ 		set<nsaddr_t>::iterator pos = neighbors_.begin();
+ 		for(uint i=0; i<next_hop_num; i++, pos++);
+ 		cmh->next_hop() = *pos;
+ 		next_hop_num = (next_hop_num+1)%neighbors_.size();
+ 		vbh->target_id.addr_ = cmh->next_hop();
+ 	}
+ 
+ 	hdr_mac* mh=hdr_mac::access(pkt);
+ 	mh->macDA() = cmh->next_hop();
+ 	mh->macSA() = index_;
+ 
+ 	sendFrame(pkt, false);
+ }
+ 
+ 
+ 
+ void UWAN_MAC::processMissingList(unsigned char* ML, nsaddr_t src)
+ {
+ 	uint node_num_ = *((uint*)ML);
+ 	ML += sizeof(uint);
+ 	nsaddr_t tmp_addr;
+ 
+ 	for(uint i=0; i<node_num_; i++ ) {
+ 		tmp_addr = *((nsaddr_t*)ML);
+ 		if( index_ == tmp_addr ) {
+ 			//make and send out the hello packet
+ 			Packet* p = Packet::alloc();
+ 			hdr_SYNC *hdr_s = hdr_SYNC::access(p);
+ 			hdr_s->cycle_period() = NextCyclePeriod_ 
+ 										- Scheduler::instance().clock();
+ 
+ 			hdr_cmn* cmh = HDR_CMN(p);
+ 
+ 			cmh->next_hop() = src;
+ 			cmh->direction()=hdr_cmn::DOWN; 
+ 			cmh->addr_type()=NS_AF_ILINK;
+ 			cmh->ptype_ = PT_UWAN_HELLO;
+ 			cmh->size() = hdr_SYNC::size();
+ 			
+ 			hdr_mac* mh=hdr_mac::access(p);
+ 			mh->macDA() = src;
+ 			mh->macSA() = index_;		
+ 
+ 			//rand the sending slot and then send out
+ 			sendFrame(p, true, Random::integer(10)*hello_tx_len);   //hello should be delayed!!!!!!
+ 			return;
+ 		}
+ 		ML += sizeof(nsaddr_t);
+ 	}
+ 
+ }
+ 
+ 
+ 
+ int UWAN_MAC::command(int argc, const char *const *argv)
+ {
+ 	if(argc == 3) {
+         if (strcmp(argv[1], "node_on") == 0) {
+ 			Node* n1=(Node*) TclObject::lookup(argv[2]);
+ 			if (!n1) return TCL_ERROR;
+ 			node_ =n1; 
+ 			return TCL_OK;
+ 		}
+ 	}
+ 
+ 	return UnderwaterMac::command(argc, argv);
+ }
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac.h ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac.h
*** ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,188 ----
+ #ifndef __UWAN_MAC_H__
+ #define __UWAN_MAC_H__
+ 
+ 
+ #include "uwan-mac-pkt.h"
+ #include <timer-handler.h>
+ #include <random.h>
+ #include <mac.h>
+ #include "../underwatermac.h"
+ #include "../underwaterchannel.h"
+ #include "../underwaterpropagation.h"
+ #include <set>
+ #include <queue>
+ #include <algorithm>
+ using namespace std;
+ 
+ #define UWAN_MAC_CALLBACK_DELAY 0.001
+ #define INFINITE_PERIOD   10000000.0
+ #define PRE_WAKE_TIME     0.1
+ 
+ class UWAN_MAC;
+ 
+ class UWAN_MAC_CallbackHandler: public Handler{
+ public:
+ 	UWAN_MAC_CallbackHandler(UWAN_MAC* mac) {
+ 		mac_ = mac;
+ 	}
+ 	void handle(Event*);
+ private:
+ 	UWAN_MAC* mac_;
+ };
+ 
+ 
+ class UWAN_MAC_StatusHandler: public Handler{
+  public:
+ 	 UWAN_MAC_StatusHandler(UWAN_MAC* mac){
+ 		 mac_ = mac;
+ 	 }
+ 	void handle(Event*);
+  private:
+   	UWAN_MAC* mac_;
+ };
+ 
+ 
+ class UWAN_MAC_SleepTimer: public TimerHandler {
+ public:
+ 	UWAN_MAC_SleepTimer(UWAN_MAC* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	bool IsPending() {
+ 		if( status() == TIMER_PENDING )
+ 			return true;
+ 		else
+ 			return false;
+ 	}
+ protected:
+ 	UWAN_MAC* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class UWAN_MAC_PktSendTimer: public TimerHandler {
+ public:
+ 	UWAN_MAC_PktSendTimer(UWAN_MAC* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 	
+ 	Time& tx_time() {
+ 		return tx_time_;
+ 	}
+ 
+ 	//Packet*& pkt() {
+ 	//	return p_;
+ 	//}
+ public:
+ 	Packet* p_;
+ protected:
+ 	UWAN_MAC* mac_;
+ 	Time	tx_time_;
+ 	//Packet* p_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class UWAN_MAC_StartTimer: public TimerHandler {
+ public:
+ 	UWAN_MAC_StartTimer(UWAN_MAC* mac): TimerHandler() {
+ 		mac_ = mac;
+ 	}
+ 
+ protected:
+ 	UWAN_MAC* mac_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ 
+ class UWAN_MAC: public UnderwaterMac{
+ 	friend class UWAN_MAC_CallbackHandler;
+ 	friend class UWAN_MAC_WakeTimer;
+ 	friend class UWAN_MAC_SleepTimer;
+ 	friend class UWAN_MAC_StatusHandler;
+ 	friend class UWAN_MAC_PktSendTimer;
+ 	friend class UWAN_MAC_StartTimer;
+ 	friend class UWAN_MAC_TxStatusHandler;
+ 	//friend UWAN_MAC_SendPktTimer;
+ 
+ public:
+ 	UWAN_MAC();
+ 
+ 	virtual  void RecvProcess(Packet*);
+ 	/*
+ 	 * UWAN MAC assumes that node knows when it will send out the next packet.
+ 	 * To simulate such pre-knowledge, we should not send out the outgoing packet in TxProcess(), 
+ 	 * but just queue it and then send out it according to the Schedule via sendoutPkt().
+ 	 */
+ 	virtual  void TxProcess(Packet*);
+ 	virtual  int  command(int argc,const char* const* argv);
+ 
+ protected:
+ 	void	sendFrame(Packet* p, bool IsMacPkt, Time delay = 0.0);
+ 	void	CallbackProcess(Event* e);
+ 	void	StatusProcess(Event* e);
+ 	void	TxPktProcess(Event* e, UWAN_MAC_PktSendTimer* pkt_send_timer);
+ 
+ 
+ 	UWAN_MAC_CallbackHandler callback_handler;
+ 	Event callback_event;
+ //	UWAN_MAC_PktSendTimer	pkt_send_timer;
+ 	Event status_event;
+ 	UWAN_MAC_StatusHandler  status_handler;
+ 	
+ 
+ 	//UWAN_MAC_WakeTimer wake_timer;	//wake this node after NextCyclePeriod;
+ 	UWAN_MAC_SleepTimer		sleep_timer;
+ 	UWAN_MAC_StartTimer		start_timer_;
+ 
+ 	Packet* makeSYNCPkt(Time CyclePeriod, nsaddr_t Recver = MAC_BROADCAST); //perhaps CyclePeriod is not required
+ 	Packet* fillMissingList(Packet* p);
+ 	Packet* fillSYNCHdr(Packet* p, Time CyclePeriod);
+ 
+ 	void	wakeup(nsaddr_t node_id);  //perhaps I should calculate the energy consumption in these two functions
+ 	void	sleep();
+ 	void	sendoutPkt(Time NextCyclePeriod);
+ 	//bool	setWakeupTimer(); //if the node still need to keep wake, return false.
+ 	void	setSleepTimer(Time Interval);     //keep awake for To, and then fall sleep
+ 	void	start();	//initilize NexCyclePeriod_ and the sleep timer, sendout first SYNC pkt
+ 	Time	genNxCyclePeriod();   //I want to use normal distribution
+ 	void	processMissingList(unsigned char* ML, nsaddr_t src);
+ 	void	SYNCSchedule(bool initial = false);
+ 
+ 	void	send_info();
+ 
+ 
+ private:
+ 	set<nsaddr_t> CL_;				//contact list
+ 	set<nsaddr_t> neighbors_;		//neighbor list.
+ 	/*the difference between CL_ and neighbors_ is the Missing list*/
+ 	Time  NextCyclePeriod_;		//next sending cycle
+ 	Time  AvgCyclePeriod_;
+ 	Time  StdCyclePeriod_;
+ 
+ 	/*  The length of initial cycle period, whenever I send current 
+ 	 *  packet, I should first decide when I will send out next one.
+ 	 */
+ 	static Time  InitialCyclePeriod_;	
+ 	static Time  ListenPeriod_;		//the length of listening to the channel after transmission.
+ 	static Time  MaxTxTime_;
+ 	static Time  MaxPropTime_;		//GuardTime_;		//2* static Time  MaxPropTime_;
+ 	static Time  hello_tx_len;
+ 	static Time  WakePeriod_;
+ 
+ 	ScheduleQueue	WakeSchQueue_;
+ 	/* 
+ 	 *packet queue which this node cache the packet from upper layer 
+ 	 */
+ 	queue<Packet*>  PacketQueue_;
+ 	int		CycleCounter_;   //count the number of cycle.
+ 	int		NumPktSend_;
+ 	uint		next_hop_num;
+ 	set<UWAN_MAC_PktSendTimer *> PktSendTimerSet_; 
+ };
+ 
+ 
+ 
+ 
+ #endif
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.cc ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.cc
*** ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,186 ----
+ #include "uwan-mac-pkt.h"
+ #include <stdio.h>
+ 
+ int hdr_SYNC::offset_;
+ int hdr_MissingList::offset_;
+ 
+ static class UWAN_SYNC_HeaderClass: public PacketHeaderClass{
+ public:
+ 	UWAN_SYNC_HeaderClass():
+ 			PacketHeaderClass("PacketHeader/UWAN_SYNC", sizeof(hdr_SYNC)) {
+ 				bind_offset(&hdr_SYNC::offset_);
+ 	}
+ }class_UWAN_SYNC_hdr;
+ 
+ 
+ 
+ static class UWAN_MissingListClass: public PacketHeaderClass {
+ public:
+ 	UWAN_MissingListClass(): 
+ 			PacketHeaderClass("PacketHeader/UWAN_ML", sizeof(hdr_MissingList)) {
+ 				bind_offset(&hdr_MissingList::offset_);
+ 	}
+ }class_UWAN_ML_hdr;
+ 
+ 
+ UWAN_MAC_WakeTimer::UWAN_MAC_WakeTimer(UWAN_MAC* mac, 
+ 									   ScheduleTime* ScheT): TimerHandler() {
+ 		mac_ = mac;
+ 		ScheT_ = ScheT;
+ }
+ 
+ 
+ 
+ void ScheduleQueue::push(Time SendTime, nsaddr_t node_id, Time Interval)
+ {
+ 	ScheduleTime* newElem = new ScheduleTime(SendTime, node_id, mac_);
+ 	newElem->start(Interval);
+ 
+ 	ScheduleTime* pos = Head_->next_;
+ 	ScheduleTime* pre_pos = Head_;
+ 
+ 	//find the position where new element should be insert
+ 	while( pos != NULL ) {
+ 		if( pos->SendTime_ > SendTime ) {
+ 			break;
+ 		}
+ 		else {
+ 			pos = pos->next_;
+ 			pre_pos = pre_pos->next_;
+ 		}
+ 
+ 	}
+ 	/*
+ 	 * insert new element after pre_pos
+ 	 */
+ 	newElem->next_ = pos;
+ 	pre_pos->next_ = newElem;
+ }
+ 
+ 
+ //get the top element, but not pop it
+ ScheduleTime* ScheduleQueue::top()
+ {
+ 	return Head_->next_;
+ }
+ 
+ //pop the top element
+ void ScheduleQueue::pop()
+ {
+ 	if( Head_->next_ != NULL ) {
+ 
+ 		ScheduleTime* tmp = Head_->next_;
+ 		Head_->next_ = Head_->next_->next_;
+ 
+ 		if( tmp->timer_.status() == TimerHandler::TIMER_PENDING ) {
+ 			tmp->timer_.cancel();
+ 		}
+ 
+ 		delete tmp;  
+ 	}
+ }
+ 
+ 
+ bool ScheduleQueue::checkGuardTime(Time SendTime, Time GuardTime, Time MaxTxTime)
+ {
+ 	ScheduleTime* pos = Head_->next_;
+ 	ScheduleTime* pre_pos = Head_;
+ 
+ 	while( pos != NULL && SendTime > pos->SendTime_ ) {
+ 		pos = pos->next_;
+ 		pre_pos = pre_pos->next_;
+ 	}
+ 
+ 	/*now, pos->SendTime > SendTime > pre_pos->SendTime
+ 	 *start to check the sendtime.
+ 	 */
+ 	if( pos == NULL ) {
+ 		if( pre_pos == Head_ )
+ 			return true;
+ 		else {
+ 			if( SendTime - pre_pos->SendTime_ >= GuardTime )
+ 				return true;
+ 			else 
+ 				return false;
+ 		}
+ 	}
+ 	else {
+ 		if( pre_pos == Head_ ) {
+ 			if( (pos->SendTime_ - SendTime) > (GuardTime + MaxTxTime) )
+ 				return true;
+ 			else
+ 				return false;
+ 		}
+ 		else {
+ 			if( ((pos->SendTime_ - SendTime) > (GuardTime + MaxTxTime))
+ 				&& (SendTime - pre_pos->SendTime_ >= GuardTime) )
+ 				return true;
+ 			else
+ 				return false;
+ 		}
+ 	}
+ }
+ 
+ 
+ 
+ Time ScheduleQueue::getAvailableSendTime(Time StartTime, 
+ 							Time OriginalSchedule, Time GuardTime, Time MaxTxTime)
+ {
+ 	ScheduleTime* pos = Head_->next_;
+ 	ScheduleTime* pre_pos = Head_;
+ 
+ 	Time DeltaTime = 0.0;
+ 	while( pos != NULL && StartTime > pos->SendTime_ ) {
+ 		pos = pos->next_;
+ 		pre_pos = pre_pos->next_;
+ 	}
+ 
+ 	while( pos != NULL ) {
+ 		DeltaTime = pos->SendTime_ - pre_pos->SendTime_ - (2*GuardTime + MaxTxTime);
+ 		if( DeltaTime > 0 ) {
+ 			return Random::uniform(pre_pos->SendTime_+GuardTime+MaxTxTime, 
+ 						pre_pos->SendTime_+DeltaTime);
+ 		}
+ 
+ 		pos = pos->next_;
+ 		pre_pos = pre_pos->next_;
+ 	}
+ 
+ 	//there is no available interval, so the time out of range of this queue is returned.
+ 	/*
+ 	 * Before calling this function, OriginalSchedule collides with other times,
+ 	 * so originalSchedule is at most pre_pos->SendTime_ + GuardTime + MaxTxTime.
+ 	 * Otherwise, it cannot collides.
+ 	 */
+ 	return pre_pos->SendTime_ + MaxTxTime + GuardTime ;
+ 
+ }
+ 
+ 
+ void ScheduleQueue::clearExpired(Time CurTime)
+ {
+ 	ScheduleTime* NextSch = NULL;
+ 	while( (NextSch = top()) && NextSch->SendTime_ < CurTime ) {
+ 		pop();
+ 	}  
+ }
+ 
+ 
+ void ScheduleQueue::print(Time GuardTime, Time MaxTxTime, bool IsMe, nsaddr_t index)
+ {
+ 	ScheduleTime* pos = Head_->next_;
+ 	char file_name[30];
+ 	strcpy(file_name, "schedule_");
+ 	file_name[strlen(file_name)+1] = '\0';
+ 	file_name[strlen(file_name)] = char(index+'0');
+ 	FILE* stream = fopen(file_name, "a");
+ 	if( IsMe )
+ 			fprintf(stream, "I send  ");
+ 	while( pos != NULL ) {
+ 		fprintf(stream, "(%f--%f, %f) ", pos->SendTime_, 
+ 			pos->SendTime_+MaxTxTime, pos->SendTime_+GuardTime+MaxTxTime);
+ 		pos = pos->next_;
+ 	}
+ 	fprintf(stream, "\n");
+ 	fclose(stream);
+ }
diff -crBN ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.h ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.h
*** ns-2.35/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwan-mac/uwan-mac-pkt.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,143 ----
+ #ifndef _UWAN_MAC_PKT_H__
+ #define _UWAN_MAc_PKT_H__
+ 
+ #include <packet.h>
+ #include <random.h>
+ #include <timer-handler.h>
+ 
+ typedef double Time;
+ 
+ //PT_UWAN_SYNC
+ //Hello Packet share the stucture of SYNC
+ 
+ struct hdr_SYNC{
+ 	Time cycle_period_;
+ 	Time& cycle_period() {
+ 		return cycle_period_;
+ 	}
+ 
+ 	inline static size_t size() {
+ 		return 8*sizeof(Time);
+ 	}
+ 
+ 	static int offset_;
+ 	inline static int& offset()
+ 	{
+ 		return offset_;
+ 	}
+ 	inline static hdr_SYNC* access(const Packet* p) 
+ 	{
+ 		return (hdr_SYNC*)p->access(offset_);
+ 	}
+ };
+ 
+ //PT_UWAN_ML
+ struct hdr_MissingList{
+ 	uint16_t	node_num_;
+ 	nsaddr_t*	addr_list_;
+ 
+ 	inline size_t size() {
+ 		return 8*(sizeof(uint16_t) + node_num_*sizeof(nsaddr_t));
+ 	}
+ 
+ 	hdr_MissingList(): node_num_(0), addr_list_(NULL) {
+ 	}
+ 
+ 	~hdr_MissingList() {
+ 		delete []addr_list_;
+ 	}
+ 
+ 	static int offset_;
+ 	inline static int& offset() {
+ 		return offset_;
+ 	}
+ 
+ 	inline static hdr_MissingList* access(const Packet* p) {
+ 		return (hdr_MissingList*)p->access(offset_);
+ 	}
+ };
+ //HELLO packet is same as hdr_SYNC
+ 
+ //MISSING LIST is implemented in the data area of packet
+ 
+ 
+ class UWAN_MAC;
+ struct ScheduleTime;
+ 
+ class UWAN_MAC_WakeTimer: public TimerHandler {
+ public:
+ 	UWAN_MAC_WakeTimer(UWAN_MAC* mac, ScheduleTime* ScheT);
+ 
+ protected:
+ 	UWAN_MAC* mac_;
+ 	ScheduleTime* ScheT_;
+ 	virtual void expire(Event* e);
+ };
+ 
+ /*
+  * Data structure for neighbors' schedule
+  */
+ 
+ 
+ struct ScheduleTime {
+ 	ScheduleTime* next_;
+ 	Time		SendTime_;
+ 	nsaddr_t	node_id_;  //with this field, we can determine that which node will send packet.
+ 	UWAN_MAC_WakeTimer	timer_;  //necessary
+ 	//Packet*  pkt_;    //the packet this node should send out
+ 
+ 	ScheduleTime(Time SendTime, nsaddr_t node_id, UWAN_MAC* mac):
+ 			next_(NULL), SendTime_(SendTime), node_id_(node_id), timer_(mac, this) {
+ 	}
+ 
+ 	~ScheduleTime() {
+ 		if( timer_.status() == TimerHandler::TIMER_PENDING )
+ 			timer_.cancel();
+ 	}
+ 
+ 	void start(Time Delay) {
+ 		if( Delay >= 0.0 )
+ 			timer_.resched(Delay);
+ 	}
+ 
+ };
+ 
+ 
+ 
+ /*The SendTime in SYNC should be translated to absolute time 
+  *and then insert into ScheduleQueue
+  */
+ class ScheduleQueue{
+ private:
+ 	ScheduleTime* Head_;
+ 	UWAN_MAC* mac_;
+ public:
+ 	ScheduleQueue(UWAN_MAC* mac): mac_(mac) {
+ 		Head_ = new ScheduleTime(0.0, 0, NULL);
+ 	}
+ 
+ 	~ScheduleQueue() {
+ 		ScheduleTime* tmp;
+ 		while( Head_ != NULL ) {
+ 			tmp = Head_;
+ 			Head_ = Head_->next_;
+ 			delete tmp;
+ 		}
+ 	}
+ 
+ public:
+ 	void push(Time SendTime, nsaddr_t node_id, Time Interval);  //first parameter is the time when sending next packet, the last one is the time interval between current time and sending time
+ 	ScheduleTime* top();		//NULL is returned if the queue is empty
+ 	void pop();
+ 	bool checkGuardTime(Time SendTime, Time GuardTime, Time MaxTxTime); //the efficiency is too low, I prefer to use the function below
+ 	Time getAvailableSendTime(Time StartTime, Time OriginalSchedule, Time GuardTime, Time MaxTxTime);
+ 	void clearExpired(Time CurTime);
+ 	void print(Time GuardTime, Time MaxTxTime, bool IsMe, nsaddr_t index);
+ };
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/uwbuffer.cc ns-2.35-aquasim/underwatersensor/uw_mac/uwbuffer.cc
*** ns-2.35/underwatersensor/uw_mac/uwbuffer.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwbuffer.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,162 ----
+ 
+ #include "packet.h"
+ #include "uwbuffer.h"
+ 
+ 
+ void 
+ TransmissionBuffer::AddNewPacket(Packet* p){
+   buffer_cell* t2;
+   buffer_cell* t1=new buffer_cell;
+ 
+   t1->packet=p;
+   t1->next=NULL;
+ 
+   if(head_==NULL) {
+      tail_=t1;
+      head_=t1;
+   }
+   else{
+   tail_->next=t1;
+   tail_=t1;
+   }
+   
+   num_of_packet++;
+ }
+ 
+ 
+ Packet* 
+ TransmissionBuffer::head(){
+   buffer_cell* t1;
+   buffer_cell* t2;
+   Packet* p;
+   
+   if(!head_) return NULL;
+   else return head_->packet;
+ }
+ 
+ 
+ Packet* 
+ TransmissionBuffer::dehead(){
+   buffer_cell* t1;
+   buffer_cell* t2;
+   Packet* p;
+   
+   if(!head_) return NULL;
+    p=head_->packet;
+    t1=head_->next;
+    t2=head_;
+  
+    head_=t1;
+    num_of_packet--;
+    
+    if(head_==NULL) tail_=NULL; 
+     delete t2;
+    return p;
+ }
+ 
+ 
+ Packet* 
+ TransmissionBuffer::next(){
+   Packet* p;
+   if(!current_p) return NULL;
+   p=current_p->packet;
+   current_p=current_p->next;
+   Packet* p1=p->copy();
+    return p1;
+ }
+ 
+ 
+ int 
+ TransmissionBuffer::DeletePacket(Packet* p){
+   buffer_cell* t1;
+   buffer_cell* t2;
+   
+   // insert this packet at the head of the link
+   t2=head_;
+   
+ 
+   if (!t2) return 0;//0 no such point, 1:delete this point
+ 
+   if (p==t2->packet){
+     printf("underwatermac: the packet is at the head of list\n");
+     head_=t2->next;
+     num_of_packet--;
+ 
+    if(head_==NULL) tail_=NULL;
+    
+     Packet::free(p);  
+      delete t2;
+     
+     return 1;
+ }
+   
+   int modified=0;
+   while(t2->next){
+     if ((t2->next)->packet!=p) t2=t2->next;
+     else{
+     
+      t1=t2->next;
+      t2->next=t1->next;
+ 
+      if(t1==tail_) tail_=t2;
+      num_of_packet--;
+     delete t1;
+     Packet::free(p);   
+     modified=1;
+     }
+   }
+   
+   return modified;
+ }
+ 
+ 
+ buffer_cell*  
+ TransmissionBuffer::lookup(Packet* p){
+   buffer_cell* t2;
+   t2=head_;  
+   while((t2->packet!=p)&&(!t2)) t2=t2->next;
+   return t2;
+ }
+ 
+ 
+ void 
+ TransmissionBuffer::LockBuffer(){
+   current_p=head_;
+   lock_p=tail_;
+   lock=true;
+ }
+ 
+ 
+ void 
+ TransmissionBuffer::UnlockBuffer(){
+   lock=false;
+   lock_p=NULL;
+ }
+ 
+ 
+ bool 
+ TransmissionBuffer::IsEmpty(){
+   return(0==num_of_packet);
+ }
+ 
+ bool 
+ TransmissionBuffer::ToBeFull(){
+   return((MAXIMUM_BUFFER-1)==num_of_packet);
+ }
+ 
+ 
+ 
+ 
+ bool 
+ TransmissionBuffer::IsEnd(){
+   if (lock_p) return (lock_p->next==current_p);
+   return(NULL==current_p);
+ }
+ 
+ 
+ 
+ bool 
+ TransmissionBuffer::IsFull(){
+   return(MAXIMUM_BUFFER==num_of_packet);
+ }
+ 
diff -crBN ns-2.35/underwatersensor/uw_mac/uwbuffer.h ns-2.35-aquasim/underwatersensor/uw_mac/uwbuffer.h
*** ns-2.35/underwatersensor/uw_mac/uwbuffer.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mac/uwbuffer.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,49 ----
+ #ifndef ns_uwbuffer_h
+ #define ns_uwbuffer_h
+ 
+ #include "config.h"
+ #include "packet.h"
+ 
+ #define MAXIMUM_BUFFER 1
+ 
+ 
+ struct buffer_cell{
+   Packet* packet;
+   buffer_cell * next;
+   double delay;
+ };
+ 
+ 
+ class TransmissionBuffer{
+  public: 
+        TransmissionBuffer(){
+                   head_=NULL;
+                   current_p=NULL; 
+                   num_of_packet=0;
+                   lock=false;
+                   tail_=NULL;
+                   lock_p=NULL;
+                           };
+       
+     void AddNewPacket(Packet*);
+     void LockBuffer();
+     void UnlockBuffer();
+     int  DeletePacket(Packet*);
+     Packet* dehead();
+     Packet* next();
+     Packet* head();
+     bool  IsEnd();
+     bool IsEmpty();
+     bool IsFull();
+     bool ToBeFull();
+     bool IsLocked(){return lock;};
+     buffer_cell * lookup(Packet*);
+     int num_of_packet;// number of sending packets
+        buffer_cell* head_;
+        bool lock;
+  private:
+        buffer_cell* current_p;
+        buffer_cell* lock_p;
+        buffer_cell* tail_;
+ };
+ #endif /* __uwbuffer_h__ */
diff -crBN ns-2.35/underwatersensor/uw_mobility_pattern/mobility_pattern_allinone.h ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/mobility_pattern_allinone.h
*** ns-2.35/underwatersensor/uw_mobility_pattern/mobility_pattern_allinone.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/mobility_pattern_allinone.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,10 ----
+ #ifndef __MOBILITY_PATTERN_ALLINONE_H__
+ #define __MOBILITY_PATTERN_ALLINONE_H__
+ 
+ #include "uw_mobility_pattern.h"
+ #include "uw_mobility_kinematic.h"
+ #include "uw_mobility_rwp.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ 
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.cc ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.cc
*** ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,63 ----
+ #include "mobility_pattern_allinone.h"
+ 
+ 
+ UW_Kinematic::UW_Kinematic(UnderwaterSensorNode* n):UWMobilityPattern(n)
+ {
+ 	k1 = Random::normal(PI, 0.1*PI);
+ 	k2 = Random::normal(PI, 0.1*PI);
+ 	k3 = Random::normal(2*PI, 0.2*PI);
+ 	k4 = Random::normal(0, 0.2);
+ 	k5 = Random::normal(0, 0.2);
+ 	lambda = Random::normal(6, 0.3);
+ 	v = Random::normal(1, 0.1);
+ }
+ 
+ 
+ 
+ void UW_Kinematic::update_position()
+ {
+ 
+ 	double now = Scheduler::instance().clock();
+ 	double interval = now - n_->position_update_time_;
+ 	double oldX = n_->X_, oldY = n_->Y_;
+ 	double delta_x = 0.0;
+ 	double delta_y = 0.0;
+ 	double v_x = 0.0;
+ 	double v_y = 0.0;
+ 
+ 
+ 	//update the node position
+ 	n_->X_ = NextX_;
+ 	n_->Y_ = NextY_;
+ 	n_->Z_ = NextZ_;
+ 	bound_position();
+ 	NextX_ = n_->X_;
+ 	NextY_ = n_->Y_;
+ 	NextZ_ = n_->Z_;
+ 	
+ 	if ((interval == 0.0)&&(n_->position_update_time_!=0))
+ 		return;         // ^^^ for list-based imprvmnt 
+ 
+     //start to calculate the position after the coming interval
+ 	v_y = k5-lambda*v*cos(k2*n_->X_)*sin(k3*n_->Y_);
+ 	v_x = k1*lambda*v*sin(k2*n_->X_)*cos(k3*n_->Y_)+k4+k1*lambda*cos(2*k1*now);	
+ 	
+ 	NextX_ += v_x*interval;
+ 	NextY_ += v_y*interval;
+ 	
+ 	if(oldX != n_->X_)
+ 		n_->T_->updateNodesList(n_, oldX); //X_ is the key value of SortList
+ 
+     
+ 	n_->position_update_time_ = now;
+ 	
+ 	
+ 	updateGridKeeper();
+ 	NamTrace("n -t %f -s %d -x %f -y %f -z %f -U %f -V %f -T %f",
+ 			now,
+ 			n_->nodeid_,
+ 			n_->X_, n_->Y_, n_->Z_,
+ 			v_x,
+ 			v_y, interval);
+ }
+ 
diff -crBN ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.h ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.h
*** ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_kinematic.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,30 ----
+ /*
+  * random waypoint model for 3D underwatersensor network. 
+  * Contributed by Yibo Zhu, email: yibo.zhu@engr.uconn.edu
+  * http://uwsn.engr.uconn.edu
+  */
+ 
+ #ifndef __UW_MOBILITY_KINEMATIC_H__
+ #define __UW_MOBILITY_KINEMATIC_H__
+ 
+ #include "uw_mobility_pattern.h"
+ 
+ 
+ class UW_Kinematic: public UWMobilityPattern{
+ public:
+ 	UW_Kinematic(UnderwaterSensorNode* n);
+ 	virtual void update_position();
+ 
+ private:
+ 	double k1;
+ 	double k2;
+ 	double k3;
+ 	double k4;
+ 	double k5;
+ 	double lambda;
+ 	double v;	
+ };
+ 
+ 
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.cc ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.cc
*** ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,91 ----
+ #include "mobility_pattern_allinone.h"
+ 
+ 
+ 
+ mpt_info mpt_names;
+ const char* mpt_info::name_[MPT_NTYPE+1];
+ 
+ 
+ 
+ UWMobilityPattern::UWMobilityPattern(UnderwaterSensorNode* n)
+ { 
+ 	n_ = n;
+ 	NextX_ = n_->X_;
+ 	NextY_ = n_->Y_;
+ 	NextZ_ = n_->Z_;
+ }
+ 
+ 
+ 
+ void UWMobilityPattern::NamTrace(char* fmt, ...)
+ {
+ 	va_list ap;
+ 
+ 	if (n_->namChan_ == 0)
+     	return;
+ 
+ 	va_start(ap, fmt);
+   	vsprintf(n_->nwrk_, fmt, ap);
+   	n_->namdump();
+   	va_end (ap);
+ }
+ 
+ 
+ void UWMobilityPattern::updateGridKeeper()
+ {
+ 	if (GridKeeper::instance()){
+ 		GridKeeper* gp =  GridKeeper::instance();
+ 		gp-> new_moves(n_);
+ 	} 
+ }
+ 
+ 
+ void UWMobilityPattern::bound_position()
+ {
+ 	double minX;
+ 	double maxX;
+ 	double minY;
+ 	double maxY;
+ 	double minZ;
+ 	double maxZ;
+ 	int recheck = 1;
+ 
+ 
+ 	minX = n_->T_->lowerX();
+ 	maxX = n_->T_->upperX();
+ 	minY = n_->T_->lowerY();
+ 	maxY = n_->T_->upperY();
+ 	minZ = n_->T_->lowerZ();
+ 	maxZ = n_->T_->upperZ();
+ 
+ 	while (recheck) {
+ 		recheck = 0;
+ 		if (n_->X_ < minX) {
+ 			n_->X_ = minX + (minX - n_->X_);
+ 			recheck = 1;
+ 		}
+ 		if (n_->X_ > maxX) {
+ 			n_->X_ = maxX - (n_->X_ - maxX);
+ 			recheck = 1;
+ 		}
+ 		if (n_->Y_ < minY) {
+ 			n_->Y_ = minY + (minY - n_->Y_);
+ 			recheck = 1;
+ 		}
+ 		if (n_->Y_ > maxY) {
+ 			n_->Y_ = maxY- (n_->Y_ - maxY);
+ 			recheck = 1;
+ 		}
+ 		if (n_->Z_ < minZ) {
+ 			n_->Z_ = minZ + (minZ - n_->Z_);
+ 			recheck = 1;
+ 		}
+ 		if (n_->Z_ > maxZ) {
+ 			n_->Z_ = maxZ - (n_->Z_ - maxZ);
+ 			recheck = 1;
+ 		}
+ 		if (recheck) {
+ 			fprintf(stderr, "Adjust position of node %d\n",n_->address_);
+ 		}
+ 	}
+ }
diff -crBN ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.h ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.h
*** ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_pattern.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,102 ----
+ /*
+  * the base class for mobility model for 3D underwatersensor network. 
+  * Contributed by Yibo Zhu, email: yibo.zhu@engr.uconn.edu
+  * http://uwsn.engr.uconn.edu
+  */
+ #ifndef __uw_mobility_pattern_h__
+ #define __uw_mobility_pattern_h__
+ 
+ #include <string.h>
+ #include <timer-handler.h>
+ #include <math.h>
+ #include <random.h>
+ 
+ 
+ #define UWMobilePatternFriendshipDeclaration \
+ 	friend class UW_Kinematic;
+ 
+ 
+ //#include "uw_node_and_mobility_pattern.h"
+ //#include "underwatersensornode.h"
+ 
+ 
+ #ifndef PI
+ #define PI 3.1415926
+ #endif
+ #define INTEGRAL_INTERVAL 0.001
+ 
+ 
+ class UnderwaterSensorNode;
+ 
+ //uw mobility pattern type
+ enum MobilityPatternType {
+ 	MPT_KINEMATIC,
+ 	MPT_RWP,
+ 	MPT_NTYPE	
+ };
+ 
+ //name of uw mobility pattern
+ class mpt_info {
+ 
+ private:
+ 	static const char* name_[MPT_NTYPE+1];
+ 
+ public:
+ 	mpt_info(){
+ 		name_[MPT_KINEMATIC]="kinematic";
+ 		name_[MPT_RWP]="RWP";
+ 		
+ 		name_[MPT_NTYPE]="undefined";
+ 	}
+ 	
+ 	const char* name(MobilityPatternType p) const { 
+ 		if ( p <= MPT_NTYPE ) 
+ 			return name_[p];
+ 		else
+ 	 		return NULL;
+ 	}
+ 
+ 	MobilityPatternType getTypeByName(const char* PatternName){
+ 		for( int i=0; i < (MPT_NTYPE); i++) {
+ 			if( strcmp(PatternName, name_[i]) == 0 )
+ 				return (MobilityPatternType)i;
+ 		}
+ 		return MPT_NTYPE;
+ 	}
+ 		
+ };
+ 
+ extern mpt_info mpt_names;
+ 
+ 
+ //call the UWMobilePattern::updateCoordinate() in UnderwaterPositionHandler::handle()
+ 
+ //impelement any mobility Pattern of UW as a child class of UWMobilityPattern
+ class UWMobilityPattern{
+ public:
+ 	UWMobilityPattern(UnderwaterSensorNode* n);	
+ 	virtual void update_position() {  return; }
+ 	virtual void init() { return; };
+ 	void NamTrace(char* format, ...);
+ 
+ protected:	
+ 	void updateGridKeeper();
+ 	void bound_position();
+ 	
+ 
+ protected:
+ 	UnderwaterSensorNode* n_;
+ 	//pre-calculate the position after coming interval so as to record movement into the nam file
+ 	double NextX_;
+ 	double NextY_;
+ 	double NextZ_;
+ 	
+ };
+ 
+ 	
+ 
+ 
+ #endif
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.cc ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.cc
*** ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,95 ----
+ #include "mobility_pattern_allinone.h"
+ 
+ 
+ UW_RWP::UW_RWP(UnderwaterSensorNode* n):UWMobilityPattern(n)
+ {
+ }
+ 
+ void UW_RWP::init()
+ {
+ 	destX_ = n_->X_ = Random::uniform(n_->T_->lowerX(), n_->T_->upperX());
+ 	destY_ = n_->Y_ = Random::uniform(n_->T_->lowerY(), n_->T_->upperY());
+ 	destZ_ = n_->Z_ = Random::uniform(n_->T_->lowerZ(), n_->T_->upperZ());
+ 	prepareNextPoint();
+ 	start_time_ = Scheduler::instance().clock();
+ 	DuplicatedNamTrace = false;
+ }
+ 
+ void UW_RWP::prepareNextPoint()
+ {
+ 	speed_ = (Random::uniform() * (n_->max_speed-n_->min_speed))+n_->min_speed;
+ 
+ 	originalX_ = destX_;
+ 	originalY_ = destY_;
+ 	originalZ_ = destZ_;
+ 	//calculate the next way point
+ 	destX_ = Random::uniform(n_->T_->lowerX(), n_->T_->upperX());
+ 	destY_ = Random::uniform(n_->T_->lowerY(), n_->T_->upperY());
+ 	destZ_ = Random::uniform(n_->T_->lowerZ(), n_->T_->upperZ());
+ 
+ 	distance_ = sqrt( (destX_ - originalX_)*(destX_ - originalX_)
+ 		+(destY_ - originalY_)*(destY_ - originalY_)
+ 		+(destZ_ - originalZ_)*(destZ_ - originalZ_) );
+ 
+ 	ratioX_ = (destX_ - originalX_)/distance_;
+ 	ratioY_ = (destY_ - originalY_)/distance_;
+ 	ratioZ_ = (destZ_ - originalZ_)/distance_;	
+ 
+ 	thought_time_ = Random::uniform(0, n_->max_thought_time_);
+ }
+ 
+ 
+ void UW_RWP::update_position()
+ {
+ 	double now = Scheduler::instance().clock();
+ 	//the time since node start to move from previous way point
+ 	double passed_len = speed_*(now - start_time_);
+ 	double oldX = n_->X_;
+ 
+ 	if( passed_len < distance_ )
+ 	{
+ 		n_->X_ = originalX_ + passed_len * ratioX_;
+ 		n_->Y_ = originalY_ + passed_len * ratioY_;
+ 		n_->Z_ = originalZ_ + passed_len * ratioZ_;
+ 	}
+ 	else{
+ 		//now I must arrive at the way point
+ 		
+ 		if( now - start_time_ - distance_/speed_ < thought_time_ )
+ 		{
+ 			//I am still thinking of that where I will go
+ 			n_->X_ = destX_;
+ 			n_->Y_ = destY_;
+ 			n_->Z_ = destZ_;
+ 		}
+ 		else{
+ 			//I am on the way to next way point again.
+ 			start_time_ = start_time_ + distance_/speed_ + thought_time_;
+ 			prepareNextPoint();		
+ 			DuplicatedNamTrace = true;
+ 			update_position();
+ 			DuplicatedNamTrace = false;			
+ 		}
+ 	}
+ 
+ 	if(oldX != n_->X_)
+ 		n_->T_->updateNodesList(n_, oldX); //X_ is the key value of SortList
+  
+ 	n_->position_update_time_ = now;	
+ 	
+ 	updateGridKeeper();
+ 	/*current nam does not support 3D, so we just write x, y velocity.
+ 	 *After using our animator, z velocity will also be traced.
+ 	 */
+ 	if( !DuplicatedNamTrace )
+ 	{
+ 		NamTrace("n -t %f -s %d -x %f -y %f -z %f -U %f -V %f -T %f",
+ 			now,
+ 			n_->nodeid_,
+ 			n_->X_, n_->Y_, n_->Z_,
+ 			speed_*ratioX_, speed_*ratioY_,
+ 			now - n_->position_update_time_);
+ 
+ 		DuplicatedNamTrace = false;
+ 	}
+ }
diff -crBN ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.h ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.h
*** ns-2.35/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_mobility_pattern/uw_mobility_rwp.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,50 ----
+ /*
+  * random waypoint model for 3D underwatersensor network. 
+  * Contributed by Yibo Zhu, email: yibo.zhu@engr.uconn.edu
+  * http://uwsn.engr.uconn.edu
+  */
+ #ifndef __UW_MOBILITY_RWP_H__
+ #define __UW_MOBILITY_RWP_H__
+ 
+ #include "uw_mobility_pattern.h"
+ 
+ 
+ 
+ class UW_RWP: public UWMobilityPattern{
+ public:
+ 	UW_RWP(UnderwaterSensorNode* n);
+ 	virtual void update_position();
+ 	virtual void init();
+ 
+ private:
+ 	inline void prepareNextPoint();
+ 
+ 
+ private:
+ 	double destX_;  //the coordinate of next way point
+ 	double destY_;
+ 	double destZ_;
+ 	double originalX_;  //the coordinate of previous way point
+ 	double originalY_;
+ 	double originalZ_;
+ 
+ 	/* the ratio between dimensions and the distance between 
+ 	 * previous way point and next way point
+ 	 */
+ 	double ratioX_;    
+ 	double ratioY_;
+ 	double ratioZ_;
+ 	
+ 	double speed_; //for speed of the node
+ 
+ 	double distance_;     //the distance to next point
+ 	double start_time_;   //the time when this node start to next point
+ 	double thought_time_; //the time taken by deceiding where I will go
+ 
+ 	bool   DuplicatedNamTrace;
+ 
+ };
+ 
+ 
+ 
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_routing/static_routing/static_routing.cc ns-2.35-aquasim/underwatersensor/uw_routing/static_routing/static_routing.cc
*** ns-2.35/underwatersensor/uw_routing/static_routing/static_routing.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/static_routing/static_routing.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,171 ----
+ #include "static_routing.h"
+ #include "cmu-trace.h"
+ 
+ static class StaticRoutingClass : public TclClass {
+ public:
+ 	StaticRoutingClass() : TclClass("Agent/StaticRouting") {}
+ 	TclObject* create(int argc, const char*const* argv) {
+ 		return(new StaticRouting());
+ 	}
+ } class_staticrouting;
+ 
+ 
+ StaticRouting::StaticRouting():Agent(PT_UW_SROUTE)
+ {
+ 	node = NULL;
+ 	has_set_routefile = false;
+ 	has_set_node = false;
+ }
+ 
+ 
+ int StaticRouting::command(int argc, const char *const *argv)
+ {
+ 	Tcl& tcl =  Tcl::instance();
+ 
+ 	if ( argc == 2 ) {
+ 		if( strcasecmp(argv[1], "start" ) == 0 ) {
+ 			return TCL_OK;
+ 		}
+ 	} else if (argc == 3) {
+ 		if ( strcasecmp( argv[1], "addr") == 0 ) {
+ 			my_addr = Address::instance().str2addr(argv[2]);
+ 				
+ 			has_set_node = true; 
+ 
+ 			if( has_set_routefile ) {
+ 				readRouteTable(route_file);
+ 			}
+ 			return TCL_OK;
+ 		}
+ 
+ 		if( strcasecmp(argv[1], "set-routefile")==0 ){
+ 			//load routing table
+ 			has_set_routefile = true;
+ 
+ 			strcpy(route_file, argv[2]);
+ 
+ 			if( has_set_node ) {
+ 				readRouteTable(route_file);
+ 			}
+ 			return TCL_OK;
+ 
+ 		}else if (strcasecmp(argv[1], "on-node")==0) {
+ 			//   printf ("inside on node\n");
+ 			node = (UnderwaterSensorNode *)tcl.lookup(argv[2]);
+ 
+ 			return TCL_OK;
+ 		} else if ( strcasecmp(argv[1], "node") == 0 ) {
+ 			node = (UnderwaterSensorNode *)tcl.lookup(argv[2]);
+ 			return TCL_OK;
+ 		} else if (strcasecmp(argv[1], "add-ll") == 0) {
+ 
+ 			TclObject *obj;
+ 
+ 			if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 				fprintf(stderr, "lookup of %s failed\n", argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			ll = (NsObject *) obj;
+ 
+ 			return TCL_OK;
+ 		}else if(strcasecmp (argv[1], "tracetarget") == 0) {
+ 			TclObject *obj;
+ 			if ((obj = TclObject::lookup (argv[2])) == 0) {
+ 				fprintf (stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1],
+ 					argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 
+ 			tracetarget = (Trace *) obj;
+ 			return TCL_OK;
+ 		}else if(strcasecmp(argv[1], "port-dmux") == 0) {
+ 			// printf("vectorbasedforward:port demux is called \n");
+ 			TclObject *obj;
+ 
+ 			if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 				fprintf(stderr, "lookup of %s failed\n", argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			port_dmux = (NsObject *) obj;
+ 			return TCL_OK;
+ 		}
+ 
+ 	} 
+ 
+ 	return Agent::command(argc, argv);
+ }
+ 
+ 
+ void StaticRouting::readRouteTable(char *filename)
+ {
+ 	FILE* stream = fopen(filename, "r");
+ 	nsaddr_t current_node, dst_node, nxt_hop; 
+ 
+ 	if( stream == NULL ) {
+ 		printf("ERROR: Cannot find routing table file!\nEXIT...\n");
+ 		exit(0);
+ 	}
+ 
+ 	while( !feof(stream) ) {
+ 		fscanf(stream, "%d:%d:%d", &current_node, &dst_node, &nxt_hop);
+ 
+ 		if( my_addr == current_node ) {
+ 			rtable_[dst_node] = nxt_hop;
+ 		}
+ 	}
+ 
+ 	fclose(stream);
+ }
+ 
+ 
+ 
+ void StaticRouting::recv(Packet *p, Handler *h)
+ {
+ 	struct hdr_cmn* ch = HDR_CMN(p);
+ 	struct hdr_ip* ih = HDR_IP(p);
+ 
+ 	ch->uw_flag() = true;
+ 
+ 	if( ih->saddr() == my_addr ) {
+ 		if( ch->num_forwards() > 0 ) {
+ 			//there is a loop, and then drop it
+ 			drop(p, DROP_RTR_ROUTE_LOOP);
+ 			return;
+ 		}
+ 		else if (ch->num_forwards() == 0 ) {
+ 			ch->size() +=  SR_HDR_LEN;
+ 		}
+ 	} else if( ch->next_hop() != my_addr ) {
+ 		drop(p, DROP_MAC_DUPLICATE);
+ 		return;
+ 	}
+ 	
+ 	//increase the number of forwards
+ 	ch->num_forwards() += 1;
+ 
+ 	if( ch->direction() == hdr_cmn::UP && 
+ 		( (u_int32_t)ih->daddr() == IP_BROADCAST || ih->daddr() == my_addr ) ) {
+ 		port_dmux->recv(p, (Handler*)NULL);
+ 		return;
+ 	
+ 	} else {
+ 		ch->direction() = hdr_cmn::DOWN;
+ 		ch->addr_type() = NS_AF_INET;
+ 		if ( (u_int32_t)ih->daddr() == IP_BROADCAST ) {
+ 			ch->next_hop() = IP_BROADCAST;
+ 		}
+ 		else {
+ 			if( rtable_.count(ih->daddr()) != 0 )
+ 				ch->next_hop() = rtable_[ih->daddr()];
+ 			else {
+ 				//fail to find the route, drop it
+ 				drop(p, DROP_RTR_NO_ROUTE);
+ 				return;
+ 			}
+ 		}
+ 
+ 		Scheduler::instance().schedule(target_, p, 0.0);
+ 	
+ 	}
+ 
+ }
diff -crBN ns-2.35/underwatersensor/uw_routing/static_routing/static_routing.h ns-2.35-aquasim/underwatersensor/uw_routing/static_routing/static_routing.h
*** ns-2.35/underwatersensor/uw_routing/static_routing/static_routing.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/static_routing/static_routing.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,60 ----
+ #ifndef STATIC_ROUTING
+ #define STATIC_ROUTING
+ 
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "arp.h"
+ #include "mac.h"
+ #include "ll.h"
+ 
+ 
+ #include <map>
+ using namespace std;
+ 
+ /*header length of Static routing*/
+ #define SR_HDR_LEN (3*sizeof(nsaddr_t)+sizeof(int))
+ 
+ class StaticRouting: public Agent {
+ public:
+ 	StaticRouting();
+ 	int command(int argc, const char*const* argv);
+ 	void recv(Packet*, Handler*);
+ protected:
+ 	nsaddr_t my_addr;
+ 
+ 	UnderwaterSensorNode *node;
+ 	Trace *tracetarget;       // Trace Target
+ 	NsObject *ll;  
+ 	NsObject *port_dmux;
+ 	
+ 	bool has_set_routefile;
+ 	bool has_set_node;
+ 	char route_file[50];
+ 
+ 	void readRouteTable(char* filename);
+ 
+ 
+ private:
+ 	map<nsaddr_t, nsaddr_t> rtable_;
+ 	
+ };
+ 
+ 
+ 
+ 
+ #endif
\ No newline at end of file
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_datastructure.h ns-2.35-aquasim/underwatersensor/uw_routing/uw_datastructure.h
*** ns-2.35/underwatersensor/uw_routing/uw_datastructure.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_datastructure.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,99 ----
+ #ifndef ns_uw_datastructure_h
+ #define ns_uw_datastructure_h
+ 
+ 
+ #define THIS_NODE             here_
+ #define JITTER                0.1    //use to generate random 
+ #define DELAY                 1.0
+ //#define DELAY2                0.01
+ 
+ #define SEND_MESSAGE(x,y,z)  send_to_dmux(prepare_message(x,y,z), 0)
+ 
+ // mess types
+ #define INTEREST      1
+ #define DATA          2
+ #define DATA_READY    3
+ #define SOURCE_DISCOVERY 4
+ #define SOURCE_TIMEOUT   5
+ #define TARGET_DISCOVERY 6
+ #define TARGET_REQUEST 7
+ #define SOURCE_DENY  8
+ #define V_SHIFT 9
+ #define FLOODING 10 // not used right now
+ #define DATA_TERMINATION 11
+ #define BACKPRESSURE 12
+ #define BACKFLOODING 13// not used right now 
+ #define EXPENSION 14
+ #define V_SHIFT_DATA 15
+ #define EXPENSION_DATA 16
+ 
+ // next hop status 
+ #define UNKNOWN 1
+ #define FRESHED 2
+ #define DEAD 3
+ //#define SUPPRESSED 4
+ 
+ 
+ 
+ // packet status
+ #define FORWARDED 3
+ #define CENTER_FORWARDED 4
+ #define FLOODED 5
+ //#define DROPPED 6
+ #define TERMINATED 7
+ //#define BACKFORWARDED 8
+ #define SUPPRESSED 9
+ #define VOID_SUPPRESSED 10
+ 
+ 
+ #define MAX_ATTRIBUTE 3
+ #define MAX_NEIGHBORS 30
+ #define MAX_DATA_TYPE 30
+ #define MAX_NEIGHBOR 10
+ #define WINDOW_SIZE  19 
+ 
+ //used by hash table to limited the maximum length
+ 
+ //#define ROUTING_PORT 255
+ 
+ 
+ typedef struct Position{
+   double x;
+   double y;
+   double z;
+ } position;
+ 
+ typedef struct RoutingVector{
+     position start;
+     position end;
+ } routing_vector;
+ 
+ 
+ 
+ struct uw_extra_info {
+ 
+   // ns_addr_t osender_id;            // The original sender of this message
+   // unsigned int seq;           //  sequence number
+ 
+   double ox;  // the start point of the forward path
+   double oy;
+   double oz;
+ 
+   //ns_addr_t sender_id;            // The forwarder of this message
+ 
+   double fx;  // the forward 's position
+   double fy;
+   double fz;
+  
+ // the end point of the forward path
+   double tx; 
+   double ty;
+   double tz;
+ 
+ // this is the information about relative position of the receiver to the forwarder, not include in the header of real packet
+   double dx;
+   double dy;
+   double dz; 
+ 
+ };
+ #endif
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting.cc ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting.cc
*** ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,285 ----
+ #include "uw_drouting.h"
+ #include "cmu-trace.h"
+ #include "address.h"
+ 
+ 
+ int hdr_uw_drouting_pkt::offset_;//??????????? what does this offset mean?
+ static class uwdroutHeaderClass : public PacketHeaderClass {
+ public:
+   uwdroutHeaderClass() : PacketHeaderClass("PacketHeader/uw_drouting",//?????what's relation?
+   sizeof(hdr_uw_drouting_pkt)) {
+ 	bind_offset(&hdr_uw_drouting_pkt::offset_);
+   }
+   
+ } class_rtuwdroutinghdr;
+ 
+ static class uw_droutingClass : public TclClass {
+ public:
+   uw_droutingClass() : TclClass("Agent/uw_drouting") {}
+   TclObject* create(int argc, const char*const* argv) {
+ 	assert(argc == 5);
+ 	return (new uw_drouting((nsaddr_t)Address::instance().str2addr(argv[4])));
+   }
+ } class_rtuw_drouting;
+ 
+ 
+ 
+ void uw_drouting_PktTimer::expire(Event* e) {
+   agent_->send_uw_drouting_pkt();
+   //agent_->reset_uw_drouting_pkt_timer();
+   resched(update_interval()+agent_->broadcast_jitter(10));
+ }
+ 
+ 
+ uw_drouting::uw_drouting(nsaddr_t id) : Agent(PT_UW_DROUTING), pkt_timer_(this, 50) {
+   bind_bool("accessible_var_", &accessible_var_);
+   ra_addr_ = id;
+   rtable_.node_id() = id;
+   coun=0;
+ }
+ 
+ 
+ int uw_drouting::command(int argc, const char*const* argv) {
+   if (argc == 2) {
+ 	if (strcasecmp(argv[1], "start") == 0) {
+ 	  pkt_timer_.resched(0.0000001+broadcast_jitter(10));
+ 	  return TCL_OK;
+ 	}
+ 	else if (strcasecmp(argv[1], "print_rtable") == 0) {
+ 	  if (logtarget_ != 0) {
+ 		sprintf(logtarget_->pt_->buffer(), "P %f _%d_ Routing Table",
+ 				CURRENT_TIME,
+ 				ra_addr());
+ 		logtarget_->pt_->dump();
+ 	  }
+ 	  else {
+ 		fprintf(stdout, "%f _%d_ If you want to print this routing table "
+ 						"you must create a trace file in your tcl script",
+ 						CURRENT_TIME,
+ 						ra_addr());
+ 	  }
+ 	  return TCL_OK;
+ 	}
+   }
+   else if (argc == 3) {
+ 	// Obtains corresponding dmux to carry packets to upper layers
+ 	if (strcmp(argv[1], "port-dmux") == 0) {
+ 	  dmux_ = (PortClassifier*)TclObject::lookup(argv[2]);
+ 	  if (dmux_ == 0) {
+ 		fprintf(stderr, "%s: %s lookup of %s failed\n",
+ 				__FILE__,
+ 				argv[1],
+ 				argv[2]);
+ 		return TCL_ERROR;
+ 	  }
+ 	  return TCL_OK;
+ 	}
+ 	// Obtains corresponding tracer
+ 	else if (strcmp(argv[1], "log-target") == 0 ||
+ 	  strcmp(argv[1], "tracetarget") == 0) {
+ 	  logtarget_ = (Trace*)TclObject::lookup(argv[2]);
+ 	if (logtarget_ == 0)
+ 	  return TCL_ERROR;
+ 	return TCL_OK;
+ 	  }
+   }
+   // Pass the command to the base class
+   return Agent::command(argc, argv);
+ }
+ 
+ 
+ 
+ 
+ void uw_drouting::recv(Packet* p, Handler* h) {
+   struct hdr_cmn* ch = HDR_CMN(p);
+   struct hdr_ip* ih = HDR_IP(p);
+   
+   ch->uw_flag() = true;
+   
+   if (ih->saddr() == ra_addr()) {
+ 	// If there exists a loop, must drop the packet
+ 	if (ch->num_forwards() > 0) {
+ 	  drop(p, DROP_RTR_ROUTE_LOOP);
+ 	  return;
+ 	}
+ 	// else if this is a packet I am originating, must add IP header
+ 	else if (ch->num_forwards() == 0)
+ 	  ch->size() += IP_HDR_LEN;
+   }
+   
+   
+   else if( ch->next_hop()!= (nsaddr_t)IP_BROADCAST && ch->next_hop() != ra_addr() ) {
+ 	drop(p, DROP_MAC_DUPLICATE);
+ 	return;
+   }
+   
+   
+   
+   ch->num_forwards() += 1;
+   
+   // If it is a protoname packet, must process it
+   if (ch->ptype() == PT_UW_DROUTING) {
+ 	recv_uw_drouting_pkt(p);
+ 	return;
+   }
+   // Otherwise, must forward the packet (unless TTL has reached zero)
+   else {
+ 	ih->ttl_--;
+ 	if (ih->ttl_ == 0) {
+ 	  drop(p, DROP_RTR_TTL);
+ 	  return;
+ 	}
+ 	forward_data(p);
+   }
+ }
+ 
+ 
+ void uw_drouting::recv_uw_drouting_pkt(Packet* p) {
+   
+   struct hdr_uw_drouting_pkt* ph = HDR_UW_DROUTING_PKT(p);
+   
+   // All routing messages are sent from and to port RT_PORT,
+   // so we check it.
+   assert(ih->sport() == RT_PORT);
+   assert(ih->dport() == RT_PORT);  
+   // take out the packet, rtable
+   
+   DN temp_DN;
+   rtable_t temp_rt;
+   nsaddr_t temp1;
+   unsigned char* walk = (unsigned char*)p->accessdata();
+   for(uint i=0; i < ph->entry_num(); i++) {
+ 	
+ 	temp1 = *((nsaddr_t*)walk);
+ 	walk += sizeof(nsaddr_t);
+ 	
+ 	temp_DN.first = *((nsaddr_t*)walk);
+ 	//temp2 = *((nsaddr_t*)walk);
+ 	walk += sizeof(nsaddr_t);
+ 	
+ 	//temp_DN[temp2]== *((int*)walk);
+ 	temp_DN.second = *((int*)walk);	
+ 	walk += sizeof(int);
+ 	temp_rt[temp1]=temp_DN;  
+   }
+   
+   
+   rtable_.update(&temp_rt, ph->pkt_src()); 
+   
+   if (rtable_.ifchg() ==1){
+ 	pkt_timer_.update_interval() = 30.0;
+   }
+   
+   if (rtable_.ifchg() ==0)
+   {
+ 	coun++;
+   }
+   
+   if (coun ==2){
+ 	pkt_timer_.update_interval() = 100.0;
+ 	coun=0;
+   }
+   
+   
+   // Release resources
+   Packet::free(p);
+ }
+ 
+ double uw_drouting::broadcast_jitter(double range)
+ {
+ 	return range*Random::uniform();
+ }
+ 
+ 
+ void uw_drouting::send_uw_drouting_pkt() {
+   Packet* p = allocpkt();
+   struct hdr_cmn* ch = HDR_CMN(p);
+   struct hdr_ip* ih = HDR_IP(p);
+   
+   //add by jun
+   struct hdr_uw_drouting_pkt* ph = HDR_UW_DROUTING_PKT(p);
+   
+   ph->pkt_src() = ra_addr();
+   ph->pkt_len() = 7;
+   ph->pkt_seq_num() = seq_num_++;
+   ph->entry_num() = rtable_.size();
+   
+   ph->pkt_len()=sizeof(ph->pkt_len())+sizeof(ph->pkt_src())+sizeof(ph->pkt_seq_num())+sizeof(ph->entry_num());
+   
+   int DataSize = (rtable_.size())*(2*sizeof(nsaddr_t)+sizeof(int)) ;
+   
+   
+   p->allocdata( DataSize );
+   
+   unsigned char* walk = (unsigned char*)p->accessdata();  
+   
+   for(rtable_t::iterator it=rtable_.rt_.begin(); it!=rtable_.rt_.end(); it++)    {  
+ 	
+ 	*(nsaddr_t*)walk = it->first;       
+ 	
+ 	walk += sizeof(it->first);  
+ 	
+ 	*(nsaddr_t*)walk = it->second.first;  
+ 	
+ 	walk += sizeof(it->second.first);  
+ 	
+ 	*(int*)walk = it->second.second;     
+ 	
+ 	walk += sizeof(it->second.second);   
+ 	
+   }
+   
+   ch->ptype() = PT_UW_DROUTING;
+   
+   ih->saddr() = ra_addr();
+   ih->daddr() = IP_BROADCAST;
+   ih->sport() = RT_PORT;
+   ih->dport() = RT_PORT;
+   ih->ttl() = 1;
+   
+   ch->direction() = hdr_cmn::DOWN;
+   ch->size() = IP_HDR_LEN + ph->pkt_len()+DataSize;
+   ch->error() = 0;
+   ch->next_hop() = IP_BROADCAST;
+   ch->addr_type() = NS_AF_INET;
+   ch->uw_flag() = true;
+   
+   Scheduler::instance().schedule(target_, p, JITTER);
+ }
+ 
+ 
+ void uw_drouting::reset_uw_drouting_pkt_timer() {
+   pkt_timer_.resched((double)50.0+broadcast_jitter(10));//   should be coustimized
+ } 
+ 
+ void uw_drouting::forward_data(Packet* p) {
+   struct hdr_cmn* ch = HDR_CMN(p);
+   struct hdr_ip* ih = HDR_IP(p);
+   
+   //double t = NOW;
+   if (ch->direction() == hdr_cmn::UP &&
+ 	((u_int32_t)ih->daddr() == IP_BROADCAST || ih->daddr() == ra_addr())) {
+ 	ch->size() -= IP_HDR_LEN;
+ 	dmux_->recv(p, (Handler*)NULL);
+   return;
+ 	}
+ 	else {
+ 	  ch->direction() = hdr_cmn::DOWN;
+ 	  ch->addr_type() = NS_AF_INET;
+ 	  if ((u_int32_t)ih->daddr() == IP_BROADCAST)
+ 		ch->next_hop() = IP_BROADCAST;
+ 	  else {
+ 		nsaddr_t next_hop = rtable_.lookup(ih->daddr());
+ 		
+ 		if (next_hop == (nsaddr_t)IP_BROADCAST) {
+ 		  debug("%f: Agent %d can not forward a packet destined to %d\n",
+ 					 CURRENT_TIME, ra_addr(), ih->daddr());
+   drop(p, DROP_RTR_NO_ROUTE);
+   return;
+ 		}
+ 		else
+ 		  ch->next_hop() = next_hop;
+ 	  }
+ 	  Scheduler::instance().schedule(target_, p, 0.0);
+ 	}
+ }
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting.h ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting.h
*** ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,75 ----
+ #ifndef __uw_drouting_h__
+ #define __uw_drouting_h__
+ 
+ #include "uw_drouting_pkt.h"
+ #include "uw_drouting_rtable.h"
+ #include <agent.h>
+ #include <packet.h>
+ #include <trace.h>
+ #include <timer-handler.h>
+ #include <random.h>
+ #include <classifier-port.h>
+ 
+  #define CURRENT_TIME Scheduler::instance().clock()
+  #define JITTER (Random::uniform()*0.5)
+ 
+  class uw_drouting; // forward declaration
+ 
+  /* Timers */
+ 
+  class uw_drouting_PktTimer : public TimerHandler {
+  public:
+  uw_drouting_PktTimer(uw_drouting* agent, double update_interval) : TimerHandler() {
+  agent_ = agent;
+  }
+  double& update_interval() {
+    return update_interval_;
+ }
+  protected:
+  uw_drouting* agent_;
+  double		update_interval_;
+  virtual void expire(Event* e);
+  };
+ 
+  /* Agent */
+ 
+  class uw_drouting : public Agent {
+ 
+  /* Friends */
+  friend class uw_drouting_PktTimer;
+ 
+  /* Private members */
+  nsaddr_t ra_addr_;
+ // uw_drouting_state state_;//?????????define state
+  //uw_drouting_rtable rtable_;//????????define table 
+  uw_drouting_rtable  rtable_;//add by jun
+  
+  int accessible_var_;
+  u_int8_t seq_num_;
+ 
+  protected:
+ 
+  PortClassifier* dmux_; // For passing packets up to agents.
+  Trace* logtarget_; // For logging.
+  uw_drouting_PktTimer pkt_timer_; // Timer for sending packets.
+ 
+  inline nsaddr_t& ra_addr() { return ra_addr_; }
+ // inline uw_drouting_state& state() { return state_; }
+  inline int& accessible_var() { return accessible_var_; };
+ 
+  void forward_data(Packet*);
+  void recv_uw_drouting_pkt(Packet*);
+  void send_uw_drouting_pkt();
+  void reset_uw_drouting_pkt_timer();
+  double broadcast_jitter(double range);
+ 
+  public:
+ 
+  uw_drouting(nsaddr_t);
+  int command(int, const char*const*);
+  void recv(Packet*, Handler*);
+  int coun;
+ 
+  };
+ 
+  #endif
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting_pkt.h ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting_pkt.h
*** ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting_pkt.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting_pkt.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,53 ----
+ #ifndef ns_uw_drouting_pkt_h
+ #define ns_uw_drouting_pkt_h
+ 
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ 
+ #include "uw_drouting_rtable.h"
+ 
+ #define HDR_UW_DROUTING_PKT(P) hdr_uw_drouting_pkt::access(p)
+ 
+ 
+ struct hdr_uw_drouting_pkt {
+ 
+  nsaddr_t  pkt_src_; // Node which originated this packet
+  u_int16_t pkt_len_; // Packet length (in bytes)
+  u_int8_t  pkt_seq_num_; // Packet sequence number
+  u_int32_t entry_num_; // Packet length (in bytes)
+  
+  //add by jun-------routing table
+  
+  inline nsaddr_t&  pkt_src() { return pkt_src_; }
+  inline u_int16_t& pkt_len() { return pkt_len_; }
+  inline u_int8_t&  pkt_seq_num() { return pkt_seq_num_; }
+  inline u_int32_t& entry_num() { return entry_num_; }
+ 
+  static int offset_;
+  inline static int& offset() { return offset_; }
+  inline static hdr_uw_drouting_pkt* access(const Packet* p) {
+  return (hdr_uw_drouting_pkt*)p->access(offset_);
+  }
+ 
+  };
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.cc ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.cc
*** ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,98 ----
+ #include "uw_drouting_rtable.h"
+ 
+ uw_drouting_rtable::uw_drouting_rtable() { }
+ 
+ 
+ void uw_drouting_rtable::print(nsaddr_t id) {
+   printf("%f node %d Routing Table:\n", NOW, id);
+   for (rtable_t::iterator it = rt_.begin(); it != rt_.end(); it++) {
+   printf("%d\t%d\t%d\t%d\n",
+   id,
+   (*it).first,
+   (*it).second.first,
+ 	it->second.second  );
+  }
+ }
+ 
+ 
+  int uw_drouting_rtable::ifchg (){
+ 
+       return chg;
+ 
+ }
+ 
+ void uw_drouting_rtable::clear() {
+    rt_.clear();
+ }
+ 
+ void uw_drouting_rtable::rm_entry(nsaddr_t dest) {
+   rt_.erase(dest);
+  }
+ 
+ void uw_drouting_rtable::add_entry(nsaddr_t dest, DN next) {
+   rt_[dest] = next;
+  }
+ 
+ //nsaddr_t uw_drouting_rtable::lookup(nsaddr_t dest) {
+ nsaddr_t uw_drouting_rtable::lookup(nsaddr_t dest) {
+    rtable_t::iterator it = rt_.find(dest);
+    if (it == rt_.end())
+ 	  return (nsaddr_t)IP_BROADCAST;
+    else
+ 	  return (*it).second.first;//add by jun
+ }
+ 
+ 
+  u_int32_t uw_drouting_rtable::size() {
+   return rt_.size();
+  }
+  
+  
+ void uw_drouting_rtable::update(rtable_t* newrt, nsaddr_t Source_N) {    //add by jun
+   
+    DN tp;
+    nsaddr_t tmp;
+    chg=0;
+ 
+    	
+    	  if (lookup(Source_N) == (nsaddr_t)IP_BROADCAST){
+    	    tp.first= Source_N;	    
+ 	    tp.second=1;	    
+ 	    add_entry(Source_N, tp);
+ 	    chg=1;
+ 	  }
+ 
+ 		  for( rtable_t:: iterator it=newrt->begin(); it !=newrt->end(); it++)  {       
+   
+ 				if( it->first == node_id() ) 
+ 				  continue;
+ 				
+ 				if (lookup((*it).first) != (nsaddr_t)IP_BROADCAST){
+ 
+ 					  tmp = lookup((*it).first);             	     
+ 	    
+ 					  if (rt_[it->first].second > (*it).second.second +1 ){	      
+ 						rm_entry((*it).first);	      
+ 						tp.first=Source_N;
+ 						tp.second=(*it).second.second+1;
+ 						add_entry((*it).first, tp);  
+ 						chg=1;
+ 	    
+ 					  }  	    
+     
+ 				  }  
+ 				  else{
+ 					tp.first= Source_N;
+ 					tp.second=(*it).second.second + 1;
+ 					add_entry((*it).first, tp);
+ 					chg=1;
+ 	    
+ 				  }      
+ 	    	    
+   
+ 			}
+ 
+     
+ }
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.h ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.h
*** ns-2.35/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_drouting/uw_drouting_rtable.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,53 ----
+ #ifndef __uw_drouting_rtable_h__
+ #define __uw_drouting_rtable_h__
+ 
+ #include <trace.h>
+ #include <map>
+ #include <ip.h>
+ 
+ struct DN {
+ nsaddr_t first;
+ nsaddr_t second;
+ };
+ 
+ 
+ //typedef std::map<nsaddr_t, int> DN;//should be defined
+ class uw_drouting;
+ typedef std::map<nsaddr_t, DN> rtable_t;//should be defined
+ 
+ class uw_drouting_rtable {
+ 
+ friend class uw_drouting;
+  rtable_t rt_;
+  int chg;
+  nsaddr_t node_id_;
+ 
+  public:
+ 
+  uw_drouting_rtable();
+  
+  nsaddr_t& node_id() {
+    return node_id_;
+   }
+  
+  void print(nsaddr_t id);
+  
+  void clear();
+  
+  void rm_entry(nsaddr_t);
+  
+  //void add_entry(nsaddr_t, nsaddr_t); 
+  
+  void add_entry(nsaddr_t, DN);//add by jun
+  
+  void update(rtable_t*, nsaddr_t); // add by jun
+ 
+  //nsaddr_t lookup(nsaddr_t);
+  nsaddr_t lookup(nsaddr_t);
+ 
+  u_int32_t size();
+ 
+  int ifchg ();
+  };
+ 
+  #endif
diff -crBN ns-2.35/underwatersensor/uw_routing/uwflooding.cc ns-2.35-aquasim/underwatersensor/uw_routing/uwflooding.cc
*** ns-2.35/underwatersensor/uw_routing/uwflooding.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uwflooding.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,356 ----
+ 
+ 
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ 
+ //#include "underwatersensor/uw_common/uwvb_header.h"
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "node.h"
+ #include "uwflooding.h"
+ #include "underwatersensor/uw_common/uw_hash_table.h"
+ //#include "arp.h"
+ //#include "mac.h"
+ //#include "ll.h"
+ //#include "dsr/path.h"
+ #include "god.h"
+ 
+ 
+ 
+ static class UWFloodingClass : public TclClass {
+ public:
+   UWFloodingClass() : TclClass("Agent/UWFlooding") {}
+   TclObject* create(int argc, const char*const* argv) {
+     return(new UWFloodingAgent());
+   }
+ } class_uwfloodingclass;
+ 
+ 
+ UWFloodingAgent::UWFloodingAgent() : Agent(PT_UWVB)
+ {
+   // Initialize variables.
+   //  printf("VB initialized\n");
+   pk_count = 0;
+   target_ = 0;
+    node = NULL;
+   tracetarget = NULL;
+   
+ }
+ 
+ 
+ void UWFloodingAgent::recv(Packet* packet, Handler*)
+ {
+  
+ 
+   // printf ("uwflooding: I have get a packet \n ");
+   hdr_uwvb* vbh = HDR_UWVB(packet);
+   unsigned char msg_type =vbh->mess_type;
+   unsigned int dtype =0;// vbh->data_type;
+  
+   // Packet Hash Table is used to keep info about experienced pkts.
+  
+     vbf_neighborhood *hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 
+      // Received this packet before ?
+ 
+     if (hashPtr != NULL) {Packet::free(packet);}
+       else {
+  
+      PktTable.put_in_hash(vbh);
+  
+      // Take action for a new pkt.
+       
+      ConsiderNew(packet);     
+       }
+ }
+ 
+ void UWFloodingAgent::ConsiderNew(Packet *pkt)
+ {
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+   unsigned char msg_type =vbh->mess_type;
+   unsigned int dtype = 0;//vbh->data_type;
+   double l,h;
+   
+   //Pkt_Hash_Entry *hashPtr;
+   ns_addr_t * hashPtr;
+   //  Agent_List *agentPtr;
+   // PrvCurPtr  RetVal;
+    ns_addr_t   from_nodeID, forward_nodeID, target_nodeID;
+ 
+   Packet *gen_pkt;
+   hdr_uwvb *gen_vbh;
+   //   printf("uwflooding(%d,%d):it is data packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);    
+   //  printf("Vectorbasedforward:oops!\n");
+   switch (msg_type) {
+    
+     case DATA :
+       //    printf("uwflooding(%d,%d):it is data packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);    
+       from_nodeID = vbh->sender_id;
+       if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 	// come from the same node, briadcast it
+       MACprepare(pkt);
+       MACsend(pkt,0); 
+       return;      
+ }
+          	  
+ 
+ 	 if (THIS_NODE.addr_==vbh->target_id.addr_)
+ 	   {
+ 	     //	printf("uwflooding: %d is the target\n", here_.addr_);
+ 	      DataForSink(pkt); // process it
+ 	       }
+ 
+ 	else{
+ 	  // printf("uwflooding: %d is the not  target\n", here_.addr_);	 
+       MACprepare(pkt);
+       MACsend(pkt, 0);
+ 	}
+       return;
+ 
+     default : 
+       
+       Packet::free(pkt);        
+       break;
+   }
+ }
+ 
+ 
+ void UWFloodingAgent::reset()
+ {
+   PktTable.reset();
+   /*
+   for (int i=0; i<MAX_DATA_TYPE; i++) {
+     routing_table[i].reset();
+   }
+   */
+ }
+ 
+ 
+ void UWFloodingAgent::Terminate() 
+ {
+ #ifdef DEBUG_OUTPUT
+ 	printf("node %d: remaining energy %f, initial energy %f\n", THIS_NODE, 
+ 	       node->energy_model()->energy(), 
+ 	       node->energy_model()->initialenergy() );
+ #endif
+ }
+ 
+ 
+ void UWFloodingAgent::StopSource()
+ {
+   /*
+   Agent_List *cur;
+ 
+   for (int i=0; i<MAX_DATA_TYPE; i++) {
+     for (cur=routing_table[i].source; cur!=NULL; cur=AGENT_NEXT(cur) ) {
+       SEND_MESSAGE(i, AGT_ADDR(cur), DATA_STOP);
+     }
+   }
+   */
+ }
+ 
+ 
+ Packet * UWFloodingAgent:: create_packet()
+ {
+   Packet *pkt = allocpkt();
+ 
+   if (pkt==NULL) return NULL;
+ 
+   hdr_cmn*  cmh = HDR_CMN(pkt);
+   cmh->size() = 36;
+ 
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+   vbh->ts_ = NOW;
+    
+ 
+   return pkt;
+ }
+ 
+ 
+ Packet *UWFloodingAgent::prepare_message(unsigned int dtype, ns_addr_t to_addr,  int msg_type)
+ 
+ {
+   Packet *pkt;
+   hdr_uwvb *vbh;
+   //hdr_ip *iph;
+ 
+     pkt = create_packet();
+     vbh = HDR_UWVB(pkt);
+     // iph = HDR_IP(pkt);
+     
+     vbh->mess_type = msg_type;
+     vbh->pk_num = pk_count;
+     pk_count++;
+     vbh->sender_id = here_;
+     // vbh->data_type = dtype;
+     vbh->forward_agent_id = here_;
+ 
+     vbh->ts_ = NOW;
+     return pkt;
+ }
+ 
+ void UWFloodingAgent::MACprepare(Packet *pkt)
+ {
+ 
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+   hdr_cmn* cmh = HDR_CMN(pkt);
+   // hdr_ip*  iph = HDR_IP(pkt); // I am not sure if we need it
+ 
+ 
+   vbh->forward_agent_id = here_; 
+  
+   cmh->xmit_failure_ = 0;
+   // printf("vectorbased: the mac_Broadcast is:%d\n",MAC_BROADCAST);
+   cmh->next_hop() = MAC_BROADCAST; 
+   cmh->addr_type() = NS_AF_ILINK;  
+  
+   cmh->direction() = hdr_cmn::DOWN;
+ 
+ }
+ 
+ 
+ void UWFloodingAgent::MACsend(Packet *pkt, Time delay)
+ {
+   hdr_cmn*  cmh = HDR_CMN(pkt);
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+  
+  if (vbh->mess_type == DATA)
+     cmh->size() = (God::instance()->data_pkt_size) ;
+   else
+     cmh->size() = 36;
+    
+   Scheduler::instance().schedule(ll, pkt, delay);
+ }
+ 
+ 
+ void UWFloodingAgent::DataForSink(Packet *pkt)
+ {
+ 
+   //  printf("DataforSink: the packet is send to demux\n");
+       send_to_dmux(pkt, 0);
+ 
+ }
+ 
+ 
+ 
+ void UWFloodingAgent::trace (char *fmt,...)
+ {
+   va_list ap;
+ 
+   if (!tracetarget)
+     return;
+ 
+   va_start (ap, fmt);
+   vsprintf (tracetarget->pt_->buffer(), fmt, ap);
+   tracetarget->pt_->dump ();
+   va_end (ap);
+ }
+ 
+ 
+ 
+ int UWFloodingAgent::command(int argc, const char*const* argv)
+ {  
+   Tcl& tcl =  Tcl::instance();
+ 
+   if (argc == 2) {
+ 
+     if (strcasecmp(argv[1], "reset-state")==0) {
+       
+       reset();
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "reset")==0) {
+       
+       return Agent::command(argc, argv);
+     }
+ 
+     if (strcasecmp(argv[1], "start")==0) {
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "stop")==0) {
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "terminate")==0) {
+       Terminate();
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "stop-source")==0) {
+       StopSource();
+       return TCL_OK;
+     }
+ 
+   } else if (argc == 3) {
+ 
+     if (strcasecmp(argv[1], "on-node")==0) {
+       // printf ("inside on node\n");
+       node = (MobileNode *)tcl.lookup(argv[2]);
+       return TCL_OK;
+     }
+     /*
+       if (strcasecmp(argv[1], "set-port")==0) {
+       printf ("inside on node\n");
+       port_number=atoi(argv[2]);
+       return TCL_OK;
+     }
+     */
+     if (strcasecmp(argv[1], "add-ll") == 0) {
+ 
+       TclObject *obj;
+ 
+       if ( (obj = TclObject::lookup(argv[2])) == 0) {
+     fprintf(stderr, "UWFlooding Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 	return TCL_ERROR;
+       }
+       ll = (NsObject *) obj;
+ 
+      return TCL_OK;
+     }
+ 
+     if (strcasecmp (argv[1], "tracetarget") == 0) {
+       TclObject *obj;
+       if ((obj = TclObject::lookup (argv[2])) == 0) {
+ 	  fprintf (stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1],
+ 		   argv[2]);
+ 	  return TCL_ERROR;
+       }
+ 
+       tracetarget = (Trace *) obj;
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "port-dmux") == 0) {
+       //   printf("uwflooding:port demux is called \n");
+       TclObject *obj;
+ 
+       if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 	fprintf(stderr, "VB node Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 	return TCL_ERROR;
+       }
+       port_dmux = (NsObject *) obj;
+       return TCL_OK;
+     }
+ 
+   } 
+ 
+   return Agent::command(argc, argv);
+ }
+ 
+ 
+ // Some methods for Flooding Entry
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/uwflooding.h ns-2.35-aquasim/underwatersensor/uw_routing/uwflooding.h
*** ns-2.35/underwatersensor/uw_routing/uwflooding.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uwflooding.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,97 ----
+ 
+ #ifndef ns_uwflooding_h
+ #define ns_uwflooding_h
+ 
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "underwatersensor/uw_routing/vectorbasedforward.h"
+ #include "underwatersensor/uw_routing/uw_datastructure.h"
+ //#include "arp.h"
+ //#include "mac.h"
+ //#include "ll.h"
+ //#include "dsr/path.h"
+ 
+ 
+ //#define THIS_NODE             here_
+ //#define THIS_NODE             here_.addr_
+ //#define JITTER                0.01       // (sec) to jitter broadcast
+ //#define DELAY                 0.01 //the timeout for electing source
+ 
+ 
+ #define SEND_MESSAGE(x,y,z)  send_to_dmux(prepare_message(x,y,z), 0)
+ 
+ 
+ // Vectorbasedforward  Entry
+ 
+ 
+ 
+ class UWFloodingAgent;
+ 
+ 
+ // Vectorbasedforward Agent
+ 
+ class UWFloodingAgent : public Agent {
+  public:
+   UWFloodingAgent();
+   int command(int argc, const char*const* argv);
+   void recv(Packet*, Handler*);
+ 
+   // Vectorbasedforward_Entry routing_table[MAX_DATA_TYPE];
+ 
+  protected:
+   int pk_count;
+   // int port_number;
+   UWPkt_Hash_Table PktTable;
+   UWPkt_Hash_Table SourceTable;
+   UWPkt_Hash_Table Target_discoveryTable;
+   UWPkt_Hash_Table SinkTable;
+   //UWDelayTimer delaytimer; 
+   
+   MobileNode *node;
+   Trace *tracetarget;       // Trace Target
+   NsObject *ll;  
+   NsObject *port_dmux;
+  
+   
+ 
+    inline void send_to_dmux(Packet *pkt, Handler *h) { 
+     port_dmux->recv(pkt, h); 
+   }
+ 
+   void Terminate();
+   void reset();
+   void ConsiderNew(Packet *pkt);
+   Packet *create_packet();
+   Packet *prepare_message(unsigned int dtype, ns_addr_t to_addr, int msg_type);
+ 
+   
+   void DataForSink(Packet *pkt);
+   void StopSource();
+   void MACprepare(Packet *pkt);
+   void MACsend(Packet *pkt, Time delay=0);
+ 
+   void trace(char *fmt,...);
+ };
+ 
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_routing_buffer.cc ns-2.35-aquasim/underwatersensor/uw_routing/uw_routing_buffer.cc
*** ns-2.35/underwatersensor/uw_routing/uw_routing_buffer.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_routing_buffer.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,236 ----
+ #include "uw_routing_buffer.h"
+ #include "vectorbasedforward.h"
+ #include "vectorbasedvoidavoidance.h"
+ void 
+ RoutingBuffer::AddNewPacket(Packet* p){
+   routing_buffer_cell* t1=new routing_buffer_cell;
+ 
+ 
+   hdr_uwvb* vbh=HDR_UWVB(p);
+   hdr_uwvbva* vbvah=HDR_UWVBVA(p);
+ 
+ 
+    ns_addr_t source;
+    if (usr) source=vbh->sender_id;
+    else source=vbvah->sender_id;
+   unsigned int pkt_num;
+    if(usr) pkt_num=vbh->pk_num;
+    else pkt_num= vbvah->pk_num;
+ 
+ 
+  Packet* tpkt=DeQueue(source,pkt_num); // avoid duplication
+   if(tpkt)Packet::free(tpkt);
+ 
+ 
+   if (IsFull()) {
+ //      printf("ok, full\n");
+       Packet::free(Dehead());
+       }
+   if(!t1){ 
+ //  printf("routingBuffer: can't get allocated  memory\n");
+   return;
+   }
+ 
+   t1->packet=p;
+   t1->next=NULL;
+ 
+   if(head_==NULL) {
+       // printf("head is empty ok\n");
+      tail_=t1;
+      head_=t1;
+   }
+   else{
+       //  printf("head is not empty ok\n");
+   tail_->next=t1;
+   tail_=t1;
+   }
+   
+   num_of_packet++;
+ }
+ 
+ 
+ void 
+ RoutingBuffer::CopyNewPacket(Packet* pkt){
+   routing_buffer_cell* t1=new routing_buffer_cell;
+   Packet* p=pkt->copy();
+  
+ 
+   hdr_uwvb* vbh=HDR_UWVB(pkt);
+   hdr_uwvbva* vbvah=HDR_UWVBVA(p);
+ 
+ 
+  
+    ns_addr_t source;
+    if (usr) source=vbh->sender_id;
+    else source=vbvah->sender_id;
+   unsigned int pkt_num;
+    if(usr) pkt_num=vbh->pk_num;
+    else pkt_num= vbvah->pk_num;
+ 
+ 
+    /*
+   ns_addr_t source=((usr)?: vbh->sender_id,vbvah->sender_id);
+   unsigned int pkt_num=((usr)?: vbh->pk_num, vbvah->pk_num);
+ 
+   
+   ns_addr_t source=vbh->sender_id;
+   unsigned int pkt_num=vbh->pk_num;
+   */
+ 
+    //  printf("uw_buffer: pkt_num is%d\n",pkt_num);
+  Packet* tpkt=DeQueue(source,pkt_num); // avoid duplication
+   if(tpkt)Packet::free(tpkt);
+ 
+   if (IsFull()) Packet::free(Dehead());
+ 
+ 
+   t1->packet=p;
+   t1->next=NULL;
+ 
+   if(head_==NULL) {
+      tail_=t1;
+      head_=t1;
+   }
+   else{
+   tail_->next=t1;
+   tail_=t1;
+   }
+   
+   num_of_packet++;
+ //printf("CopyNewPacket the pkt_num is %d and %d packets in buffer\n",vbh->pk_num,num_of_packet);
+ }
+ 
+ 
+ Packet* 
+ RoutingBuffer::head(){
+   routing_buffer_cell* t1;
+   routing_buffer_cell* t2;
+   Packet* p;
+   
+   if(!head_) return NULL;
+   else return head_->packet;
+ }
+ 
+ 
+ Packet* 
+ RoutingBuffer::Dehead(){
+   routing_buffer_cell* t1;
+   routing_buffer_cell* t2;
+   Packet* p;
+   
+   if(!head_) return NULL;
+    p=head_->packet;
+    t2=head_;
+    head_=head_->next;
+    num_of_packet--;
+    
+    if(!head_) tail_=NULL; 
+     delete t2;
+    return p;
+ }
+ 
+ bool 
+ RoutingBuffer::IsEmpty(){
+   return(0==num_of_packet);
+ }
+ 
+ bool 
+ RoutingBuffer::IsFull(){
+     //printf("maximum size is %d and num_packet is%d\n",maximum_size,num_of_packet);
+   return(maximum_size==num_of_packet);
+ }
+ 
+ 
+ Packet*
+ RoutingBuffer::DeQueue( ns_addr_t sender,unsigned int num){
+     routing_buffer_cell * current_p=head_;
+     routing_buffer_cell * previous_p=head_;
+     Packet* p=0;
+     if(IsEmpty()) return NULL; 
+     while (current_p)
+     {
+         hdr_uwvb* vbh=HDR_UWVB(current_p->packet);
+         hdr_uwvbva* vbvah=HDR_UWVBVA(current_p->packet);     
+ 
+ 
+        
+    ns_addr_t source;
+    if (usr) source=vbh->sender_id;
+    else source=vbvah->sender_id;
+    unsigned int pkt_num;
+    if(usr) pkt_num=vbh->pk_num;
+    else pkt_num= vbvah->pk_num;
+ 
+    /*
+   ns_addr_t source=((usr)?: vbh->sender_id,vbvah->sender_id);
+   unsigned int pkt_num=((usr)?: vbh->pk_num, vbvah->pk_num);
+    */
+ 
+ //printf("ok, DEQUEUE buffer sender id is %d num=%d\n",vbh->sender_id.addr_,vbh->pk_num);
+         if((source.addr_==sender.addr_)&&(source.port_==sender.port_)&&(pkt_num==num))
+ {
+    
+ 	    p=current_p->packet;
+             
+             if(current_p==head_){
+ 		head_=head_->next;
+ 		if(!head_) tail_=0;
+ 		//	delete current_p;
+ 	    }
+ 	    else 
+ 	    {
+                 if(current_p==tail_)tail_=previous_p; 
+ 		previous_p->next=current_p->next;
+ 		//    delete current_p;
+ 	    }
+ 
+             delete current_p;
+             num_of_packet--;
+ 	    return p;
+ }
+           previous_p=current_p;
+ 	current_p=current_p->next; 
+         
+     }
+     return NULL;
+ }
+ 
+ 
+ 
+ Packet*
+ RoutingBuffer::LookupCopy( ns_addr_t sender,unsigned int num){
+     routing_buffer_cell * current_p=head_;
+     Packet* p=NULL;
+     if(IsEmpty()) {
+ //printf("buffer: the data link is empty\n");
+ return NULL;
+     }   
+     while (current_p)
+     {
+         hdr_uwvb* vbh=HDR_UWVB(current_p->packet);
+         hdr_uwvbva* vbvah=HDR_UWVBVA(current_p->packet);     
+     
+    ns_addr_t source;
+    if (usr) source=vbh->sender_id;
+    else source=vbvah->sender_id;
+   unsigned int pkt_num;
+    if(usr) pkt_num=vbh->pk_num;
+    else pkt_num= vbvah->pk_num;
+ 
+    /*
+   ns_addr_t source=((usr)?: vbh->sender_id,vbvah->sender_id);
+   unsigned int pkt_num=((usr)?: vbh->pk_num, vbvah->pk_num);
+    */
+ 
+ //printf("ok, Lookup buffer sender id is %d num=%d\n",vbh->sender_id.addr_,vbh->pk_num);
+         if((source.addr_==sender.addr_)&&(source.port_==sender.port_)&&(pkt_num==num))  {
+           p=current_p->packet;
+           return p;
+ 	} 
+ 	current_p=current_p->next; 
+     }
+     return p;
+ }
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/uw_routing_buffer.h ns-2.35-aquasim/underwatersensor/uw_routing/uw_routing_buffer.h
*** ns-2.35/underwatersensor/uw_routing/uw_routing_buffer.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/uw_routing_buffer.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,42 ----
+ #ifndef ns_uw_routing_buffer_h
+ #define ns_uw_routing_buffer_h
+ 
+ #include "packet.h"
+ 
+ 
+ typedef struct RoutingBufferCell{
+   Packet* packet;
+   RoutingBufferCell* next;
+   double arrival_time;
+ } routing_buffer_cell;
+ 
+ 
+ class RoutingBuffer{
+  public: 
+                   RoutingBuffer(int size=10, int myuser=1){
+                   head_=NULL;
+                   tail_=NULL;
+                   num_of_packet=0;
+                   maximum_size=size;
+                   usr=myuser;
+                           };
+ 
+    
+     void AddNewPacket(Packet*);
+     void CopyNewPacket(Packet*);// copy the packet and put into queue
+     Packet* Dehead();
+     Packet* DeQueue(ns_addr_t,unsigned int);
+     // Packet* Lookup(ns_addr_t, int);
+     Packet* LookupCopy(ns_addr_t,unsigned int);
+     Packet* head();
+     inline int bufferSize()const {return num_of_packet;}
+     bool IsEmpty();
+     bool IsFull();
+     int usr; // this added later distinguish VBVA and VBF 1 is used for vbf 0 is used for vbva
+  private:
+        int num_of_packet;
+        int maximum_size;
+        routing_buffer_cell* head_;
+        routing_buffer_cell* tail_;
+ };
+ #endif /* __uw_routing_buffer_h__ */
diff -crBN ns-2.35/underwatersensor/uw_routing/vectorbasedforward.cc ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward.cc
*** ns-2.35/underwatersensor/uw_routing/vectorbasedforward.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,1119 ----
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ #include <tcl.h>
+ #include "underwatersensor/uw_mac/underwaterchannel.h"
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "ip.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "node.h"
+ #include "vectorbasedforward.h"
+ #include "arp.h"
+ #include "mac.h"
+ #include "ll.h"
+ #include "dsr/path.h"
+ #include "god.h"
+ #include  "underwatersensor/uw_mac/underwaterpropagation.h"
+ 
+ 
+ int hdr_uwvb::offset_;
+ 
+ 
+ static class UWVBHeaderClass: public PacketHeaderClass{
+ public:
+ 	UWVBHeaderClass():PacketHeaderClass("PacketHeader/UWVB",sizeof(hdr_uwvb))
+ 	{
+ 		bind_offset(&hdr_uwvb::offset_);
+ 	} 
+ } class_uwvbhdr;
+ 
+ 
+ 
+ 
+ void UWPkt_Hash_Table::reset()
+ {
+ 	vbf_neighborhood *hashPtr;
+ 	Tcl_HashEntry *entryPtr;
+ 	Tcl_HashSearch searchPtr;
+ 
+ 	entryPtr = Tcl_FirstHashEntry(&htable, &searchPtr);
+ 	while (entryPtr != NULL) {
+ 		hashPtr = (vbf_neighborhood *)Tcl_GetHashValue(entryPtr);
+ 		delete hashPtr;
+ 		Tcl_DeleteHashEntry(entryPtr);
+ 		entryPtr = Tcl_NextHashEntry(&searchPtr);
+ 	}
+ }
+ 
+ 
+ 
+ vbf_neighborhood* UWPkt_Hash_Table::GetHash(ns_addr_t sender_id, 
+ 											unsigned int pk_num)
+ {
+ 	unsigned int key[3];
+ 
+ 	key[0] = sender_id.addr_;
+ 	key[1] = sender_id.port_;
+ 	key[2] = pk_num;
+ 
+ 	Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(&htable, (char *)key);
+ 
+ 	if (entryPtr == NULL )
+ 		return NULL;
+ 
+ 	return (vbf_neighborhood *)Tcl_GetHashValue(entryPtr);
+ }
+ 
+ 
+ 
+ void UWPkt_Hash_Table::put_in_hash(hdr_uwvb * vbh)
+ {
+ 	Tcl_HashEntry *entryPtr;
+ 	// Pkt_Hash_Entry    *hashPtr;
+ 	vbf_neighborhood* hashPtr;
+ 	unsigned int key[3];
+ 	int newPtr;
+ 
+ 	key[0]=(vbh->sender_id).addr_;
+ 	key[1]=(vbh->sender_id).port_;
+ 	key[2]=vbh->pk_num;
+ 
+ 
+ 	int  k=key[2]-window_size;
+ 	if(k>0)
+ 	{
+ 		for (int i=0;i<k;i++)
+ 		{
+ 			key[2]=i;
+ 			entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+ 			if (entryPtr)
+ 			{
+ 				hashPtr=(vbf_neighborhood*)Tcl_GetHashValue(entryPtr);
+ 				delete hashPtr;
+ 				Tcl_DeleteHashEntry(entryPtr);
+ 			}
+ 		}
+ 	}     
+ 
+ 	key[2]=vbh->pk_num;
+ 	entryPtr = Tcl_CreateHashEntry(&htable, (char *)key, &newPtr);
+ 	if (!newPtr){
+ 		hashPtr=GetHash(vbh->sender_id,vbh->pk_num);
+ 		int m=hashPtr->number;
+ 		if (m<MAX_NEIGHBOR){
+ 			hashPtr->number++;
+ 			hashPtr->neighbor[m].x=0;
+ 			hashPtr->neighbor[m].y=0;
+ 			hashPtr->neighbor[m].z=0;
+ 		}
+ 		return;
+ 	}
+ 	hashPtr=new vbf_neighborhood[1];
+ 	hashPtr[0].number=1;
+ 	hashPtr[0].neighbor[0].x=0;
+ 	hashPtr[0].neighbor[0].y=0;
+ 	hashPtr[0].neighbor[0].z=0;
+ 	Tcl_SetHashValue(entryPtr, hashPtr);
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ void UWPkt_Hash_Table::put_in_hash(hdr_uwvb * vbh, position* p)
+ {
+ 	Tcl_HashEntry *entryPtr;
+ 	// Pkt_Hash_Entry    *hashPtr;
+ 	vbf_neighborhood* hashPtr;
+ 	unsigned int key[3];
+ 	int newPtr;
+ 
+ 	key[0]=(vbh->sender_id).addr_;
+ 	key[1]=(vbh->sender_id).port_;
+ 	key[2]=vbh->pk_num;
+ 
+ 
+ 	int  k=key[2]-window_size;
+ 	if(k>0)
+ 	{
+ 		for (int i=0;i<k;i++){
+ 			key[2]=i;
+ 			entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+ 			if (entryPtr)
+ 			{
+ 				hashPtr=(vbf_neighborhood*)Tcl_GetHashValue(entryPtr);
+ 				delete hashPtr;
+ 				Tcl_DeleteHashEntry(entryPtr);
+ 			}
+ 
+ 		}       
+ 	}
+ 	key[2]=vbh->pk_num;
+ 	entryPtr = Tcl_CreateHashEntry(&htable, (char *)key, &newPtr);
+ 	if (!newPtr)
+ 	{
+ 
+ 		hashPtr=GetHash(vbh->sender_id,vbh->pk_num);
+ 		int m=hashPtr->number;
+ 		// printf("hash_table: this is not old item, there are %d item inside\n",m); 
+ 		if (m<MAX_NEIGHBOR){
+ 			hashPtr->number++;
+ 			hashPtr->neighbor[m].x=p->x;
+ 			hashPtr->neighbor[m].y=p->y;
+ 			hashPtr->neighbor[m].z=p->z;
+ 		}
+ 		return;
+ 	}
+ 	hashPtr=new vbf_neighborhood[1];
+ 	hashPtr[0].number=1;
+ 	hashPtr[0].neighbor[0].x=p->x;
+ 	hashPtr[0].neighbor[0].y=p->y;
+ 	hashPtr[0].neighbor[0].z=p->z;
+ 	Tcl_SetHashValue(entryPtr, hashPtr);
+ 
+ }
+ 
+ 
+ void UWData_Hash_Table::reset()
+ {
+ 	Tcl_HashEntry *entryPtr;
+ 	Tcl_HashSearch searchPtr;
+ 
+ 	entryPtr = Tcl_FirstHashEntry(&htable, &searchPtr);
+ 	while (entryPtr != NULL) {
+ 		Tcl_DeleteHashEntry(entryPtr);
+ 		entryPtr = Tcl_NextHashEntry(&searchPtr);
+ 	}
+ }
+ 
+ 
+ Tcl_HashEntry  *UWData_Hash_Table::GetHash(int *attr)
+ {
+ 	return Tcl_FindHashEntry(&htable, (char *)attr);
+ }
+ 
+ 
+ void UWData_Hash_Table::PutInHash(int *attr)
+ {
+ 	int newPtr;
+ 
+ 	Tcl_HashEntry* entryPtr=Tcl_CreateHashEntry(&htable, (char *)attr, &newPtr);
+ 
+ 	if (!newPtr)
+ 		return;
+ 
+ 	int *hashPtr=new int[1];
+ 	hashPtr[0]=1;
+ 	Tcl_SetHashValue(entryPtr, hashPtr);
+ 
+ }
+ 
+ 
+ void UWDelayTimer:: handle(Event* e)
+ {
+ 	a_->timeout((Packet*) e);
+ }
+ 
+ 
+ static class VectorbasedforwardClass : public TclClass {
+ public:
+ 	VectorbasedforwardClass() : TclClass("Agent/Vectorbasedforward") {}
+ 	TclObject* create(int argc, const char*const* argv) {
+ 		return(new VectorbasedforwardAgent());
+ 	}
+ } class_vectorbasedforward;
+ 
+ 
+ 
+ VectorbasedforwardAgent::VectorbasedforwardAgent() : Agent(PT_UWVB),
+ delaytimer(this)
+ {
+ 	// Initialize variables.
+ 	//  printf("VB initialized\n");
+ 	pk_count = 0;
+ 	target_ = 0;
+ 	node = NULL;
+ 	tracetarget = NULL;
+ 	width=0;
+ 	counter=0;
+ 	priority=1.5;
+ 	//useOverhear = 0;
+ 	EnableRouting = 1;
+ 	bind("hop_by_hop_", &hop_by_hop);
+ 	bind("EnableRouting", &EnableRouting);
+ 	bind("width",& width);
+ 	Random::seed_heuristically();
+ 	//bind("useOverhear_", &useOverhear);
+ 
+ }
+ 
+ 
+ void VectorbasedforwardAgent::recv(Packet* packet, Handler*)
+ {
+ 	hdr_uwvb* vbh = HDR_UWVB(packet);
+ 	unsigned char msg_type =vbh->mess_type;
+ 	unsigned int dtype = vbh->data_type;
+ 	double t1=vbh->ts_;
+ 	position * p1;
+ 
+ 	p1=new position[1];
+ 	p1[0].x=vbh->info.fx;
+ 	p1[0].y=vbh->info.fy;
+ 	p1[0].z=vbh->info.fz;    
+ 
+ 
+ 	if( !EnableRouting ) {
+ 		if( vbh->mess_type != DATA ) {
+ 			Packet::free(packet);
+ 			return;
+ 		}
+ 
+ 		if( vbh->sender_id.addr_ == here_.addr_ ) {
+ 			HDR_CMN(packet)->ptype() = PT_UWVB;
+ 			MACprepare(packet);
+ 			MACsend(packet, Random::uniform()*JITTER);		
+ 		}
+ 		else if( vbh->target_id.addr_ == here_.addr_ )  {
+ 			DataForSink(packet);
+ 		}
+ 		return;
+ 	}
+ 
+ 	vbf_neighborhood *hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 
+ 	// Received this packet before ?
+ 
+ 	if (hashPtr != NULL) {       
+ 		PktTable.put_in_hash(vbh,p1);
+ 		Packet::free(packet);
+ 		// printf("vectrobasedforward: this is duplicate packet\n"); 
+ 	}
+ 	else {
+ 
+ 		// Never receive it before ? Put in hash table.
+ 		//printf("vectrobasedforward: this is new packet\n");
+ 		PktTable.put_in_hash(vbh,p1);
+ 		ConsiderNew(packet);
+ 	}
+ 
+ 	delete p1;
+ }
+ 
+ void VectorbasedforwardAgent::ConsiderNew(Packet *pkt)
+ {
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	unsigned char msg_type =vbh->mess_type;
+ 	unsigned int dtype = vbh->data_type;
+ 	double l,h;
+ 
+ 	//Pkt_Hash_Entry *hashPtr;
+ 	vbf_neighborhood * hashPtr;
+ 	//  Agent_List *agentPtr;
+ 	// PrvCurPtr  RetVal;
+ 	ns_addr_t   from_nodeID, forward_nodeID, target_nodeID;
+ 
+ 	Packet *gen_pkt;
+ 	hdr_uwvb *gen_vbh;
+ 	position * p1;
+ 	p1=new position[1];
+ 	p1[0].x=vbh->info.fx;
+ 	p1[0].y=vbh->info.fy;
+ 	p1[0].z=vbh->info.fz;    
+ 
+ 	//if(((vbh->ts_>35.0)&&(vbh->ts_<=36))||((vbh->ts_>10.0)&&(vbh->ts_<11)))
+ 	// printf ("vectorbasedforward:(id :%d) forward:(%d ,%d) sender is(%d,%d,%d), (%f,%f,%f) the relative position is (%f ,%f,%f) forward position is is (%f,%f,%f) at time %f\n",here_.addr_, vbh->forward_agent_id.addr_, vbh->forward_agent_id.port_,vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num,node->X(),node->Y(),node->Z(),vbh->info.dx,vbh->info.dy,vbh->info.dz, vbh->info.fx,vbh->info.fy,vbh->info.fz,NOW);
+ 
+ 	//  printf ("vectorbasedforward:(id :%d) forward:(%d ,%d) sender is(%d,%d,%d),my position is  (%f,%f,%f)  at time %f\n",here_.addr_, vbh->forward_agent_id.addr_, vbh->forward_agent_id.port_,vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num,node->X(),node->Y(),node->Z(),NOW);
+ 
+ 
+ 	//  printf("Vectorbasedforward:oops!\n");
+ 	switch (msg_type) {
+ 	case INTEREST : 
+ 		// printf("Vectorbasedforward:it is interest packet!\n");
+ 		hashPtr = PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 
+ 		// Check if it comes from sink agent of this node
+ 		// If so we have to keep it in sink list 
+ 
+ 		from_nodeID = vbh->sender_id;
+ 		forward_nodeID = vbh->forward_agent_id;
+ 		//  printf("Vectorbasedforward:it the from_nodeid is %d %d  and theb this node id is %d ,%d!\n", from_nodeID.addr_,from_nodeID.port_,THIS_NODE.addr_,THIS_NODE.port_ );
+ 
+ 		if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 
+ 			MACprepare(pkt);
+ 			MACsend(pkt,Random::uniform()*JITTER); 
+ 			//  printf("vectorbasedforward: after MACprepare(pkt)\n");
+ 		}
+ 		else
+ 		{
+ 			calculatePosition(pkt);
+ 			//printf("vectorbasedforward: This packet is from different node\n");
+ 			if (IsTarget(pkt)) 
+ 			{ 
+ 				// If this node is target?
+ 				l=advance(pkt);
+ 
+ 				//  send_to_demux(pkt,0);
+ 				//  printf("vectorbasedforward:%d send out the source-discovery \n",here_.addr_);
+ 				vbh->mess_type=SOURCE_DISCOVERY;
+ 				set_delaytimer(pkt,l*JITTER);
+ 				// !!! need to re-think
+ 			}
+ 			else{ 
+ 				// calculatePosition(pkt);
+ 				// No the target forwared
+ 				l=advance(pkt);
+ 				h=projection(pkt);
+ 				if (IsCloseEnough(pkt)){
+ 					// printf("vectorbasedforward:%d I am close enough for the interest\n",here_.addr_);
+ 					MACprepare(pkt);
+ 					MACsend(pkt,Random::uniform()*JITTER);//!!!! need to re-think
+ 				}
+ 				else { 
+ 					//  printf("vectorbasedforward:%d I am not close enough for the interest  \n",here_.addr_);
+ 					Packet::free(pkt);}
+ 			}
+ 		}
+ 		// Packet::free(pkt); 
+ 		return;
+ 
+ 
+ 
+ 
+ 	case TARGET_DISCOVERY: 
+ 		// from other nodes hitted by the packet, it is supposed
+ 		// to be the one hop away from the sink 
+ 
+ 		// printf("Vectorbasedforward(%d,%d):it is target-discovery  packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);    
+ 		if (THIS_NODE.addr_==vbh->target_id.addr_) {
+ 			//printf("Vectorbasedforward(%d,??%d):it is target-discovery  packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);    
+ 			// ns_addr_t *hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 			// Received this packet before ?
+ 			// if (hashPtr == NULL) { 
+ 
+ 			calculatePosition(pkt);
+ 			DataForSink(pkt);
+ 			printf("Vectorbasedforward: %d is the target\n", here_.addr_);
+ 			// } //New data Process this data 
+ 			// 
+ 		} else  {Packet::free(pkt);}
+ 		return;
+ 
+ 	case SOURCE_DISCOVERY:
+ 		Packet::free(pkt); 
+ 		// other nodes already claim to be the source of this interest
+ 		//   SourceTable.put_in_hash(vbh);
+ 		return;
+ 
+ 
+ 	case DATA_READY :
+ 		//  printf("Vectorbasedforward(%d,%d):it is data ready packet(%d)! it target id is %d \n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_);    
+ 		from_nodeID = vbh->sender_id;
+ 		if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 			// come from the same node, broadcast it
+ 			MACprepare(pkt);
+ 			MACsend(pkt,Random::uniform()*JITTER); 
+ 			return;      
+ 		}
+ 		calculatePosition(pkt);
+ 		if (THIS_NODE.addr_==vbh->target_id.addr_)
+ 		{
+ 			printf("Vectorbasedforward: %d is the target\n", here_.addr_);
+ 			DataForSink(pkt); // process it
+ 		} 
+ 		else{
+ 			// printf("Vectorbasedforward: %d is the not  target\n", here_.addr_); 
+ 			MACprepare(pkt);
+ 			MACsend(pkt, Random::uniform()*JITTER);
+ 		}
+ 		return;
+ 
+ 		/*
+ 		case DATA_READY :
+ 
+ 		// put source_agent in source list of routing table   
+ 		agentPtr = new Agent_List;
+ 		AGT_ADDR(agentPtr) = vbh->sender_id;
+ 		agentPtr->next = routing_table[dtype].source;
+ 		routing_table[dtype].source = agentPtr;
+ 
+ 		// !! this part will be modified later
+ 		God::instance()->AddSource(dtype, (vbh->sender_id).addr_);
+ 
+ 		gen_pkt = prepare_message(dtype, vbh->sender_id, DATA_REQUEST);
+ 		gen_vbh = HDR_UWVB(gen_pkt);
+ 		//      gen_vbh->report_rate = ORIGINAL;
+ 		send_to_dmux(gen_pkt, 0);
+ 		Packet::free(pkt);
+ 		return;
+ 		*/
+ 
+ 	case DATA :
+ 		// printf("Vectorbasedforward(%d,%d):it is data packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);    
+ 		//  printf("Vectorbasedforward(%d):it is data packet(%d)\n",here_.addr_,vbh->pk_num);    
+ 		from_nodeID = vbh->sender_id;
+ 		if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 			// come from the same node, broadcast it
+ 			MACprepare(pkt);
+ 			MACsend(pkt,0); 
+ 			return;      
+ 		}
+ 		calculatePosition(pkt);
+ 		//  printf("vectorbasedforward: after MACprepare(pkt)\n");
+ 		l=advance(pkt);
+ 		h=projection(pkt);
+ 
+ 
+ 		if (THIS_NODE.addr_==vbh->target_id.addr_)
+ 		{
+ 			// printf("Vectorbasedforward: %d is the target\n", here_.addr_);
+ 			DataForSink(pkt); // process it
+ 		}
+ 
+ 		else{
+ 			//  printf("Vectorbasedforward: %d is the not  target\n", here_.addr_);
+ 			if (IsCloseEnough(pkt)){
+ 				double delay=calculateDelay(pkt,p1);
+ 				double d2=(UnderwaterChannel::Transmit_distance()-distance(pkt))/SPEED_OF_SOUND_IN_WATER;
+ 				//printf("Vectorbasedforward: I am  not  target delay is %f d2=%f distance=%f\n",(sqrt(delay)*DELAY+d2*2),d2,distance(pkt));
+ 				set_delaytimer(pkt,(sqrt(delay)*DELAY+d2*2));
+ 
+ 			}
+ 			else { Packet::free(pkt);   }
+ 		}
+ 		return;
+ 
+ 	default : 
+ 
+ 		Packet::free(pkt);        
+ 		break;
+ 	}
+ 	delete p1;
+ }
+ 
+ 
+ void VectorbasedforwardAgent::reset()
+ {
+ 	PktTable.reset();
+ 	/*
+ 	for (int i=0; i<MAX_DATA_TYPE; i++) {
+ 	routing_table[i].reset();
+ 	}
+ 	*/
+ }
+ 
+ 
+ void VectorbasedforwardAgent::Terminate() 
+ {
+ #ifdef DEBUG_OUTPUT
+ 	printf("node %d: remaining energy %f, initial energy %f\n", THIS_NODE, 
+ 		node->energy_model()->energy(), 
+ 		node->energy_model()->initialenergy() );
+ #endif
+ }
+ 
+ 
+ void VectorbasedforwardAgent::StopSource()
+ {
+ 	/*
+ 	Agent_List *cur;
+ 
+ 	for (int i=0; i<MAX_DATA_TYPE; i++) {
+ 	for (cur=routing_table[i].source; cur!=NULL; cur=AGENT_NEXT(cur) ) {
+ 	SEND_MESSAGE(i, AGT_ADDR(cur), DATA_STOP);
+ 	}
+ 	}
+ 	*/
+ }
+ 
+ 
+ Packet * VectorbasedforwardAgent:: create_packet()
+ {
+ 	Packet *pkt = allocpkt();
+ 
+ 	if (pkt==NULL) return NULL;
+ 
+ 	hdr_cmn*  cmh = HDR_CMN(pkt);
+ 	cmh->size() = 36;
+ 
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	vbh->ts_ = NOW;
+ 
+ 	//!! I add new part
+ 
+ 	vbh->info.ox=node->CX();
+ 	vbh->info.oy=node->CY(); 
+ 	vbh->info.oz=node->CZ(); 
+ 	vbh->info.fx=node->CX(); 
+ 	vbh->info.fy=node->CY();
+ 	vbh->info.fz=node->CZ();
+ 
+ 
+ 
+ 	return pkt;
+ }
+ 
+ 
+ Packet *VectorbasedforwardAgent::prepare_message(unsigned int dtype, ns_addr_t to_addr,  int msg_type)
+ 
+ {
+ 	Packet *pkt;
+ 	hdr_uwvb *vbh;
+ 	//hdr_ip *iph;
+ 
+ 	pkt = create_packet();
+ 	vbh = HDR_UWVB(pkt);
+ 	// iph = HDR_IP(pkt);
+ 
+ 	vbh->mess_type = msg_type;
+ 	vbh->pk_num = pk_count;
+ 	pk_count++;
+ 	vbh->sender_id = here_;
+ 	vbh->data_type = dtype;
+ 	vbh->forward_agent_id = here_;
+ 
+ 	vbh->ts_ = NOW;
+ 	//    vbh->num_next = 1;
+ 	// I am not sure if we need this
+ 	// vbh->next_nodes[0] = to_addr.addr_;
+ 
+ 
+ 	// I am not sure if we need it?    
+ 	/*
+ 	iph->src_ = here_;
+ 	iph->dst_ = to_addr;
+ 	*/
+ 	return pkt;
+ }
+ 
+ void VectorbasedforwardAgent::MACprepare(Packet *pkt)
+ {
+ 
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	hdr_cmn* cmh = HDR_CMN(pkt);
+ 	//  hdr_ip*  iph = HDR_IP(pkt); // I am not sure if we need it
+ 
+ 
+ 	vbh->forward_agent_id = here_; 
+ 
+ 	cmh->xmit_failure_ = 0;
+ 	// printf("vectorbased: the mac_Broadcast is:%d\n",MAC_BROADCAST);
+ 	cmh->next_hop() = MAC_BROADCAST; 
+ 	cmh->addr_type() = NS_AF_ILINK;  
+ 	// cmh->txtime()=0;
+ 	// printf("vectorbased: the address type is :%d and suppose to be %d and  nexthop %d MAC_BROAD %d\n", cmh->addr_type(),NS_AF_ILINK,cmh->next_hop(),MAC_BROADCAST);
+ 	cmh->direction() = hdr_cmn::DOWN;
+ 	// cmh->ptype_==PT_UWVB;
+ 	// printf("vectorbased: the packet type is :%d\n", cmh->ptype_);
+ 	//  printf("ok\n");
+ 
+ 	//if (node) printf("ok, node is not empty\n");
+ 	//printf("vectorbasedforward: inside MACprepare%d %d %d \n",node->X(),node->Y(),node->Z());
+ 
+ 
+ 	// iph->src_ = here_;
+ 	//iph->dst_.addr_ = MAC_BROADCAST;
+ 	//iph->dst_.port_ = ROUTING_PORT;
+ 
+ 	//  vbh->num_next = 1;
+ 	// vbh->next_nodes[0] = MAC_BROADCAST;
+ 
+ 
+ 	if(!node->sinkStatus()){       //!! I add new part
+ 		vbh->info.fx=node->CX();
+ 		vbh->info.fy=node->CY();
+ 		vbh->info.fz=node->CZ();
+ 	}
+ 	else{
+ 		vbh->info.fx=node->X();
+ 		vbh->info.fy=node->Y();
+ 		vbh->info.fz=node->Z();
+ 	}
+ 
+ 	// printf("vectorbasedforward: last line MACprepare\n");
+ }
+ 
+ 
+ void VectorbasedforwardAgent::MACsend(Packet *pkt, Time delay)
+ {
+ 	hdr_cmn*  cmh = HDR_CMN(pkt);
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 
+ 	// I don't understand why it works like this way
+ 	/*
+ 	if (vbh->mess_type == DATA)
+ 	cmh->size() = (God::instance()->data_pkt_size) + 4*(vbh->num_next - 1);
+ 	else
+ 	cmh->size() = 36 + 4*(vbh->num_next -1);
+ 	*/
+ 
+ 
+ 	/*
+ 	if (vbh->mess_type == DATA)
+ 	// cmh->size() = (God::instance()->data_pkt_size)+12 ;
+ 	cmh->size() = 65+12 ;
+ 	else
+ 	cmh->size() =32;
+ 	*/
+ 
+ 
+ 
+ 
+ 	//if(!ll) printf("ok, the LL is empty\n");
+ 	//cmh->ptype_==PT_UWVB;
+ 	//printf("vectorbased: the address type is :%d uid is %d\n", cmh->addr_type(),pkt->uid_);
+ 	//printf("vectorbased: the packet type is :%d\n", cmh->ptype_);
+ 	// ll->handle(pkt);
+ 	Scheduler::instance().schedule(ll, pkt, delay);
+ }
+ 
+ 
+ void VectorbasedforwardAgent::DataForSink(Packet *pkt)
+ {
+ 	send_to_dmux(pkt, 0);
+ }
+ 
+ 
+ 
+ void VectorbasedforwardAgent::trace (char *fmt,...)
+ {
+ 	va_list ap;
+ 
+ 	if (!tracetarget)
+ 		return;
+ 
+ 	va_start (ap, fmt);
+ 	vsprintf (tracetarget->pt_->buffer(), fmt, ap);
+ 	tracetarget->pt_->dump ();
+ 	va_end (ap);
+ }
+ 
+ void VectorbasedforwardAgent::set_delaytimer(Packet* pkt, double c){
+ 	// delaytimer.packet=pkt; 
+ 	//delaytimer.resched(c);
+ 	Scheduler& s=Scheduler::instance();
+ 	s.schedule(&delaytimer,(Event*)pkt,c);
+ 	return;
+ }
+ 
+ void VectorbasedforwardAgent::timeout(Packet * pkt){
+ 
+ 	hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 	unsigned char msg_type =vbh->mess_type;
+ 	vbf_neighborhood  *hashPtr;
+ 	//Packet* p1;
+ 
+ 
+ 
+ 	switch (msg_type){
+ 
+  case DATA:
+ 	 hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 	 if (hashPtr != NULL) {
+ 		 int num_neighbor=hashPtr->number;
+ 		 // printf("vectorbasedforward: node %d have received %d when wake up at %f\n",here_.addr_,num_neighbor,NOW);
+ 		 if (num_neighbor!=1){
+ 
+ 			 /*AlohaOverhear can guarantee that the packet be successfully deliveried to next hop,
+ 			 * so we release the pkt if overhearing other neighbors send this pkt. 
+ 			 */
+ 			/* if( useOverhear )
+ 			 {
+ 				 Packet::free(pkt);
+ 				 return;
+ 			 }*/
+ 
+ 			 // Some guys transmit the data before me
+ 			 if (num_neighbor==MAX_NEIGHBOR) {
+ 				 //I have too many neighbors, I quit
+ 				 Packet::free(pkt);
+ 				 return;  
+ 			 }
+ 			 else //I need to calculate my delay time again 
+ 			 {  
+ 				 int i=0;
+ 				 position* tp;
+ 				 tp=new position[1];
+ 
+ 				 tp[0].x=hashPtr->neighbor[i].x;   
+ 				 tp[0].y=hashPtr->neighbor[i].y;   
+ 				 tp[0].z=hashPtr->neighbor[i].z; 
+ 				 double tdelay=calculateDelay(pkt,tp);
+ 				 // double tdelay=5;
+ 				 i++;
+ 				 double c=1;
+ 				 while (i<num_neighbor){
+ 					 c=c*2;
+ 					 tp[0].x=hashPtr->neighbor[i].x;   
+ 					 tp[0].y=hashPtr->neighbor[i].y;   
+ 					 tp[0].z=hashPtr->neighbor[i].z;   
+ 					 double t2delay=calculateDelay(pkt,tp);
+ 					 if (t2delay<tdelay)
+ 						 tdelay=t2delay;
+ 					 i++; 
+ 				 }
+ 
+ 				 delete tp;
+ 				 if(tdelay<=(priority/c)) { 
+ 					 MACprepare(pkt);
+ 					 MACsend(pkt,0);      
+ 				 }
+ 				 else
+ 					 Packet::free(pkt);//to much overlap, don;t send 
+ 			 }// end of calculate my new delay time 
+ 		 }
+ 		 else{// I am the only neighbor
+ 			 position* tp;
+ 			 tp=new position[1];
+ 			 tp[0].x=vbh->info.fx;   
+ 			 tp[0].y=vbh->info.fy;   
+ 			 tp[0].z=vbh->info.fz;   
+ 			 double delay=calculateDelay(pkt,tp);
+ 
+ 			 delete tp;
+ 			 if (delay<=priority){
+ 				 // printf("vectorbasedforward: !!%f\n",delay);
+ 				 MACprepare(pkt);
+ 				 MACsend(pkt,0);      
+ 			 }
+ 			 else  Packet::free(pkt);     
+ 			 // printf("vectorbasedforward:  I%d am the only neighbor, I send it out at %f\n",here_.addr_,NOW);
+ 			 return;
+ 		 }
+ 	 }
+ 	 break; 
+  default:
+ 	 Packet::free(pkt);  
+ 	 break;
+ 	}
+ }
+ 
+ 
+ 
+ void VectorbasedforwardAgent::calculatePosition(Packet* pkt)
+ {
+ 
+ 	hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+ 	double fx=vbh->info.fx;
+ 	double fy=vbh->info.fy;
+ 	double fz=vbh->info.fz;
+ 
+ 	double dx=vbh->info.dx;
+ 	double dy=vbh->info.dy;
+ 	double dz=vbh->info.dz;
+ 
+ 	node->CX_=fx+dx;
+ 	node->CY_=fy+dy;
+ 	node->CZ_=fz+dz;
+ 	// printf("vectorbased: my position is computed as (%f,%f,%f)\n",node->CX_, node->CY_,node->CZ_);
+ }
+ 
+ double VectorbasedforwardAgent::calculateDelay(Packet* pkt,position* p1)
+ {
+ 
+ 	hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+ 	double fx=p1->x;
+ 	double fy=p1->y;
+ 	double fz=p1->z;
+ 
+ 	double dx=node->CX_-fx; 
+ 	double dy=node->CY_-fy;
+ 	double dz=node->CZ_-fz;
+ 
+ 
+ 	double tx=vbh->info.tx;
+ 	double ty=vbh->info.ty;
+ 	double tz=vbh->info.tz; 
+ 
+ 	double dtx=tx-fx;
+ 	double dty=ty-fy;
+ 	double dtz=tz-fz;  
+ 
+ 	double dp=dx*dtx+dy*dty+dz*dtz;
+ 
+ 	// double a=advance(pkt);
+ 	double p=projection(pkt);
+ 	double d=sqrt((dx*dx)+(dy*dy)+ (dz*dz));
+ 	double l=sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+ 	double cos_theta=dp/(d*l);
+ 	// double delay=(TRANSMISSION_DISTANCE-d*cos_theta)/TRANSMISSION_DISTANCE;
+ 	double delay=(p/width) +((UnderwaterChannel::Transmit_distance()-d*cos_theta)/UnderwaterChannel::Transmit_distance());
+ 	// double delay=(p/width) +((TRANSMISSION_DISTANCE-d)/TRANSMISSION_DISTANCE)+(1-cos_theta);
+ 	//printf("vectorbased: node(%d) projection is %f, and cos is %f, and d is %f)\n",here_.addr_,p, cos_theta, d);
+ 	return delay;
+ }
+ 
+ 
+ double VectorbasedforwardAgent::distance(Packet* pkt)
+ {
+ 
+ 	hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+ 	double tx=vbh->info.fx;
+ 	double ty=vbh->info.fy;
+ 	double tz=vbh->info.fz;
+ 	// printf("vectorbased: the target is %lf,%lf,%lf \n",tx,ty,tz);
+ 	double x=node->CX(); //change later
+ 	double y=node->CY();// printf(" Vectorbasedforward: I am in advanced\n");
+ 	double z=node->CZ();
+ 	// printf("the target is %lf,%lf,%lf and my coordinates are %lf,%lf,%lf\n",tx,ty,tz,x,y,z);
+ 	return sqrt((tx-x)*(tx-x)+(ty-y)*(ty-y)+ (tz-z)*(tz-z));
+ }
+ 
+ 
+ double VectorbasedforwardAgent::advance(Packet* pkt)
+ {
+ 
+ 	hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+ 	double tx=vbh->info.tx;
+ 	double ty=vbh->info.ty;
+ 	double tz=vbh->info.tz;
+ 	// printf("vectorbased: the target is %lf,%lf,%lf \n",tx,ty,tz);
+ 	double x=node->CX(); //change later
+ 	double y=node->CY();// printf(" Vectorbasedforward: I am in advanced\n");
+ 	double z=node->CZ();
+ 	// printf("the target is %lf,%lf,%lf and my coordinates are %lf,%lf,%lf\n",tx,ty,tz,x,y,z);
+ 	return sqrt((tx-x)*(tx-x)+(ty-y)*(ty-y)+ (tz-z)*(tz-z));
+ }
+ 
+ double VectorbasedforwardAgent::projection(Packet* pkt)
+ {
+ 	hdr_uwvb *vbh  = HDR_UWVB(pkt);
+ 
+ 	double tx=vbh->info.tx;
+ 	double ty=vbh->info.ty;
+ 	double tz=vbh->info.tz;
+ 
+ 	double ox, oy, oz;
+ 
+ 	if( !hop_by_hop )
+ 	{
+ 		//printf("vbf is used\n");
+ 		ox=vbh->info.ox;
+ 		oy=vbh->info.oy;
+ 		oz=vbh->info.oz;
+ 	}
+ 	else{
+ 		//printf("hop_by_hop vbf is used\n");
+ 		ox=vbh->info.fx;
+ 		oy=vbh->info.fy;
+ 		oz=vbh->info.fz;
+ 	}
+ 
+ 	double x=node->CX();
+ 	double y=node->CY();
+ 	double z=node->CZ();
+ 
+ 	double wx=tx-ox;
+ 	double wy=ty-oy;
+ 	double wz=tz-oz;
+ 
+ 	double vx=x-ox;
+ 	double vy=y-oy;
+ 	double vz=z-oz;
+ 
+ 	double cross_product_x=vy*wz-vz*wy;
+ 	double cross_product_y=vz*wx-vx*wz;
+ 	double cross_product_z=vx*wy-vy*wx;
+ 
+ 	double area=sqrt(cross_product_x*cross_product_x+ 
+ 		cross_product_y*cross_product_y+cross_product_z*cross_product_z);
+ 	double length=sqrt((tx-ox)*(tx-ox)+(ty-oy)*(ty-oy)+ (tz-oz)*(tz-oz));
+ 	// printf("vectorbasedforward: the area is %f and length is %f\n",area,length);
+ 	return area/length;
+ }
+ 
+ bool VectorbasedforwardAgent::IsTarget(Packet* pkt)
+ {
+ 	hdr_uwvb * vbh=HDR_UWVB(pkt);
+ 
+ 	if (vbh->target_id.addr_==0){
+ 
+ 		//  printf("vectorbased: advanced is %lf and my range is %f\n",advance(pkt),vbh->range);
+ 		return (advance(pkt)<vbh->range);
+ 	}
+ 	else return(THIS_NODE.addr_==vbh->target_id.addr_);
+ 
+ 
+ }
+ 
+ 
+ 
+ bool VectorbasedforwardAgent::IsCloseEnough(Packet* pkt)
+ {
+ 	hdr_uwvb     *vbh  = HDR_UWVB(pkt);
+ 	double range=vbh->range;
+ 	//double range=width;
+ 
+ 	//  printf("underwatersensor: The width is %f\n",range);
+ 	double ox=vbh->info.ox;
+ 	double oy=vbh->info.oy;
+ 	double oz=vbh->info.oz;
+ 
+ 	double tx=vbh->info.tx;
+ 	double ty=vbh->info.ty;
+ 	double tz=vbh->info.tz;
+ 
+ 	double fx=vbh->info.fx;
+ 	double fy=vbh->info.fy;
+ 	double fz=vbh->info.fz;
+ 
+ 
+ 	double x=node->CX(); //change later
+ 	double y=node->CY();
+ 	double z=node->CZ();
+ 
+ 	double d=sqrt((tx-fx)*(tx-fx)+(ty-fy)*(ty-fy)+(tz-fz)*(tz-fz));
+ 	//double l=sqrt((tx-ox)*(tx-ox)+(ty-oy)*(ty-oy)+ (tz-oz)*(tz-oz));
+ 	double l=advance(pkt);
+ 	// if (l<range)
+ 	// {
+ 	// printf("vectorbasedforward: IsClose?too close! it should be target!\n");
+ 	// return true;
+ 	// }
+ 	// else {
+ 	//double c=d/l;
+ 	double c=1;
+ 	// if ((d<=range)&&((z-oz)<0.01))  return true;
+ 	if ((projection(pkt)<=(c*width)))  return true;
+ 	return false;
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ int VectorbasedforwardAgent::command(int argc, const char*const* argv)
+ {  
+ 	Tcl& tcl =  Tcl::instance();
+ 
+ 	if (argc == 2) {
+ 
+ 		if (strcasecmp(argv[1], "reset-state")==0) {
+ 
+ 			reset();
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "reset")==0) {
+ 
+ 			return Agent::command(argc, argv);
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "start")==0) {
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "stop")==0) {
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "terminate")==0) {
+ 			Terminate();
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "name")==0) {
+ 			printf("vectorbased \n");
+ 			return TCL_OK;
+ 		}
+ 		if (strcasecmp(argv[1], "stop-source")==0) {
+ 			StopSource();
+ 			return TCL_OK;
+ 		}
+ 
+ 	} else if (argc == 3) {
+ 
+ 		if (strcasecmp(argv[1], "on-node")==0) {
+ 			//   printf ("inside on node\n");
+ 			node = (UnderwaterSensorNode *)tcl.lookup(argv[2]);
+ 			return TCL_OK;
+ 		}
+ 		/*
+ 		if (strcasecmp(argv[1], "set-port")==0) {
+ 		printf ("inside on node\n");
+ 		port_number=atoi(argv[2]);
+ 		return TCL_OK;
+ 		}
+ 		*/
+ 		if (strcasecmp(argv[1], "add-ll") == 0) {
+ 
+ 			TclObject *obj;
+ 
+ 			if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 				fprintf(stderr, "Vectorbasedforwarding Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			ll = (NsObject *) obj;
+ 
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp (argv[1], "tracetarget") == 0) {
+ 			TclObject *obj;
+ 			if ((obj = TclObject::lookup (argv[2])) == 0) {
+ 				fprintf (stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1],
+ 					argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 
+ 			tracetarget = (Trace *) obj;
+ 			return TCL_OK;
+ 		}
+ 
+ 		if (strcasecmp(argv[1], "port-dmux") == 0) {
+ 			// printf("vectorbasedforward:port demux is called \n");
+ 			TclObject *obj;
+ 
+ 			if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 				fprintf(stderr, "VB node Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 				return TCL_ERROR;
+ 			}
+ 			port_dmux = (NsObject *) obj;
+ 			return TCL_OK;
+ 		}
+ 
+ 	} 
+ 
+ 	return Agent::command(argc, argv);
+ }
+ 
+ 
+ // Some methods for Flooding Entry
+ 
+ /*
+ void Vectorbasedforward_Entry::reset()
+ {
+ clear_agentlist(source);
+ clear_agentlist(sink);
+ source = NULL;
+ sink = NULL;
+ }
+ 
+ void Vectorbasedforward_Entry::clear_agentlist(Agent_List *list)
+ {
+ Agent_List *cur=list;
+ Agent_List *temp = NULL;
+ 
+ while (cur != NULL) {
+ temp = AGENT_NEXT(cur);
+ delete cur;
+ cur = temp;
+ }
+ }
+ 
+ */
diff -crBN ns-2.35/underwatersensor/uw_routing/vectorbasedforward.h ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward.h
*** ns-2.35/underwatersensor/uw_routing/vectorbasedforward.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,185 ----
+ #ifndef ns_vectorbasedforward_h
+ #define ns_vectorbasedforward_h
+ 
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ //#include "underwatersensor/uw_common/uw_hash_table.h"
+ #include "arp.h"
+ #include "mac.h"
+ #include "ll.h"
+ #include "dsr/path.h"
+ #include "uw_datastructure.h"
+ 
+ 
+ 
+ struct vbf_neighborhood{
+   int number;
+   position neighbor[MAX_NEIGHBOR];
+ };
+ 
+ struct hdr_uwvb{
+ 	unsigned int mess_type;
+ 	unsigned int pk_num;
+         ns_addr_t target_id; // the target id  of this data 
+         ns_addr_t sender_id;  //original sender id
+   // nsaddr_t next_nodes[MAX_NEIGHBORS];
+   //int      num_next;
+         unsigned int data_type;
+         ns_addr_t forward_agent_id;// the forwarder id
+ 
+        position original_source;
+        struct uw_extra_info info;
+         
+          double token;
+   	double ts_;                       // Timestamp when pkt is generated.
+       double range;    // target range
+   //    int    report_rate;               // For simple diffusion only.
+   //	int    attr[MAX_ATTRIBUTE];
+ 	
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_uwvb* access(const Packet*  p) {
+ 		return (hdr_uwvb*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ 
+ 
+ 
+ class UWPkt_Hash_Table {
+  public:
+   Tcl_HashTable htable;
+ 
+   UWPkt_Hash_Table() {
+     window_size=WINDOW_SIZE;
+     //  lower_counter=0;
+ // 50 items in the hash table, however, because it begins by 0, so, minus 1
+     Tcl_InitHashTable(&htable, 3);
+   }
+ 
+   int  window_size;
+   void reset();
+   void put_in_hash(hdr_uwvb *);
+   void put_in_hash(hdr_uwvb *, position *);
+   vbf_neighborhood* GetHash(ns_addr_t sender_id, unsigned int pkt_num);
+   //private:
+   //int lower_counter;
+ };
+ 
+ 
+ class UWData_Hash_Table {
+  public:
+   Tcl_HashTable htable;
+ 
+   UWData_Hash_Table() {
+     Tcl_InitHashTable(&htable, MAX_ATTRIBUTE);
+   }
+ 
+   void reset();
+   void PutInHash(int *attr);
+   Tcl_HashEntry  *GetHash(int *attr);
+ };
+ 
+ 
+ 
+ class VectorbasedforwardAgent;
+ 
+ class UWDelayTimer: public Handler{
+ public:
+ UWDelayTimer(VectorbasedforwardAgent * a):Handler(){a_=a;}
+  void handle(Event* e);
+ protected :
+   VectorbasedforwardAgent * a_;
+   
+ };
+ 
+ 
+ class VectorbasedforwardAgent : public Agent {
+  public:
+   VectorbasedforwardAgent();
+   int command(int argc, const char*const* argv);
+   void recv(Packet*, Handler*);
+ 
+   // Vectorbasedforward_Entry routing_table[MAX_DATA_TYPE];
+ 
+  protected:
+   int pk_count;
+   int counter;
+   int hop_by_hop;
+   int EnableRouting;   //if true, VBF can perform routing functionality. Otherwise, not perform
+   //int useOverhear;
+   double priority;
+   bool measureStatus;
+   // int port_number;
+   UWPkt_Hash_Table PktTable;
+   UWPkt_Hash_Table SourceTable;
+   UWPkt_Hash_Table Target_discoveryTable;
+   UWPkt_Hash_Table SinkTable;
+   UWDelayTimer delaytimer; 
+   
+ 
+   
+   UnderwaterSensorNode *node;
+   Trace *tracetarget;       // Trace Target
+   NsObject *ll;  
+   NsObject *port_dmux;
+   double width; 
+ // the width is used to test if the node is close enough to the path specified by the packet  
+   
+ 
+    inline void send_to_dmux(Packet *pkt, Handler *h) { 
+     port_dmux->recv(pkt, h); 
+   }
+ 
+   void Terminate();
+   void reset();
+   void ConsiderNew(Packet *pkt);
+   void set_delaytimer(Packet*,double);
+   void timeout(Packet*);
+   double advance(Packet *);
+   double distance(Packet *);
+   double projection(Packet*);
+   double calculateDelay(Packet*, position*);
+   //double recoveryDelay(Packet*, position*);
+   void calculatePosition(Packet*);
+    void setMeasureTimer(Packet*,double);
+   bool IsTarget(Packet*);
+   bool IsCloseEnough(Packet*);
+  
+  
+   Packet *create_packet();
+   Packet *prepare_message(unsigned int dtype, ns_addr_t to_addr, int msg_type);
+ 
+   
+   void DataForSink(Packet *pkt);
+   void StopSource();
+   void MACprepare(Packet *pkt);
+   void MACsend(Packet *pkt, Time delay=0);
+ 
+   void trace(char *fmt,...);
+   friend class UWDelayTimer;
+ };
+ 
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.cc ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.cc
*** ns-2.35/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,1117 ----
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ #include "underwatersensor/uw_mac/underwaterchannel.h"
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "ip.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "node.h"
+ #include "vectorbasedforward_hop_by_hop.h"
+ #include "arp.h"
+ #include "mac.h"
+ #include "ll.h"
+ #include "dsr/path.h"
+ #include "god.h"
+ #include  "underwatersensor/uw_mac/underwaterpropagation.h"
+ 
+ #define EXP  1e6
+ #define INF  1e9
+ 
+ int hdr_uwvb::offset_;
+ 
+ 
+ static class UWVBHeaderClass: public PacketHeaderClass{
+  public:
+   UWVBHeaderClass():PacketHeaderClass("PacketHeader/UWVB",sizeof(hdr_uwvb))
+ {
+  bind_offset(&hdr_uwvb::offset_);
+ } 
+ } class_uwvbhdr;
+ 
+ 
+ 
+ 
+ void UWPkt_Hash_Table::reset()
+ {
+   neighborhood *hashPtr;
+   Tcl_HashEntry *entryPtr;
+   Tcl_HashSearch searchPtr;
+ 
+   entryPtr = Tcl_FirstHashEntry(&htable, &searchPtr);
+   while (entryPtr != NULL) {
+     hashPtr = (neighborhood *)Tcl_GetHashValue(entryPtr);
+      delete hashPtr;
+     Tcl_DeleteHashEntry(entryPtr);
+     entryPtr = Tcl_NextHashEntry(&searchPtr);
+   }
+ }
+ 
+ 
+ 
+ neighborhood* UWPkt_Hash_Table::GetHash(ns_addr_t sender_id, 
+ 					unsigned int pk_num)
+ {
+   unsigned int key[3];
+ 
+   key[0] = sender_id.addr_;
+   key[1] = sender_id.port_;
+   key[2] = pk_num;
+ 
+   Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(&htable, (char *)key);
+ 
+   if (entryPtr == NULL )
+      return NULL;
+ 
+   return (neighborhood *)Tcl_GetHashValue(entryPtr);
+ }
+ 
+ 
+ 
+ void UWPkt_Hash_Table::put_in_hash(hdr_uwvb * vbh)
+ {
+     Tcl_HashEntry *entryPtr;
+     // Pkt_Hash_Entry    *hashPtr;
+     neighborhood* hashPtr;
+     unsigned int key[3];
+     int newPtr;
+ 
+     key[0]=(vbh->sender_id).addr_;
+     key[1]=(vbh->sender_id).port_;
+     key[2]=vbh->pk_num;
+ 
+ 
+      int  k=key[2]-window_size;
+     if(k>0)
+       {
+       for (int i=0;i<k;i++)
+ 	{
+           key[2]=i;
+        entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+       if (entryPtr)
+      {
+ 	hashPtr=(neighborhood*)Tcl_GetHashValue(entryPtr);
+ 	delete hashPtr;
+ 	Tcl_DeleteHashEntry(entryPtr);
+       }
+ 	}
+       }     
+      
+   key[2]=vbh->pk_num;
+     entryPtr = Tcl_CreateHashEntry(&htable, (char *)key, &newPtr);
+     if (!newPtr){
+      hashPtr=GetHash(vbh->sender_id,vbh->pk_num);
+     int m=hashPtr->number;
+     if (m<MAX_NEIGHBOR){
+         hashPtr->number++;
+ 	hashPtr->neighbor[m].x=0;
+         hashPtr->neighbor[m].y=0;
+ 	hashPtr->neighbor[m].z=0;
+     }
+       return;
+ }
+     hashPtr=new neighborhood[1];
+     hashPtr[0].number=1;
+     hashPtr[0].neighbor[0].x=0;
+     hashPtr[0].neighbor[0].y=0;
+     hashPtr[0].neighbor[0].z=0;
+     Tcl_SetHashValue(entryPtr, hashPtr);
+    
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ void UWPkt_Hash_Table::put_in_hash(hdr_uwvb * vbh, position* p)
+ {
+     Tcl_HashEntry *entryPtr;
+     // Pkt_Hash_Entry    *hashPtr;
+     neighborhood* hashPtr;
+     unsigned int key[3];
+     int newPtr;
+ 
+     key[0]=(vbh->sender_id).addr_;
+     key[1]=(vbh->sender_id).port_;
+     key[2]=vbh->pk_num;
+ 
+ 
+      int  k=key[2]-window_size;
+     if(k>0)
+       {
+ 	for (int i=0;i<k;i++){
+ 	  key[2]=i;
+        entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+       if (entryPtr)
+      {
+ 	hashPtr=(neighborhood*)Tcl_GetHashValue(entryPtr);
+ 	delete hashPtr;
+ 	Tcl_DeleteHashEntry(entryPtr);
+       }
+ 
+       }       
+       }
+        key[2]=vbh->pk_num;
+     entryPtr = Tcl_CreateHashEntry(&htable, (char *)key, &newPtr);
+     if (!newPtr)
+ {
+ 
+      hashPtr=GetHash(vbh->sender_id,vbh->pk_num);
+     int m=hashPtr->number;
+     // printf("hash_table: this is not old item, there are %d item inside\n",m); 
+     if (m<MAX_NEIGHBOR){
+         hashPtr->number++;
+ 	hashPtr->neighbor[m].x=p->x;
+         hashPtr->neighbor[m].y=p->y;
+ 	hashPtr->neighbor[m].z=p->z;
+     }
+         return;
+ }
+     hashPtr=new neighborhood[1];
+     hashPtr[0].number=1;
+     hashPtr[0].neighbor[0].x=p->x;
+     hashPtr[0].neighbor[0].y=p->y;
+     hashPtr[0].neighbor[0].z=p->z;
+     Tcl_SetHashValue(entryPtr, hashPtr);
+    
+ }
+ 
+ 
+ void UWData_Hash_Table::reset()
+ {
+   Tcl_HashEntry *entryPtr;
+   Tcl_HashSearch searchPtr;
+ 
+   entryPtr = Tcl_FirstHashEntry(&htable, &searchPtr);
+   while (entryPtr != NULL) {
+     Tcl_DeleteHashEntry(entryPtr);
+     entryPtr = Tcl_NextHashEntry(&searchPtr);
+   }
+ }
+ 
+ 
+ Tcl_HashEntry  *UWData_Hash_Table::GetHash(int *attr)
+ {
+   return Tcl_FindHashEntry(&htable, (char *)attr);
+ }
+ 
+ 
+ void UWData_Hash_Table::PutInHash(int *attr)
+ {
+     int newPtr;
+ 
+      Tcl_HashEntry* entryPtr=Tcl_CreateHashEntry(&htable, (char *)attr, &newPtr);
+ 
+     if (!newPtr)
+       return;
+  
+     int *hashPtr=new int[1];
+     hashPtr[0]=1;
+     Tcl_SetHashValue(entryPtr, hashPtr);
+ 
+ }
+ 
+ void UWDelayTimer:: expire(Event* e)
+ {
+   a_->timeout(packet);
+ }
+ 
+ 
+ static class VectorbasedforwardClass : public TclClass {
+ public:
+   VectorbasedforwardClass() : TclClass("Agent/Vectorbasedforward") {}
+   TclObject* create(int argc, const char*const* argv) {
+     return(new VectorbasedforwardAgent());
+   }
+ } class_vectorbasedforward;
+ 
+ 
+ 
+ VectorbasedforwardAgent::VectorbasedforwardAgent() : Agent(PT_UWVB),
+ delaytimer(this)
+ {
+   // Initialize variables.
+   
+   pk_count = 0;
+   target_ = 0;
+    node = NULL;
+   tracetarget = NULL;
+   // width=0;
+   counter=0;
+   priority=1.5;
+  
+  // forwarder_based=true;
+  bind("hop_by_hop_", &forwarder_based);
+  bind("width",& width);
+  minProjection=width/4; 
+ //  printf("VB initialized and minProjection is %f\n",minProjection);
+ }
+ 
+ 
+ void VectorbasedforwardAgent::recv(Packet* packet, Handler*)
+ {
+    
+   hdr_cmn *hdr = HDR_CMN(packet);
+   
+   if(1==hdr->error()){
+ printf ("vectorbasedforward: I( %d ) received a  corrupted packet !!!!\n ",here_.addr_);
+    Packet::free(packet);
+   return;
+   }
+    
+ 
+   if (node->failure_status()==1){
+      
+   printf ("vectorbasedforward: I( %d ) failed, I can't receive a packet !!!!\n ",here_.addr_);
+   return;
+   }
+   
+  
+   
+   hdr_uwvb* vbh = HDR_UWVB(packet);
+   unsigned char msg_type =vbh->mess_type;
+   unsigned int dtype = vbh->data_type;
+   double t1=vbh->ts_;
+   position * p1;
+  
+   p1=new position[1];
+   p1[0].x=vbh->info.fx;
+   p1[0].y=vbh->info.fy;
+   p1[0].z=vbh->info.fz;    
+ 
+ 
+     neighborhood *hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+     //printf("vectrobasedforward node %d: recv  packet %d from the sender %d\n",here_.addr_,vbh->pk_num,vbh->sender_id.addr_); 
+      // Received this packet before ?
+ 
+     if (hashPtr) {       
+       PktTable.put_in_hash(vbh,p1);
+     
+       printf("vectrobasedforward node %d: this is duplicate packet %d from the sender %d\n",here_.addr_,vbh->pk_num,vbh->sender_id.addr_); 
+         Packet::free(packet);
+                       }
+       else {
+  
+      PktTable.put_in_hash(vbh,p1);
+  
+      // Take action for a new pkt.
+       
+      ConsiderNew(packet);     
+       }
+     delete p1;
+ }
+ 
+ void VectorbasedforwardAgent::ConsiderNew(Packet *pkt)
+ {
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+   unsigned char msg_type =vbh->mess_type;
+   unsigned int dtype = vbh->data_type; 
+  
+   double l,h;
+   
+  
+    neighborhood * hashPtr;
+    ns_addr_t   from_nodeID, forward_nodeID, target_nodeID;
+ 
+   Packet *gen_pkt;
+   hdr_uwvb *gen_vbh;
+   position * p1;
+   p1=new position[1];
+   p1[0].x=vbh->info.fx;
+   p1[0].y=vbh->info.fy;
+   p1[0].z=vbh->info.fz;    
+ 
+   printf ("vectorbasedforward:(id :%d) forward:(%d ,%d) sender is(%d,%d,%d), (%f,%f,%f) the relative position is (%f ,%f,%f) forward position is is (%f,%f,%f) at time %f type is %d real one is %d\n",here_.addr_, vbh->forward_agent_id.addr_, vbh->forward_agent_id.port_,vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num,node->X(),node->Y(),node->Z(),vbh->info.dx,vbh->info.dy,vbh->info.dz, vbh->info.fx,vbh->info.fy,vbh->info.fz,NOW,vbh->mess_type,DATA);
+  
+   
+   switch (msg_type) {
+     case INTEREST : 
+       // printf("Vectorbasedforward:it is interest packet!\n");
+       hashPtr = PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 
+       // Check if it comes from sink agent of  this node
+       // If so we have to keep it in sink list 
+ 
+       from_nodeID = vbh->sender_id;
+       forward_nodeID = vbh->forward_agent_id;
+       //  printf("Vectorbasedforward:it the from_nodeid is %d %d  and theb this node id is %d ,%d!\n", from_nodeID.addr_,from_nodeID.port_,THIS_NODE.addr_,THIS_NODE.port_ );
+ 
+       if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+    
+       MACprepare(pkt);
+       MACsend(pkt,0); 
+       //      MACsend(pkt,Random::uniform()*JITTER); 
+       printf("vectorbasedforward: after MACprepare(pkt)\n");
+       }
+       else
+        {
+           calculatePosition(pkt);
+ 	 //printf("vectorbasedforward: This packet is from different node\n");
+ 	 if (IsTarget(pkt)) 
+            { 
+             // If this node is target?
+     	      l=advance(pkt);
+         
+ 	   //  send_to_demux(pkt,0);
+ 	      //  printf("vectorbasedforward:%d send out the source-discovery \n",here_.addr_);
+ 	     vbh->mess_type=SOURCE_DISCOVERY;
+ 	     set_delaytimer(pkt,l*JITTER);
+                  // !!! need to re-think
+ 	   }
+ 	 else{ 
+ 	   // calculatePosition(pkt);
+ 	   // No the target forwared
+           l=advance(pkt);
+           h=projection(pkt, forwarder_based);
+         if (IsCloseEnough(pkt,forwarder_based)){
+ 	  // printf("vectorbasedforward:%d I am close enough for the interest\n",here_.addr_);
+       MACprepare(pkt);
+       MACsend(pkt,Random::uniform()*JITTER);//!!!! need to re-think
+ 	}
+ 	else { 
+ 	  //  printf("vectorbasedforward:%d I am not close enough for the interest  \n",here_.addr_);
+          Packet::free(pkt);}
+ 	 }
+        }
+       // Packet::free(pkt); 
+       return;
+ 
+ 
+  
+ 
+   case TARGET_DISCOVERY: 
+ 
+     if (THIS_NODE.addr_==vbh->target_id.addr_) {
+      
+        calculatePosition(pkt);
+        DataForSink(pkt);
+        //	 printf("Vectorbasedforward: %d is the target\n", here_.addr_);
+        // } //New data Process this data 
+        // 
+     } else  {Packet::free(pkt);}
+    return;
+ 
+   case SOURCE_DISCOVERY:
+       Packet::free(pkt); 
+ // other nodes already claim to be the source of this interest
+     //   SourceTable.put_in_hash(vbh);
+     return;
+ 
+ 
+  case DATA_READY :
+    //  printf("Vectorbasedforward(%d,%d):it is data ready packet(%d)! it target id is %d \n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_);    
+       from_nodeID = vbh->sender_id;
+       if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 	// come from the same node, broadcast it
+       MACprepare(pkt);
+       MACsend(pkt,Random::uniform()*JITTER); 
+       return;      
+           }
+           calculatePosition(pkt);
+       if (THIS_NODE.addr_==vbh->target_id.addr_)
+                {
+         printf("Vectorbasedforward: %d is the target\n", here_.addr_);
+ 	      DataForSink(pkt); // process it
+ 	       } 
+ 	else{
+ 	  // printf("Vectorbasedforward: %d is the not  target\n", here_.addr_); 
+       MACprepare(pkt);
+       MACsend(pkt, Random::uniform()*JITTER);
+ 	}
+       return;
+  
+     case DATA :
+       //     printf("Vectorbasedforward(%d,%d):it is data packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);  
+ 
+       // printf("Vectorbasedforward(%d) the traget address is %d\n",THIS_NODE.addr_,vbh->sender_id.addr_);   
+   
+       from_nodeID = vbh->sender_id;
+       if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 	// come from the same node, broadcast it
+       MACprepare(pkt);
+       MACsend(pkt,0); 
+       return;      
+ }
+            calculatePosition(pkt);
+ 	  //  printf("vectorbasedforward: after MACprepare(pkt)\n");
+           
+ 	   // l=advance(pkt);
+ 	   // h=projection(pkt, forwarder_based);
+ 	
+            if (THIS_NODE.addr_==vbh->target_id.addr_)
+                {
+ 		 // printf("Vectorbasedforward: %d is the target\n", here_.addr_);
+ 	      DataForSink(pkt); // process it
+ 	       }
+ 
+ 	else{
+    	    if (IsCloseEnough(pkt, forwarder_based)){
+ 	      double delay=calculateDelay(pkt,p1);
+               double d2=(UnderwaterChannel::Transmit_distance()-distance(pkt))/SPEED_OF_SOUND_IN_WATER;
+ 	      set_delaytimer(pkt,(sqrt(delay)*DELAY+d2*2));
+             printf("Vectorbasedforward: %d is forwarding a packet, speed is %f and transmission range is %f\n", here_.addr_, SPEED_OF_SOUND_IN_WATER,UnderwaterChannel::Transmit_distance() );	    
+ 	  }
+ 	  else { Packet::free(pkt);   }
+ 	     
+ 	}
+       return;
+ 
+     default : 
+       
+       Packet::free(pkt);        
+       break;
+   }
+   delete p1;
+ }
+ 
+ 
+ void VectorbasedforwardAgent::reset()
+ {
+   PktTable.reset();
+   
+ }
+ 
+ 
+ void VectorbasedforwardAgent::Terminate() 
+ {
+ #ifdef DEBUG_OUTPUT
+ 	printf("node %d: remaining energy %f, initial energy %f\n", THIS_NODE, 
+ 	       node->energy_model()->energy(), 
+ 	       node->energy_model()->initialenergy() );
+ #endif
+ }
+ 
+ 
+ void VectorbasedforwardAgent::StopSource()
+ {
+   /*
+   Agent_List *cur;
+ 
+   for (int i=0; i<MAX_DATA_TYPE; i++) {
+     for (cur=routing_table[i].source; cur!=NULL; cur=AGENT_NEXT(cur) ) {
+       SEND_MESSAGE(i, AGT_ADDR(cur), DATA_STOP);
+     }
+   }
+   */
+ }
+ 
+ 
+ Packet * VectorbasedforwardAgent:: create_packet()
+ {
+   Packet *pkt = allocpkt();
+ 
+   if (pkt==NULL) return NULL;
+ 
+   hdr_cmn*  cmh = HDR_CMN(pkt);
+   cmh->size() = 36;
+ 
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+   vbh->ts_ = NOW;
+    
+   //!! I add new part
+  
+   vbh->info.ox=node->CX();
+   vbh->info.oy=node->CY(); 
+   vbh->info.oz=node->CZ(); 
+   vbh->info.fx=node->CX(); 
+   vbh->info.fy=node->CY();
+   vbh->info.fz=node->CZ();
+ 
+ 
+ 
+   return pkt;
+ }
+ 
+ 
+ Packet *VectorbasedforwardAgent::prepare_message(unsigned int dtype, ns_addr_t to_addr,  int msg_type)
+ 
+ {
+   Packet *pkt;
+   hdr_uwvb *vbh;
+   //hdr_ip *iph;
+ 
+     pkt = create_packet();
+     vbh = HDR_UWVB(pkt);
+     // iph = HDR_IP(pkt);
+     
+     vbh->mess_type = msg_type;
+     vbh->pk_num = pk_count;
+     pk_count++;
+     vbh->sender_id = here_;
+     vbh->data_type = dtype;
+     vbh->forward_agent_id = here_;
+ 
+     vbh->ts_ = NOW;
+     //    vbh->num_next = 1;
+     // I am not sure if we need this
+     // vbh->next_nodes[0] = to_addr.addr_;
+ 
+ 
+     // I am not sure if we need it?    
+     /*
+     iph->src_ = here_;
+     iph->dst_ = to_addr;
+     */
+     return pkt;
+ }
+ 
+ void VectorbasedforwardAgent::MACprepare(Packet *pkt)
+ {
+ 
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+   hdr_cmn* cmh = HDR_CMN(pkt);
+   //  hdr_ip*  iph = HDR_IP(pkt); // I am not sure if we need it
+ 
+ 
+   vbh->forward_agent_id = here_; 
+  
+   cmh->xmit_failure_ = 0;
+   // printf("vectorbased: the mac_Broadcast is:%d\n",MAC_BROADCAST);
+   cmh->next_hop() = MAC_BROADCAST; 
+   cmh->addr_type() = NS_AF_ILINK;  
+   // cmh->txtime()=0;
+   // printf("vectorbased: the address type is :%d and suppose to be %d and  nexthop %d MAC_BROAD %d\n", cmh->addr_type(),NS_AF_ILINK,cmh->next_hop(),MAC_BROADCAST);
+   cmh->direction() = hdr_cmn::DOWN;
+   // cmh->ptype_==PT_UWVB;
+   // printf("vectorbased: the packet type is :%d\n", cmh->ptype_);
+   //  printf("ok\n");
+ 
+   //if (node) printf("ok, node is not empty\n");
+   //printf("vectorbasedforward: inside MACprepare%d %d %d \n",node->X(),node->Y(),node->Z());
+   
+ 
+   // iph->src_ = here_;
+   //iph->dst_.addr_ = MAC_BROADCAST;
+   //iph->dst_.port_ = ROUTING_PORT;
+ 
+   //  vbh->num_next = 1;
+   // vbh->next_nodes[0] = MAC_BROADCAST;
+ 
+ 
+   if(!node->sinkStatus()){       //!! I add new part
+   vbh->info.fx=node->CX();
+   vbh->info.fy=node->CY();
+   vbh->info.fz=node->CZ();
+   }
+   else{
+     vbh->info.fx=node->X();
+   vbh->info.fy=node->Y();
+   vbh->info.fz=node->Z();
+ }
+ 
+   // printf("vectorbasedforward: last line MACprepare\n");
+ }
+ 
+ 
+ void VectorbasedforwardAgent::MACsend(Packet *pkt, Time delay)
+ {
+   hdr_cmn*  cmh = HDR_CMN(pkt);
+   hdr_uwvb* vbh = HDR_UWVB(pkt);
+ 
+   // I don't understand why it works like this way
+   /*
+   if (vbh->mess_type == DATA)
+     cmh->size() = (God::instance()->data_pkt_size) + 4*(vbh->num_next - 1);
+   else
+     cmh->size() = 36 + 4*(vbh->num_next -1);
+   */
+  
+  if (vbh->mess_type == DATA)
+    // cmh->size() = (God::instance()->data_pkt_size)+12 ;
+   cmh->size() = 65+12 ;
+   else
+     cmh->size() =32;
+   
+  //if(!ll) printf("ok, the LL is empty\n");
+  //cmh->ptype_==PT_UWVB;
+  //printf("vectorbased: the address type is :%d uid is %d\n", cmh->addr_type(),pkt->uid_);
+  // printf("vectorbased: the packet type is :%d\n", cmh->ptype_);
+ // ll->handle(pkt);
+   Scheduler::instance().schedule(ll, pkt, delay);
+ }
+ 
+ 
+ void VectorbasedforwardAgent::DataForSink(Packet *pkt)
+ {
+ 
+ 
+   /*
+   hdr_uwvb     *vbh  = HDR_UWVB(pkt);
+   unsigned int dtype = vbh->data_type;
+   //Agent_List   *cur_agent;
+   Packet       *cur_pkt;
+   hdr_uwvb     *cur_vbh;
+   hdr_ip       *cur_iph;
+ 
+   for (cur_agent= (routing_table[dtype]).sink; cur_agent != NULL; 
+ 	   cur_agent= AGENT_NEXT(cur_agent) ) {
+ 
+       cur_pkt       = pkt->copy();
+       //  cur_iph       = HDR_IP(cur_pkt);
+       // cur_iph->dst_ = AGT_ADDR(cur_agent);
+ 
+       cur_vbh       = HDR_UWVB(cur_pkt);
+       cur_vbh->forward_agent_id = here_;
+       cur_vbh->num_next = 1;
+       // cur_vbh->next_nodes[0] = NODE_ADDR(cur_agent);
+       
+   */
+   //  printf("DataforSink: the packet is send to demux\n");
+       send_to_dmux(pkt, 0);
+ 
+ }
+ 
+ 
+ 
+ void VectorbasedforwardAgent::trace (char *fmt,...)
+ {
+   va_list ap;
+ 
+   if (!tracetarget)
+     return;
+ 
+   va_start (ap, fmt);
+   vsprintf (tracetarget->pt_->buffer(), fmt, ap);
+   tracetarget->pt_->dump ();
+   va_end (ap);
+ }
+ 
+ void VectorbasedforwardAgent::set_delaytimer(Packet* pkt, double c){
+  delaytimer.packet=pkt; 
+  delaytimer.resched(c);
+ }
+ 
+ void VectorbasedforwardAgent::timeout(Packet * pkt){
+ 
+  hdr_uwvb* vbh = HDR_UWVB(pkt);
+  unsigned char msg_type =vbh->mess_type;
+  neighborhood  *hashPtr;
+  minProjection=width/4;
+ printf("VB node %d in timeout  minProjection is %f\n",here_.addr_,minProjection);
+ // right now, I just consider the case of DATA package, later, we should add on other packet types 
+  switch (msg_type){
+   
+  case DATA:
+        hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 	if (hashPtr != NULL) {
+           int num_neighbor=hashPtr->number;          
+ 	  // printf("vectorbasedforward: node %d have received %d when wake up at %f\n",here_.addr_,num_neighbor,NOW);
+ 	  if (num_neighbor!=1){
+       // Some guys transmit the data before me
+ 	    if (num_neighbor==MAX_NEIGHBOR) {
+              //I have too many neighbors, I quit
+                   Packet::free(pkt);
+ 		  return;  
+ 	    }
+ 	    else //I need to calculate my delay time again 
+              {  
+ 	       int i=0;
+ 	       position tp,sp,mp;
+                double tprojection=10000.0;
+ 
+ 	       while (i<num_neighbor){
+ 	      	 sp.x=hashPtr->neighbor[i].x;   
+ 	         sp.y=hashPtr->neighbor[i].y;   
+         	 sp.z=hashPtr->neighbor[i].z;
+   
+                  tp.x=vbh->info.tx;
+                  tp.y=vbh->info.ty;
+                  tp.z=vbh->info.tz;
+                     
+                  mp.x=node->CX_;
+                  mp.y=node->CY_;
+                  mp.z=node->CZ_;
+ 
+                 double t2projection=projection(&sp,&tp,&mp);
+                  if (t2projection<tprojection) tprojection=t2projection;
+ 		 	 i++; 
+ 	       }
+ 		
+ 	      
+                if(tprojection>minProjection){ 
+      printf("vectorbasedforward:  I (%d) has neighbors minprojection=%f, but I still need to send at %f\n",here_.addr_,tprojection,NOW);
+                MACprepare(pkt);
+                MACsend(pkt,0);      
+ 		 }
+                else{
+ 	   Packet::free(pkt);//to much overlap, don;t send 
+  printf("vectorbasedforward:  I (%d) has neighbors, minprojection=%f I don't  need to send at %f\n",here_.addr_,tprojection,NOW);
+ 	       }
+ 	     }// end of calculate my new delay time 
+ 	  }
+ 
+  else{// I am the only neighbor
+ 	       position* tp;
+                tp=new position[1];
+ 		 tp[0].x=vbh->info.fx;   
+ 	         tp[0].y=vbh->info.fy;   
+         	 tp[0].z=vbh->info.fz;   
+ 		 double delay=calculateDelay(pkt,tp);
+ 
+                  delete tp;
+ 		 if (delay<=priority){
+ 	printf("vectorbasedforward:  I (%d) am the only neighbor, I send it out at %f\n",here_.addr_,NOW);
+ 		  
+                     MACprepare(pkt);
+                     MACsend(pkt,0);      
+ 		              }
+ 		 else 
+ {       
+  printf("vectorbasedforward: I am not good enough even I am the only neighbor!!%f\n",here_.addr_);
+ Packet::free(pkt);     
+ }
+ 	return;
+  }
+ 	}
+ 	break; 
+  default:
+     Packet::free(pkt);  
+    break;
+  }
+ }
+ 
+ 
+ 
+ void VectorbasedforwardAgent::calculatePosition(Packet* pkt)
+ {
+  
+  hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+  double fx=vbh->info.fx;
+  double fy=vbh->info.fy;
+  double fz=vbh->info.fz;
+ 
+  double dx=vbh->info.dx;
+  double dy=vbh->info.dy;
+  double dz=vbh->info.dz;
+ 
+  node->CX_=fx+dx;
+  node->CY_=fy+dy;
+  node->CZ_=fz+dz;
+  // printf("vectorbased: my position is computed as (%f,%f,%f)\n",node->CX_, node->CY_,node->CZ_);
+ }
+ 
+ double VectorbasedforwardAgent::calculateDelay(Packet* pkt,position* p1)
+ {
+  
+  hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+  
+  position tp;
+  position sp;
+ 
+ 
+  tp.x=vbh->info.tx;
+  tp.y=vbh->info.ty;
+  tp.z=vbh->info.tz;
+ 
+  sp.x=p1->x;
+  sp.y=p1->y;
+  sp.z=p1->z;
+  
+ 
+ 
+  double fx=p1->x;
+  double fy=p1->y;
+  double fz=p1->z;
+ 
+  double dx=node->CX_-fx; 
+  double dy=node->CY_-fy;
+  double dz=node->CZ_-fz;
+ 
+   
+  double tx=vbh->info.tx;
+  double ty=vbh->info.ty;
+  double tz=vbh->info.tz; 
+ 
+  double dtx=tx-fx;
+  double dty=ty-fy;
+  double dtz=tz-fz;  
+ 
+  double dp=dx*dtx+dy*dty+dz*dtz;
+ 
+ 
+  double p=projection(&sp,&tp,p1);
+  double d=sqrt((dx*dx)+(dy*dy)+ (dz*dz));
+  double l=sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+  double cos_theta = 0;
+ /*
+  if( d*l < EXP )
+  	cos_theta = INF;
+  else
+  	cos_theta=dp/(d*l);
+ */
+  cos_theta = dp/(d*l);
+ 
+  double delay=(p/width) +((UnderwaterChannel::Transmit_distance()-d*cos_theta)/UnderwaterChannel::Transmit_distance());
+    return delay;
+ }
+ 
+ double VectorbasedforwardAgent::distance(Packet* pkt)
+ {
+  
+  hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+  double tx=vbh->info.fx;
+  double ty=vbh->info.fy;
+  double tz=vbh->info.fz;
+  // printf("vectorbased: the target is %lf,%lf,%lf \n",tx,ty,tz);
+  double x=node->CX(); //change later
+  double y=node->CY();// printf(" Vectorbasedforward: I am in advanced\n");
+  double z=node->CZ();
+  // printf("the target is %lf,%lf,%lf and my coordinates are %lf,%lf,%lf\n",tx,ty,tz,x,y,z);
+  return sqrt((tx-x)*(tx-x)+(ty-y)*(ty-y)+ (tz-z)*(tz-z));
+ }
+ 
+ 
+ double VectorbasedforwardAgent::advance(Packet* pkt)
+ {
+  
+  hdr_uwvb     *vbh  = HDR_UWVB(pkt); 
+  double tx=vbh->info.tx;
+  double ty=vbh->info.ty;
+  double tz=vbh->info.tz;
+  // printf("vectorbased: the target is %lf,%lf,%lf \n",tx,ty,tz);
+  double x=node->CX(); //change later
+  double y=node->CY();// printf(" Vectorbasedforward: I am in advanced\n");
+  double z=node->CZ();
+  // printf("the target is %lf,%lf,%lf and my coordinates are %lf,%lf,%lf\n",tx,ty,tz,x,y,z);
+  return sqrt((tx-x)*(tx-x)+(ty-y)*(ty-y)+ (tz-z)*(tz-z));
+ }
+ 
+ 
+ double VectorbasedforwardAgent::projection(const position* sp, const position* tp,const position * p)
+ {
+ 
+  double tx=tp->x;
+  double ty=tp->y;
+  double tz=tp->z;
+  
+ 
+  double ox=sp->x;
+  double oy=sp->y;
+  double oz=sp->z;
+ 
+  double x=p->x;
+  double y=p->y;
+  double z=p->z;
+  
+  double wx=tx-ox;
+  double wy=ty-oy;
+  double wz=tz-oz;
+ 
+  double vx=x-ox;
+  double vy=y-oy;
+  double vz=z-oz;
+ 
+  double cross_product_x=vy*wz-vz*wy;
+  double cross_product_y=vz*wx-vx*wz;
+  double cross_product_z=vx*wy-vy*wx;
+   
+  double area=sqrt(cross_product_x*cross_product_x+ 
+           cross_product_y*cross_product_y+cross_product_z*cross_product_z);
+  double length=sqrt((tx-ox)*(tx-ox)+(ty-oy)*(ty-oy)+ (tz-oz)*(tz-oz));
+  // printf("vectorbasedforward: the area is %f and length is %f\n",area,length);
+  return area/length;
+ }
+ 
+ 
+ double VectorbasedforwardAgent::projection(Packet* pkt, bool forwarder_based)
+ {
+ 
+  hdr_uwvb     *vbh  = HDR_UWVB(pkt);
+  
+  double tx=vbh->info.tx;
+  double ty=vbh->info.ty;
+  double tz=vbh->info.tz;
+  
+  double ox,oy,oz;
+ 
+  if(!forwarder_based){
+   ox=vbh->info.ox;
+   oy=vbh->info.oy;
+   oz=vbh->info.oz;
+  }
+  else {
+   ox=vbh->info.fx;
+   oy=vbh->info.fy;
+   oz=vbh->info.fz;
+  }
+ 
+  double x=node->CX();
+  double y=node->CY();
+  double z=node->CZ();
+  
+  double wx=tx-ox;
+  double wy=ty-oy;
+  double wz=tz-oz;
+ 
+  double vx=x-ox;
+  double vy=y-oy;
+  double vz=z-oz;
+ 
+  double cross_product_x=vy*wz-vz*wy;
+  double cross_product_y=vz*wx-vx*wz;
+  double cross_product_z=vx*wy-vy*wx;
+   
+  double area=sqrt(cross_product_x*cross_product_x+ 
+           cross_product_y*cross_product_y+cross_product_z*cross_product_z);
+  double length=sqrt((tx-ox)*(tx-ox)+(ty-oy)*(ty-oy)+ (tz-oz)*(tz-oz));
+  //printf("vectorbasedforward: my %d projection is %f\n",here_.addr_,area/length);
+ /* if( length < EXP )
+ 	return INF;
+  else */
+  	return area/length;
+ }
+ 
+ bool VectorbasedforwardAgent::IsTarget(Packet* pkt)
+ {
+   hdr_uwvb * vbh=HDR_UWVB(pkt);
+ 
+   if (vbh->target_id.addr_==0){
+ 
+   //  printf("vectorbased: advanced is %lf and my range is %f\n",advance(pkt),vbh->range);
+     return (advance(pkt)<vbh->range);
+ }
+   else return(THIS_NODE.addr_==vbh->target_id.addr_);
+ 
+ 
+ }
+ 
+ 
+ 
+ bool VectorbasedforwardAgent::IsCloseEnough(Packet* pkt, bool forwarder_based)
+ {
+   hdr_uwvb     *vbh  = HDR_UWVB(pkt);
+   double range=vbh->range;
+   //double range=width;
+ 
+   //  printf("underwatersensor: The width is %f\n",range);
+  double ox=vbh->info.ox;
+  double oy=vbh->info.oy;
+  double oz=vbh->info.oz;
+ 
+  double tx=vbh->info.tx;
+  double ty=vbh->info.ty;
+  double tz=vbh->info.tz;
+ 
+  double fx=vbh->info.fx;
+  double fy=vbh->info.fy;
+  double fz=vbh->info.fz;
+ 
+ 
+  double x=node->CX(); //change later
+  double y=node->CY();
+  double z=node->CZ();
+ 
+  double d=sqrt((tx-fx)*(tx-fx)+(ty-fy)*(ty-fy)+(tz-fz)*(tz-fz));
+  //double l=sqrt((tx-ox)*(tx-ox)+(ty-oy)*(ty-oy)+ (tz-oz)*(tz-oz));
+  double l=advance(pkt);
+ 
+    double c=1;
+ 
+  if ((projection(pkt,forwarder_based)<=(c*width)))  return true;
+  return false;
+ 
+ }
+ 
+ 
+ int VectorbasedforwardAgent::command(int argc, const char*const* argv)
+ {  
+   Tcl& tcl =  Tcl::instance();
+ 
+   if (argc == 2) {
+ 
+     if (strcasecmp(argv[1], "reset-state")==0) {
+       
+       reset();
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "reset")==0) {
+       
+       return Agent::command(argc, argv);
+     }
+ 
+     if (strcasecmp(argv[1], "start")==0) {
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "stop")==0) {
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "terminate")==0) {
+       Terminate();
+       return TCL_OK;
+     }
+ 
+    if (strcasecmp(argv[1], "name")==0) {
+      printf("vectorbased \n");
+       return TCL_OK;
+     }
+     if (strcasecmp(argv[1], "stop-source")==0) {
+       StopSource();
+       return TCL_OK;
+     }
+ 
+   } else if (argc == 3) {
+ 
+     if (strcasecmp(argv[1], "on-node")==0) {
+       //   printf ("inside on node\n");
+       node = (UnderwaterSensorNode *)tcl.lookup(argv[2]);
+       return TCL_OK;
+     }
+     
+     if (strcasecmp(argv[1], "add-ll") == 0) {
+ 
+       TclObject *obj;
+ 
+       if ( (obj = TclObject::lookup(argv[2])) == 0) {
+     fprintf(stderr, "Vectorbasedforwarding Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 	return TCL_ERROR;
+       }
+       ll = (NsObject *) obj;
+ 
+      return TCL_OK;
+     }
+ 
+     if (strcasecmp (argv[1], "tracetarget") == 0) {
+       TclObject *obj;
+       if ((obj = TclObject::lookup (argv[2])) == 0) {
+ 	  fprintf (stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1],
+ 		   argv[2]);
+ 	  return TCL_ERROR;
+       }
+ 
+       tracetarget = (Trace *) obj;
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "port-dmux") == 0) {
+       // printf("vectorbasedforward:port demux is called \n");
+       TclObject *obj;
+ 
+       if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 	fprintf(stderr, "VB node Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 	return TCL_ERROR;
+       }
+       port_dmux = (NsObject *) obj;
+       return TCL_OK;
+     }
+ 
+   } 
+ 
+   return Agent::command(argc, argv);
+ }
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.h ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.h
*** ns-2.35/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedforward_hop_by_hop.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,264 ----
+ #ifndef ns_vectorbasedforward_h
+ #define ns_vectorbasedforward_h
+ 
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ #include <signal.h>
+ #include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "arp.h"
+ #include "mac.h"
+ #include "ll.h"
+ #include "dsr/path.h"
+ 
+ 
+ #define THIS_NODE             here_
+ //#define THIS_NODE             here_.addr_
+ #define JITTER                0.08       // (sec) to jitter broadcast
+ #define DELAY                 0.8 // maximum delay that a node holdes a packet
+ #define DELAY2                0.01
+ //#define DELAY3                0.12
+ 
+ #define SEND_MESSAGE(x,y,z)  send_to_dmux(prepare_message(x,y,z), 0)
+ 
+ #define INTEREST      1
+ #define DATA          2
+ #define DATA_READY    3
+ #define SOURCE_DISCOVERY 4
+ #define SOURCE_TIMEOUT   5
+ #define TARGET_DISCOVERY 6
+ #define TARGET_REQUEST 7
+ #define SOURCE_DENY  8
+ 
+ 
+ 
+ 
+ //#define DATA_READY    3 // not used yet
+ //#define DATA_REQUEST  4 // not used yet
+ //#define POS_REINFORCE 5 //not used yet
+ //#define NEG_REINFORCE 6 //not used yet
+ //#define INHIBIT       7 //not used yet
+ //#define TX_FAILED     8 //not used yet
+ //#define DATA_STOP     9 
+ 
+ #define MAX_ATTRIBUTE 3
+ #define MAX_NEIGHBORS 30
+ #define MAX_DATA_TYPE 30
+ #define MAX_NEIGHBOR 10
+ #define WINDOW_SIZE  19 
+ //used by hash table to limited the maximum length
+ 
+ 
+ 
+ #define ROUTING_PORT 255
+ 
+ //#define ORIGINAL    100        
+ //#define SUB_SAMPLED 1         
+ 
+ // For positive reinforcement in simple mode. 
+ // And for TX_FAILED of backtracking mode.
+ 
+ 
+ struct position{
+   double x;
+   double y;
+   double z;
+ };
+ 
+ struct neighborhood{
+   int number;
+   position neighbor[MAX_NEIGHBOR];
+ };
+ 
+ 
+ struct uw_extra_info {
+ 
+   // ns_addr_t osender_id;            // The original sender of this message
+   // unsigned int seq;           //  sequence number
+ 
+   double ox;  // the original sender's position
+   double oy;
+   double oz;
+ 
+   //ns_addr_t sender_id;            // The forwarder of this message
+ 
+   double fx;  // the original sender's position
+   double fy;
+   double fz;
+ 
+   double tx;
+   double ty;
+   double tz;
+ 
+ // this is the information about relative position of the receiver to the forwarder
+   double dx;
+   double dy;
+   double dz; 
+ 
+ };
+ 
+ 
+ struct hdr_uwvb{
+ 	unsigned int mess_type;
+ 	unsigned int pk_num;
+         ns_addr_t target_id; // the target id  of this data 
+         ns_addr_t sender_id;  //original sender id
+   // nsaddr_t next_nodes[MAX_NEIGHBORS];
+   //int      num_next;
+         unsigned int data_type;
+         ns_addr_t forward_agent_id;// the forwarder id
+ 
+        struct uw_extra_info info;
+         
+          double token;
+   	double ts_;                       // Timestamp when pkt is generated.
+       double range;    // target range
+   //    int    report_rate;               // For simple diffusion only.
+   //	int    attr[MAX_ATTRIBUTE];
+ 	
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_uwvb* access(const Packet*  p) {
+ 		return (hdr_uwvb*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ 
+ 
+ 
+ class UWPkt_Hash_Table {
+  public:
+   Tcl_HashTable htable;
+ 
+   UWPkt_Hash_Table() {
+     window_size=WINDOW_SIZE;
+     //  lower_counter=0;
+ // 50 items in the hash table, however, because it begins by 0, so, minus 1
+     Tcl_InitHashTable(&htable, 3);
+   }
+ 
+   int  window_size;
+   void reset();
+   void put_in_hash(hdr_uwvb *);
+   void put_in_hash(hdr_uwvb *, position *);
+   neighborhood* GetHash(ns_addr_t sender_id, unsigned int pkt_num);
+   //private:
+   //int lower_counter;
+ };
+ 
+ 
+ class UWData_Hash_Table {
+  public:
+   Tcl_HashTable htable;
+ 
+   UWData_Hash_Table() {
+     Tcl_InitHashTable(&htable, MAX_ATTRIBUTE);
+   }
+ 
+   void reset();
+   void PutInHash(int *attr);
+   Tcl_HashEntry  *GetHash(int *attr);
+ };
+ 
+ 
+ 
+ class VectorbasedforwardAgent;
+ 
+ class UWDelayTimer: public TimerHandler{
+ public:
+ UWDelayTimer(VectorbasedforwardAgent * a):TimerHandler(){a_=a;}
+ Packet * packet;
+ protected :
+ virtual void expire(Event* e);
+   VectorbasedforwardAgent * a_;
+   
+ };
+ 
+ 
+ class VectorbasedforwardAgent : public Agent {
+  public:
+   VectorbasedforwardAgent();
+   int command(int argc, const char*const* argv);
+   void recv(Packet*, Handler*);
+ 
+   // Vectorbasedforward_Entry routing_table[MAX_DATA_TYPE];
+ 
+  protected:
+   int pk_count;
+   int counter;
+   double priority;
+   double minProjection;
+ 
+   bool measureStatus;
+   int  forwarder_based;
+   // int port_number;
+   UWPkt_Hash_Table PktTable;
+   UWPkt_Hash_Table SourceTable;
+   UWPkt_Hash_Table Target_discoveryTable;
+   UWPkt_Hash_Table SinkTable;
+   UWDelayTimer delaytimer; 
+   
+ 
+   
+   UnderwaterSensorNode *node;
+   Trace *tracetarget;       // Trace Target
+   NsObject *ll;  
+   NsObject *port_dmux;
+   double width; 
+ // the width is used to test if the node is close enough to the path specified by the packet  
+   
+ 
+    inline void send_to_dmux(Packet *pkt, Handler *h) { 
+     port_dmux->recv(pkt, h); 
+   }
+ 
+   void Terminate();
+   void reset();
+   void ConsiderNew(Packet *pkt);
+   void set_delaytimer(Packet*,double);
+   void timeout(Packet*);
+   double advance(Packet *);
+   double distance(Packet *);
+   double projection(Packet*, bool);
+   double projection(const position*, const position*,const position *);
+   double calculateDelay(Packet*, position*);
+   //double recoveryDelay(Packet*, position*);
+   void calculatePosition(Packet*);
+    void setMeasureTimer(Packet*,double);
+   bool IsTarget(Packet*);
+   bool IsCloseEnough(Packet*, bool);
+  
+  
+   Packet *create_packet();
+   Packet *prepare_message(unsigned int dtype, ns_addr_t to_addr, int msg_type);
+ 
+   
+   void DataForSink(Packet *pkt);
+   void StopSource();
+   void MACprepare(Packet *pkt);
+   void MACsend(Packet *pkt, Time delay=0);
+ 
+   void trace(char *fmt,...);
+   friend class UWDelayTimer;
+ };
+ 
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/vectorbasedvoidavoidance.cc ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedvoidavoidance.cc
*** ns-2.35/underwatersensor/uw_routing/vectorbasedvoidavoidance.cc	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedvoidavoidance.cc	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,2445 ----
+ #include "vectorbasedvoidavoidance.h"
+ #include "god.h"
+ #include  "underwatersensor/uw_mac/underwaterpropagation.h"
+ #include "underwatersensor/uw_mac/underwaterchannel.h"
+ 
+ int hdr_uwvbva::offset_;
+ 
+ static class UWVBVAHeaderClass: public PacketHeaderClass{
+  public:
+   UWVBVAHeaderClass():PacketHeaderClass("PacketHeader/UWVBVA",sizeof(hdr_uwvbva))
+ {
+  bind_offset(&hdr_uwvbva::offset_);
+ } 
+ } class_uwvbvahdr;
+ 
+ 
+ void UWVBVAPkt_Hash_Table::reset()
+ {
+   neighborhood *hashPtr;
+   Tcl_HashEntry *entryPtr;
+   Tcl_HashSearch searchPtr;
+ 
+   entryPtr = Tcl_FirstHashEntry(&htable, &searchPtr);
+   while (entryPtr != NULL) {
+     hashPtr = (neighborhood *)Tcl_GetHashValue(entryPtr);
+      delete hashPtr;
+     Tcl_DeleteHashEntry(entryPtr);
+     entryPtr = Tcl_NextHashEntry(&searchPtr);
+   }
+ }
+ 
+ 
+ 
+ neighborhood* UWVBVAPkt_Hash_Table::GetHash(ns_addr_t sender_id, 
+ 					unsigned int pk_num)
+ {
+   unsigned int key[3];
+ 
+   key[0] = sender_id.addr_;
+   key[1] = sender_id.port_;
+   key[2] = pk_num;
+ 
+   Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(&htable, (char *)key);
+ 
+   if (entryPtr == NULL )
+      return NULL;
+ 
+   return (neighborhood *)Tcl_GetHashValue(entryPtr);
+ }
+ 
+ 
+ void UWVBVAPkt_Hash_Table::delete_hash(hdr_uwvbva * vbh)
+ {
+     Tcl_HashEntry *entryPtr;
+  
+     neighborhood* hashPtr;
+     unsigned int key[3];
+     // int newPtr;
+ 
+     key[0]=(vbh->sender_id).addr_;
+     key[1]=(vbh->sender_id).port_;
+     key[2]=vbh->pk_num;
+ 
+       
+        entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+       if (entryPtr)
+       {
+ 	hashPtr=(neighborhood*)Tcl_GetHashValue(entryPtr);
+ 	delete hashPtr;
+ 	Tcl_DeleteHashEntry(entryPtr);
+       }
+ 	return;    
+ }
+ 
+ 
+ 
+ void UWVBVAPkt_Hash_Table::delete_hash(ns_addr_t source, unsigned int pkt_num)
+ {
+     Tcl_HashEntry *entryPtr;
+  
+     neighborhood* hashPtr;
+     unsigned int key[3];
+     //int newPtr;
+ 
+     key[0]=source.addr_;
+     key[1]=source.port_;
+     key[2]=pkt_num;
+ 
+       
+        entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+       if (entryPtr)
+       {
+ 	hashPtr=(neighborhood*)Tcl_GetHashValue(entryPtr);
+ 	delete hashPtr;
+ 	Tcl_DeleteHashEntry(entryPtr);
+       }
+ 	return;    
+ }
+ 
+ void UWVBVAPkt_Hash_Table::MarkNextHopStatus(ns_addr_t sender_id, unsigned int pk_num,unsigned int forwarder_id, unsigned int status)
+ {
+     Tcl_HashEntry *entryPtr;
+   
+     neighborhood* hashPtr;
+     unsigned int key[3];
+     int newPtr;
+     // unsigned int forwarder_id=forwarder_id;
+ 
+     key[0]=sender_id.addr_;
+     key[1]=sender_id.port_;
+     key[2]=pk_num;
+ 
+ 
+      entryPtr = Tcl_CreateHashEntry(&htable, (char *)key, &newPtr);
+     if (!newPtr){
+      hashPtr=GetHash(sender_id,pk_num);
+     int m=hashPtr->number;
+ 
+     for (int i=0;i<m;i++) {
+         if ((hashPtr->neighbor[i].forwarder_id==forwarder_id)&&
+ 	    (hashPtr->neighbor[i].status==FRESHED))
+             hashPtr->neighbor[i].status=status;
+     }
+     }
+     else printf("hashtable, the packet record doesn't exist\n");
+ 
+     return;
+ }
+ 
+ 
+ void UWVBVAPkt_Hash_Table::put_in_hash(hdr_uwvbva * vbh)
+ {
+     Tcl_HashEntry *entryPtr;
+     neighborhood* hashPtr;
+     unsigned int key[3];
+     int newPtr;
+     unsigned int forwarder_id=(vbh->forward_agent_id).addr_;
+ 
+     key[0]=(vbh->sender_id).addr_;
+     key[1]=(vbh->sender_id).port_;
+     key[2]=vbh->pk_num;
+ 
+      int  k=key[2]-window_size;
+ 
+     if(k>0)
+       {
+       for (int i=0;i<k;i++)
+ 	{
+           key[2]=i;
+        entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+       if (entryPtr)
+      {
+ 	hashPtr=(neighborhood*)Tcl_GetHashValue(entryPtr);
+ 	delete hashPtr;
+ 	Tcl_DeleteHashEntry(entryPtr);
+       }
+ 	}
+       }     
+      
+     key[2]=vbh->pk_num;
+     entryPtr = Tcl_CreateHashEntry(&htable, (char *)key, &newPtr);
+ 
+     if (!newPtr){// the record already exist
+     hashPtr=GetHash(vbh->sender_id,vbh->pk_num);
+     int m=hashPtr->number;
+ 
+     int k=0;
+     while((hashPtr->neighbor[k].forwarder_id!=forwarder_id)&&(k<m)) k++;
+ 
+     if(k==m) hashPtr->number++;    
+     if (k<MAX_NEIGHBOR){
+ 	hashPtr->neighbor[k].vec.start.x=0;
+         hashPtr->neighbor[k].vec.start.y=0;
+ 	hashPtr->neighbor[k].vec.start.z=0;
+ 
+    	hashPtr->neighbor[k].vec.end.x=0;
+         hashPtr->neighbor[k].vec.end.y=0;
+ 	hashPtr->neighbor[k].vec.end.z=0;
+ 
+ 	hashPtr->neighbor[k].node.x=0;
+         hashPtr->neighbor[k].node.y=0;
+ 	hashPtr->neighbor[k].node.z=0;
+ 
+         hashPtr->neighbor[k].forwarder_id=forwarder_id;
+         hashPtr->neighbor[k].status=FRESHED;
+     }
+     else {
+ 	for(int i=1;i<MAX_NEIGHBOR;i++)
+ 	{
+ 	    hashPtr->neighbor[i-1].vec=hashPtr->neighbor[i].vec; 
+             hashPtr->neighbor[i-1].node=hashPtr->neighbor[i].node;
+ 
+             hashPtr->neighbor[i-1].forwarder_id=hashPtr->neighbor[i].forwarder_id;
+             hashPtr->neighbor[i-1].status= hashPtr->neighbor[i].status;
+ 	}
+       
+        	hashPtr->neighbor[MAX_NEIGHBOR-1].vec.start.x=0;
+         hashPtr->neighbor[MAX_NEIGHBOR-1].vec.start.y=0;
+ 	hashPtr->neighbor[MAX_NEIGHBOR-1].vec.start.z=0;
+ 
+        	hashPtr->neighbor[MAX_NEIGHBOR-1].vec.end.x=0;
+         hashPtr->neighbor[MAX_NEIGHBOR-1].vec.end.y=0;
+ 	hashPtr->neighbor[MAX_NEIGHBOR-1].vec.end.z=0;
+ 
+         hashPtr->neighbor[MAX_NEIGHBOR-1].node.x=0;
+         hashPtr->neighbor[MAX_NEIGHBOR-1].node.y=0;
+ 	hashPtr->neighbor[MAX_NEIGHBOR-1].node.z=0;
+ 
+ 
+        hashPtr->neighbor[MAX_NEIGHBOR-1].forwarder_id=forwarder_id;
+        hashPtr->neighbor[MAX_NEIGHBOR-1].status=FRESHED;
+     }
+     return;
+     }
+ 
+     // the record does not exist
+ 
+     hashPtr=new neighborhood;
+     hashPtr->number=1;
+ 
+ 
+     hashPtr->neighbor[0].vec.start.x=0;
+     hashPtr->neighbor[0].vec.start.y=0;
+     hashPtr->neighbor[0].vec.start.z=0;
+ 
+     hashPtr->neighbor[0].vec.end.x=0;
+     hashPtr->neighbor[0].vec.end.y=0;
+     hashPtr->neighbor[0].vec.end.z=0;
+ 
+     hashPtr->neighbor[0].node.x=0;
+     hashPtr->neighbor[0].node.y=0;
+     hashPtr->neighbor[0].node.z=0;
+ 
+     hashPtr->neighbor[0].forwarder_id=forwarder_id;
+     hashPtr->neighbor[0].status=FRESHED;
+ 
+     Tcl_SetHashValue(entryPtr, hashPtr);
+ }
+ 
+ 
+ void UWVBVAPkt_Hash_Table::put_in_hash(hdr_uwvbva * vbh, const position* sp, const position* tp, const position* fp, unsigned  int status)
+ {
+     Tcl_HashEntry *entryPtr;
+     neighborhood* hashPtr;
+     unsigned int key[3];
+     int newPtr;
+     unsigned int forwarder_id=(vbh->forward_agent_id).addr_;
+ 
+     key[0]=vbh->sender_id.addr_;
+     key[1]=vbh->sender_id.port_;
+     key[2]=vbh->pk_num;
+ 
+ 
+      int  k=key[2]-window_size;
+     if(k>0)
+       {
+ 	for (int i=0;i<k;i++){
+ 	  key[2]=i;
+        entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+       if (entryPtr)
+      {
+ 	hashPtr=(neighborhood*)Tcl_GetHashValue(entryPtr);
+ 	delete hashPtr;
+ 	Tcl_DeleteHashEntry(entryPtr);
+       }
+ 
+       }       
+       }
+        key[2]=vbh->pk_num;
+     entryPtr = Tcl_CreateHashEntry(&htable, (char *)key, &newPtr);
+ 
+     if (!newPtr)// record already exists
+ {
+      hashPtr=GetHash(vbh->sender_id,vbh->pk_num);
+     int m=hashPtr->number;
+ 
+     int k=0;
+     while((hashPtr->neighbor[k].forwarder_id!=forwarder_id)&&(k<m)) k++;
+     if(k==m) hashPtr->number++;
+     
+ 
+   // printf("hash_table: this is not old item, there are %d item inside\n",m); 
+     if (k<MAX_NEIGHBOR){
+ 	hashPtr->neighbor[k].vec.start.x=sp->x;
+         hashPtr->neighbor[k].vec.start.y=sp->y;
+ 	hashPtr->neighbor[k].vec.start.z=sp->z;
+ 
+ 	hashPtr->neighbor[k].vec.end.x=tp->x;
+         hashPtr->neighbor[k].vec.end.y=tp->y;
+ 	hashPtr->neighbor[k].vec.end.z=tp->z;
+ 
+         hashPtr->neighbor[k].node.x=fp->x;
+         hashPtr->neighbor[k].node.y=fp->y;
+ 	hashPtr->neighbor[k].node.z=fp->z;
+       
+       
+        hashPtr->neighbor[k].forwarder_id=forwarder_id;
+        hashPtr->neighbor[k].status=status;
+     }
+     else {
+ 	for(int i=1;i<MAX_NEIGHBOR;i++)
+ 	{
+ 	    hashPtr->neighbor[i-1].vec=hashPtr->neighbor[i].vec; 
+             hashPtr->neighbor[i-1].node=hashPtr->neighbor[i].node;
+ 
+             hashPtr->neighbor[i-1].forwarder_id=hashPtr->neighbor[i].forwarder_id;
+             hashPtr->neighbor[i-1].status= hashPtr->neighbor[i].status;
+ 	}
+ 
+ 	hashPtr->neighbor[MAX_NEIGHBOR-1].vec.start=(*sp);
+ 	hashPtr->neighbor[MAX_NEIGHBOR-1].vec.end=(*tp);
+  	hashPtr->neighbor[MAX_NEIGHBOR-1].node=(*fp);
+ 
+        hashPtr->neighbor[MAX_NEIGHBOR-1].forwarder_id=forwarder_id;
+        hashPtr->neighbor[MAX_NEIGHBOR-1].status=FRESHED;
+     }
+ 
+         return;
+ } 
+     // record does not exist
+     hashPtr=new neighborhood;
+     hashPtr->number=1;
+ 
+     hashPtr->neighbor[0].vec.start=(*sp);
+     hashPtr->neighbor[0].vec.end=(*tp);
+     hashPtr->neighbor[0].node=(*fp);
+     
+ 
+     hashPtr->neighbor[0].forwarder_id=forwarder_id;
+     hashPtr->neighbor[0].status=status;
+ 
+ 
+     Tcl_SetHashValue(entryPtr, hashPtr);
+     return;   
+ }
+ 
+ 
+ void UWVBVAData_Hash_Table::reset()
+ {
+   unsigned int *hashPtr;
+   Tcl_HashEntry *entryPtr;
+   Tcl_HashSearch searchPtr;
+ 
+   entryPtr = Tcl_FirstHashEntry(&htable, &searchPtr);
+   while (entryPtr != NULL) {
+     hashPtr = (unsigned int *)Tcl_GetHashValue(entryPtr);
+      delete hashPtr;
+     Tcl_DeleteHashEntry(entryPtr);
+     entryPtr = Tcl_NextHashEntry(&searchPtr);
+   }
+ }
+ 
+ 
+ void UWVBVAData_Hash_Table::put_in_hash(ns_addr_t source, unsigned int pkt_num, unsigned int status)
+ {
+     Tcl_HashEntry *entryPtr;
+     int* hashPtr;
+     unsigned int key[3];
+     int statusPtr;
+     unsigned int* valuePtr=0;
+    
+     valuePtr=new unsigned int;
+     (*valuePtr)=status;   
+ 
+     key[0]=source.addr_;
+     key[1]=source.port_;
+     key[2]=pkt_num;
+     
+     entryPtr = Tcl_CreateHashEntry(&htable, (char*)key, &statusPtr);
+     Tcl_SetHashValue(entryPtr,valuePtr);        
+     return;
+ }
+   
+ 
+ void UWVBVAData_Hash_Table::delete_hash(ns_addr_t source, unsigned int pkt_num)
+ {
+     Tcl_HashEntry *entryPtr;
+  
+     unsigned int* hashPtr;
+     unsigned int key[3];
+ 
+     key[0]=source.addr_;
+     key[1]=source.port_;
+     key[2]=pkt_num;
+ 
+       
+        entryPtr=Tcl_FindHashEntry(&htable, (char *)key);
+       if (entryPtr)
+       {
+ 	hashPtr=(unsigned int*)Tcl_GetHashValue(entryPtr);
+ 	delete hashPtr;
+ 	Tcl_DeleteHashEntry(entryPtr);
+       }
+ 	return;    
+ }
+ 
+ 
+ 
+ 
+ unsigned int*  UWVBVAData_Hash_Table::GetHash(ns_addr_t source, unsigned int pkt_num)
+ {
+   unsigned int key[3];
+ 
+   key[0] =source.addr_;
+   key[1] =source.port_;
+   key[2] = pkt_num;
+ 
+   Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(&htable, (char *)key);
+ 
+   if (!entryPtr)
+      return NULL;
+  
+   return (unsigned int*)Tcl_GetHashValue(entryPtr);
+ }
+ 
+ void UWDelayHandler:: handle(Event* e)
+ {
+   a_->process_forward_timeout((Packet*) e);
+ }
+ 
+ 
+ void UWVoidAvoidHandler:: handle(Event* e)
+ {
+   a_->process_void_avoidance_timeout((Packet*)e);
+ }
+ 
+ /*
+ void UWFloodingHandler::handle(Event* e)
+ {
+   a_->process_flooding_timeout((Packet*)e);
+ }
+ */
+ 
+ 
+ void UWFloodingBackwardHandler::handle(Event* e)
+ {
+   a_->process_backpressure_timeout((Packet*)e);
+ }
+ 
+ void UWFloodingForwardHandler::handle(Event* e)
+ {
+   a_->process_selfcentered_timeout((Packet*)e);
+ }
+ 
+ 
+ /*
+ void UWFBackwardFloodingHandler::handle(Event* e)
+ {
+   a_->process_backwardflooding_packet_timeout((Packet*)e);
+ }
+ */
+ 
+ 
+ 
+ static class VectorbasedVoidAvoidanceClass : public TclClass {
+ public:
+   VectorbasedVoidAvoidanceClass() : TclClass("Agent/VectorbasedVoidAvoidance") {}
+   TclObject* create(int argc, const char*const* argv) {
+     return(new VectorbasedVoidAvoidanceAgent());
+   }
+ } class_vectorbasedvoidavoidance;
+ 
+ 
+ 
+ 
+ VectorbasedVoidAvoidanceAgent::VectorbasedVoidAvoidanceAgent() : Agent(PT_UWVBVA),forward_delay_handler(this),void_avoidance_buffer(15,0),void_avoidance_handler(this),backpressure_handler(this),mini_distance(20.0),mini_threshold(1.5), /*receiving_buffer(10),*/self_centered_forward_handler(this)
+ {
+ 
+   position_update_time=-1.0;
+   pk_count = 0;
+   target_ = 0;
+   node = NULL;
+   tracetarget = NULL;
+   width=0;
+   counter=0;
+   bind("width",& width);
+   bind("control_packet_size",& control_packet_size);
+   
+ }
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::recv(Packet* packet, Handler*)
+ {
+   if (node->failure_status()==1){    
+   printf ("vectorbasedvoidavoidance%d: I fails!!!!\n ",here_.addr_);
+   Packet::free(packet);
+   return;
+   }
+   
+ 
+   printf (">>>vectorbasedvoidavoidance%d: recv  at %f\n ",here_.addr_,NOW);
+ 
+ 
+   hdr_uwvbva* vbh = HDR_UWVBVA(packet);
+   unsigned  int  msg_type =vbh->mess_type;
+   double t1=vbh->ts_;
+   position * p1;
+   ns_addr_t source=vbh->sender_id;
+   ns_addr_t forwarder=vbh->forward_agent_id;  
+   unsigned int pkt_num=vbh->pk_num; 
+ 
+   unsigned int* statusPtr=PacketStatusTable.GetHash(source,pkt_num);
+  if(statusPtr&&((*statusPtr)==TERMINATED)){
+ printf("vectrobasedforward node %d: this packet has been terminated\n",here_.addr_);
+  Packet::free(packet);
+  return;
+  }
+ 
+  /*
+       if(msg_type==BACKFLOODING){
+ // printf("vectrobasedforward node %d: recv backflooding  from the sender %d\n",here_.addr_,vbh->forward_agent_id.addr_);
+ 
+      unsigned int* packet_status=PacketStatusTable.GetHash(source,pkt_num);
+        
+      if (((packet_status*)==FLOODED)||((packet_status*)==CENTERED)||((packet_status*)==SENT)) {       
+  // printf("vectrobasedforward node %d:the data packet is flooded, termonated or center_sent\n",here_.addr_); 
+          Packet::free(packet);
+ 	return;
+     }    
+      processBackFloodedPacket(packet);
+       return;
+       }  
+  */
+ 
+       if(msg_type==DATA_TERMINATION){
+ // printf("vectrobasedforward node %d: recv DATA_TERMINATION  from the sender %d\n",here_.addr_,vbh->forward_agent_id.addr_);
+       PacketStatusTable.put_in_hash(source,pkt_num,TERMINATED);
+       Packet::free(packet);
+       return;
+       }  
+ 
+       if((msg_type==V_SHIFT)||(msg_type==V_SHIFT_DATA)){
+ 	//printf("vectrobasedforward node %d: recv V_SHIFT or V_D from the sender %d\n",here_.addr_,vbh->forward_agent_id.addr_);  
+         if(IsNewlyTouchedNode(source, pkt_num)){
+   printf("vectrobasedforward node %d is a newly touched node\n",here_.addr_);
+   
+ //  unsigned int* packet_status=PacketStatusTable.GetHash(source,pkt_num);
+ 
+         PacketStatusTable.put_in_hash(source,pkt_num,SUPPRESSED);
+ 	processCenteredPacket(packet);
+          return;
+  } else Packet::free(packet);
+       }
+ 
+       if((msg_type==EXPENSION)||(msg_type==EXPENSION_DATA)){
+ 	//printf("vectrobasedforward node %d: recv EXPENSION  from the sender %d\n",here_.addr_,vbh->forward_agent_id.addr_);  
+       
+         unsigned int* packet_status=PacketStatusTable.GetHash(source,pkt_num);
+ 
+         if((!packet_status)||((*packet_status)==SUPPRESSED)){
+         PacketStatusTable.put_in_hash(source,pkt_num,VOID_SUPPRESSED);
+ 	processCenteredPacket(packet);
+          return;
+  } else Packet::free(packet);
+       }
+ 
+   if(msg_type==BACKPRESSURE){
+     //printf("vectrobasedforward node %d: receives a backpressure packet(%d) from %d\n",here_.addr_,pkt_num,vbh->forward_agent_id.addr_); 
+         processBackpressurePacket(packet);     
+     return;
+ }
+ 
+   if(msg_type==DATA){
+     printf(">>>vectrobasedforward node %d: receives a DATA packet from %d\n",here_.addr_,vbh->forward_agent_id.addr_);      
+      unsigned int* statusPtr= PacketStatusTable.GetHash(source,pkt_num);
+      neighborhood *  packetPtr=PktTable.GetHash(source,pkt_num);
+    
+  if ((statusPtr)||(packetPtr)) {  
+    
+         recordPacket(vbh);
+         Packet::free(packet);
+ 	return;
+     }
+ 
+  //   if(t1>position_update_time) {
+             calculatePosition(packet);
+                position_update_time=t1;
+ 	       // }
+  
+      ConsiderNew(packet);     
+      return ;
+   }
+ }
+ 
+ 
+ 
+ // this function assme that the end points of the vectors are the same
+ bool 
+ VectorbasedVoidAvoidanceAgent::IsSamePosition(const position* sp1, const position* sp2)
+ {
+     double err=0.1;
+     if(fabs(sp1->x-sp2->x)>err) return false;
+     if(fabs(sp1->y-sp2->y)>err) return false;
+     if(fabs(sp1->z-sp2->z)>err) return false;
+     return true;
+ } 
+ 
+ void 
+ VectorbasedVoidAvoidanceAgent::recordPacket(hdr_uwvbva* vbh, unsigned int status)
+ {
+       position sp,ep,fp;
+   
+ 
+       fp.x=vbh->info.fx;
+       fp.y=vbh->info.fy;
+       fp.z=vbh->info.fz;    
+ 
+       sp.x=vbh->info.ox;
+       sp.y=vbh->info.oy;
+       sp.z=vbh->info.oz;
+    
+       ep.x=vbh->info.tx;
+       ep.y=vbh->info.ty;
+       ep.z=vbh->info.tz;
+       
+       PktTable.put_in_hash(vbh,&sp,&ep,&fp, status);
+ 
+     return;
+ }
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::processCenteredPacket(Packet* pkt)
+ {
+   //  printf("vectorbased node %d: process centered packet\n",here_.addr_);
+ 
+ 
+ 
+  if(!pkt){
+      printf("vectorbased node %d: the data packet is empty\n",here_.addr_);
+     return;
+   }
+ 
+ 
+ 
+ 
+       hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+ 
+       ns_addr_t source=vbh->sender_id;
+       unsigned pkt_num=vbh->pk_num;
+     
+       Packet* tpacket=0;
+     
+     
+       position mp,tp,sp,fp;
+  
+       mp.x=node->CX();
+       mp.y=node->CY();
+       mp.z=node->CZ();
+ 
+       tp.x=vbh->info.tx;
+       tp.y=vbh->info.ty;
+       tp.z=vbh->info.tz;
+     
+       fp.x=vbh->info.fx;
+       fp.y=vbh->info.fy;
+       fp.z=vbh->info.fz;
+  
+       sp.x=vbh->info.ox;
+       sp.y=vbh->info.oy;
+       sp.z=vbh->info.oz;
+ 
+       //printf("vectorbased: node(%d) sp (%f,%f,%f) tp (%f,%f,%f) and fp(%f,%f,%f)\n",here_.addr_,sp.x,sp.y,sp.z,tp.x,tp.y,tp.z,fp.x,fp.y,fp.z);
+ 
+ 
+  double delay_factor=calculateSelfCenteredDelay(&sp,&tp,&mp,&fp);
+  if (delay_factor>1.2){
+    Packet::free(pkt);
+    return;
+  }
+ 
+ 
+       if((vbh->mess_type==V_SHIFT)||(vbh->mess_type==EXPENSION)){
+ 
+       Packet::free(pkt);
+ 
+       Packet* p=void_avoidance_buffer.LookupCopy(source,pkt_num);
+ 
+  if(!p){
+      printf("vectorbased node %d: can not find the corresponding packet in the buffer\n",here_.addr_);
+     return;
+   }
+    tpacket=p->copy();
+ 
+       } else{
+ 
+ 	// in case this node is target
+        if (THIS_NODE.addr_==vbh->target_id.addr_)
+                {
+ 	      sendDataTermination(pkt); 
+ 	      PacketStatusTable.put_in_hash(source,pkt_num,TERMINATED); 
+ 	      DataForSink(pkt); // process it
+ 	      return;
+ 	       }
+ 
+       tpacket=pkt->copy();
+       Packet::free(pkt);
+       }   
+ 
+      if(!tpacket) {
+  printf("vectorbased node %d: can not generate the corresponding packet\n",here_.addr_);
+ return;
+      }
+      vbh = HDR_UWVBVA(tpacket);
+    
+      vbh->info.ox=mp.x;
+      vbh->info.oy=mp.y;
+      vbh->info.oz=mp.z;
+ 
+      vbh->info.fx=mp.x;
+      vbh->info.fy=mp.y;
+      vbh->info.fz=mp.z;
+   
+      vbh->mess_type=DATA;
+ 
+      
+      double delay= sqrt(delay_factor)*DELAY*2.0;
+      //     printf("vectorbased:node %d sets its timer for %f at %f\n", here_.addr_, delay,NOW);
+ 
+      Scheduler& s=Scheduler::instance();
+      s.schedule(&self_centered_forward_handler,(Event*)tpacket,delay);  
+ 
+      // added by peng xie 20071118 
+       PktTable.delete_hash(source,pkt_num);// to be used by timeout process     
+      return;
+ }
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::processBackpressurePacket(Packet* pkt)
+ {
+   //  printf("Vectorbasedvoidavoidance node %d process BackpressurePacket\n",here_.addr_);
+   if(!pkt) {
+     // printf("Vectorbasedvoidavoidance node %d processBackpressurePacket: the packet is empty\n",here_.addr_);
+     return; 
+   }
+ 
+   hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+   unsigned int msg_type =vbh->mess_type;
+ 
+   ns_addr_t   target_id, source, forwarder;
+   int num=vbh->pk_num;
+   unsigned int packet_status=SUPPRESSED;
+   
+   target_id=vbh->target_id;
+   source=vbh->sender_id;  
+   
+   position tp, fp,mp;
+ 
+    tp.x=vbh->info.tx;
+    tp.y=vbh->info.ty;
+    tp.z=vbh->info.tz;
+ 
+    fp.x=vbh->info.fx;
+    fp.y=vbh->info.fy;
+    fp.z=vbh->info.fz;
+   
+    mp.x=node->CX();
+    mp.y=node->CY();
+    mp.z=node->CZ();
+ 
+   
+ 
+    // added by peng xie 20071118
+    if(!IsUpstreamNode(mp,fp,tp)){
+      // not from upstream node, ignore it, 
+      Packet::free(pkt);
+      return;
+    }    
+    
+ 
+    unsigned int * statusPtr= PacketStatusTable.GetHash(source,num);  
+   if(!statusPtr){ 
+  printf("Vectorbasedvoidavoidance: %d never process the data packet referenced by this backpressure packt\n", here_.addr_); 
+        Packet::free(pkt);
+        return; 
+   } else {
+     packet_status=(*statusPtr); 
+   }
+ 
+   // PktTable.MarkNextHopStatus(source,num,forwarder.addr_,DEAD); 
+ 
+ 
+   // addded by peng xie at 20071117
+   if ((packet_status==SUPPRESSED)||(packet_status==TERMINATED)||(packet_status==VOID_SUPPRESSED)) {
+ printf("Vectorbasedvoidavoidance: %d  this backpressure have been processed or not sent by this node\n", here_.addr_); 
+     Packet::free(pkt);
+        return;
+   } 
+ 
+  
+     neighborhood *hashPtr= PktTable.GetHash(source, num);
+ 
+     if (!hashPtr){
+   printf ("vectorbasedvoidavoidance(%d): there is no record for this backpressure\n ",here_.addr_);
+   Packet::free(pkt);
+   return;
+     }
+ 
+ 
+       PktTable.MarkNextHopStatus(source,num,forwarder.addr_,DEAD); 
+ 
+     neighbornode* forwarder_list= hashPtr->neighbor; 
+     int num_of_forwarder=hashPtr->number;
+ 
+     if(IsStuckNode(forwarder_list,&tp,num_of_forwarder,packet_status)){
+    printf ("vectorbasedvoidavoidance(%d): is stuck node\n ",here_.addr_);
+       if((packet_status==FORWARDED)||(packet_status==CENTER_FORWARDED)){
+         PacketStatusTable.put_in_hash(source,num,FLOODED);
+       	  
+               Packet* p;
+            if(packet_status==FORWARDED) p=generateControlDataPacket(pkt,V_SHIFT_DATA);
+ 	   else  p=generateControlDataPacket(pkt,EXPENSION_DATA);
+ 
+              Packet* pt=generateBackpressurePacket(pkt);
+         	 Packet::free(pkt);
+ 
+ 	   if(!p){
+   printf ("vectorbasedvoidavoidance(%d): can not generate control data packet\n ",here_.addr_);
+ 	     return;
+ 	   }
+        if(!pt){
+   printf ("vectorbasedvoidavoidance(%d): can not generate backpressure packet\n ",here_.addr_);
+ 	     return;
+ 	   }
+         
+           PktTable.delete_hash(source,num);
+ 
+           double d3=(UnderwaterChannel::Transmit_distance())/SPEED_OF_SOUND_IN_WATER;     
+             double d4=Random::uniform()*JITTER;    
+ 	    //  double c=DELAY*sqrt(mini_threshold)+JITTER+d3*3+d4;
+ 	     double c=DELAY*sqrt(3.0)*4.0+JITTER+d3*3+d4;
+            Scheduler& s=Scheduler::instance();
+            s.schedule(&backpressure_handler,(Event*)pt,c);
+ 
+         MACprepare(p);
+         MACsend(p,0);
+       } else {
+         PacketStatusTable.put_in_hash(source,num,TERMINATED);
+         Packet* p=generateBackpressurePacket(pkt);
+ 	Packet::free(pkt);       
+ 
+         if(!p){
+   printf ("vectorbasedvoidavoidance(%d): can not generate backpressure packet\n ",here_.addr_);
+ 	     return;
+ 	   }
+ 
+         MACprepare(p);
+         MACsend(p,0);
+       }
+ 
+       return;
+     }
+ }
+ 
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::ConsiderNew(Packet *pkt)
+ {
+   hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+   unsigned int msg_type =vbh->mess_type;
+   ns_addr_t source=vbh->sender_id;
+   unsigned int pkt_num=vbh->pk_num;
+ 
+    double l,h;
+   
+    neighborhood * hashPtr;
+    ns_addr_t   from_nodeID, forward_nodeID, target_nodeID;
+ 
+   Packet *gen_pkt;
+   hdr_uwvbva *gen_vbh;
+ 
+   position sp,ep,fp;
+   
+ 
+   sp.x=vbh->info.ox;
+   sp.y=vbh->info.oy;
+   sp.z=vbh->info.oz;
+ 
+   ep.x=vbh->info.tx;
+   ep.y=vbh->info.ty;
+   ep.z=vbh->info.tz;
+ 
+   fp.x=vbh->info.fx;
+   fp.y=vbh->info.fy;
+   fp.z=vbh->info.fz;    
+ 
+   printf("Consider New!\n");
+   
+   //   printf ("vectorbasedvoidavoidance:(id :%d) forward:(%d ,%d) sender is(%d,%d,%d), my position is (%f,%f,%f) forward position is (%f,%f,%f) at time %f  \n",here_.addr_, vbh->forward_agent_id.addr_, vbh->forward_agent_id.port_,vbh->sender_id.addr_,vbh->sender_id.port_,vbh->pk_num,node->X(),node->Y(),node->Z(),vbh->info.fx,vbh->info.fy,vbh->info.fz,NOW);
+  
+   
+   switch (msg_type) {
+     case INTEREST : 
+       // printf("Vectorbasedvoidavoidance:it is interest packet!\n");
+       hashPtr = PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+ 
+       // Check if it comes from sink agent of  this node
+       // If so we have to keep it in sink list 
+ 
+       from_nodeID = vbh->sender_id;
+       forward_nodeID = vbh->forward_agent_id;
+       //  printf("Vectorbasedvoidavoidance:it the from_nodeid is %d %d  and theb this node id is %d ,%d!\n", from_nodeID.addr_,from_nodeID.port_,THIS_NODE.addr_,THIS_NODE.port_ );
+ 
+       if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+    
+       MACprepare(pkt);
+       MACsend(pkt,0); 
+       //      MACsend(pkt,Random::uniform()*JITTER); 
+       printf("vectorbasedvoidavoidance: after MACprepare(pkt)\n");
+       }
+       else
+        {
+           calculatePosition(pkt);
+ 	 //printf("vectorbasedvoidavoidance: This packet is from different node\n");
+ 	 if (IsTarget(pkt)) 
+            { 
+             // If this node is target?
+     	      l=advance(pkt);
+         
+ 	   //  send_to_demux(pkt,0);
+          //  printf("vectorbasedvoidavoidance:%d send out the source-discovery \n",here_.addr_);
+ 	     vbh->mess_type=SOURCE_DISCOVERY;
+ 	     setForwardDelayTimer(pkt,l*JITTER);
+                  // !!! need to re-think
+ 	   }
+ 	 else{ 
+ 	   // calculatePosition(pkt);
+ 	   // No the target forwared
+           l=advance(pkt);
+           h=projection(pkt);
+         if (IsCloseEnough(pkt)){
+ 	  // printf("vectorbasedvoidavoidance:%d I am close enough for the interest\n",here_.addr_);
+       MACprepare(pkt);
+       MACsend(pkt,Random::uniform()*JITTER);//!!!! need to re-think
+ 	}
+ 	else { 
+ 	  //  printf("vectorbasedvoidavoidance:%d I am not close enough for the interest  \n",here_.addr_);
+          Packet::free(pkt);
+               }
+ 	 }
+        }
+       // Packet::free(pkt); 
+       return;
+ 
+   case TARGET_DISCOVERY: 
+ // from other nodes hitted by the packet, it is supposed
+ // to be the one hop away from the sink 
+ 
+ // printf("Vectorbasedvoidavoidance(%d,%d):it is target-discovery  packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);    
+     if (THIS_NODE.addr_==vbh->target_id.addr_) {
+   pk_count = 0;
+   target_ = 0;    
+       // ns_addr_t *hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+      // Received this packet before ?
+       // if (hashPtr == NULL) { 
+ 
+        calculatePosition(pkt);
+        DataForSink(pkt);
+        //	 printf("Vectorbasedvoidavoidance: %d is the target\n", here_.addr_);
+        // } //New data Process this data 
+        // 
+     } else  {Packet::free(pkt);}
+    return;
+ 
+   case SOURCE_DISCOVERY:
+       Packet::free(pkt); 
+ // other nodes already claim to be the source of this interest
+     //   SourceTable.put_in_hash(vbh);
+     return;
+ 
+ 
+  case DATA_READY :
+    //  printf("Vectorbasedvoidavoidance(%d,%d):it is data ready packet(%d)! it target id is %d \n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_);    
+       from_nodeID = vbh->sender_id;
+       if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 	// come from the same node, broadcast it
+       MACprepare(pkt);
+       MACsend(pkt,Random::uniform()*JITTER); 
+       return;      
+           }
+           calculatePosition(pkt);
+       if (THIS_NODE.addr_==vbh->target_id.addr_)
+                {
+         printf("Vectorbasedvoidavoidance: %d is the target\n", here_.addr_);
+ 	      DataForSink(pkt); // process it
+ 	       } 
+ 	else{
+ 	  // printf("Vectorbasedvoidavoidance: %d is the not  target\n", here_.addr_); 
+       MACprepare(pkt);
+       MACsend(pkt, Random::uniform()*JITTER);
+ 	}
+       return;
+  
+     case DATA :
+       //    printf("Vectorbasedvoidavoidance(%d,%d):it is data packet(%d)! it target id is %d  coordinate is %f,%f,%f and range is %f\n",here_.addr_,here_.port_,vbh->pk_num,vbh->target_id.addr_,vbh->info.tx, vbh->info.ty,vbh->info.tz,vbh->range);  
+ 
+  // printf("Vectorbasedvoidavoidance(%d) the traget address is %d\n",THIS_NODE.addr_,vbh->sender_id.addr_);   
+   
+       from_nodeID = vbh->sender_id;
+       if (THIS_NODE.addr_ == from_nodeID.addr_) {       
+ 	// come from the same node, broadcast it
+            PacketStatusTable.put_in_hash(source,pkt_num,CENTER_FORWARDED);
+             void_avoidance_buffer.CopyNewPacket(pkt);          
+ 
+         double d3=(UnderwaterChannel::Transmit_distance())/SPEED_OF_SOUND_IN_WATER;   
+ 	// Packet* pt=pkt->copy();
+         double c=2*DELAY+JITTER+d3*3;
+ 
+            set_shift_timer(pkt,c); 
+           
+       MACprepare(pkt);
+       MACsend(pkt,Random::uniform()*JITTER);
+       return;      
+ }	     
+ 	 if (THIS_NODE.addr_==vbh->target_id.addr_)
+                {
+ 	      sendDataTermination(pkt); 
+ 	      PacketStatusTable.put_in_hash(source,pkt_num,TERMINATED); 
+ 	      DataForSink(pkt); // process it
+ 	       }
+ 
+ 	else{
+      
+ 	 if (IsCloseEnough(pkt)){
+ 	        recordPacket(vbh);   
+                 void_avoidance_buffer.CopyNewPacket(pkt);
+           double delay=calculateDesirableness(pkt);
+ 	  PacketStatusTable.put_in_hash(source, pkt_num,SUPPRESSED);// later possibly changed in forward_timeout
+ 	 
+           double d2=(UnderwaterChannel::Transmit_distance()-distance(pkt))/SPEED_OF_SOUND_IN_WATER;
+           double d3=(UnderwaterChannel::Transmit_distance())/SPEED_OF_SOUND_IN_WATER;   
+           double d4=Random::uniform()*JITTER;    
+ 	   setForwardDelayTimer(pkt,(sqrt(delay)*DELAY+d2*2+d3+d4));
+ 	  } else { 
+        // put the data packet into its buffer to wait for void-avoidance use
+ 	    //!!!!!!!!!!!!!!!  reconsider this action  
+               recordPacket(vbh);    
+ 	      void_avoidance_buffer.AddNewPacket(pkt);
+    }   
+ 	}
+       break;
+ 
+     default :       
+       Packet::free(pkt);        
+       break;
+   }
+ }
+ 
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsNewlyTouchedNode(ns_addr_t source, unsigned int pkt_num)
+ {
+   
+   unsigned int * statusPtr=PacketStatusTable.GetHash(source, pkt_num);
+   if(statusPtr) return false;
+   return true;
+  
+   /*
+   unsigned int * statusPtr=PacketStatusTable.GetHash(source, pkt_num);
+   if(statusPtr) return false;
+   */
+ 
+   /* old version of newly touched 
+   neighborhood*  ptr=PktTable.GetHash(source, pkt_num);
+   if(!ptr) return true;
+   int num=ptr->number; 
+   if((num==1)&&(ptr->neighbor[0].forwarder_id==forwarder.addr_)) return true;
+   return false;
+   */
+ }
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::reset()
+ {
+   PktTable.reset();
+   /*
+   for (int i=0; i<MAX_DATA_TYPE; i++) {
+     routing_table[i].reset();
+   }
+   */
+ }
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::Terminate() 
+ {
+ #ifdef DEBUG_OUTPUT
+ 	printf("node %d: remaining energy %f, initial energy %f\n", THIS_NODE, 
+ 	       node->energy_model()->energy(), 
+ 	       node->energy_model()->initialenergy() );
+ #endif
+ }
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::MACprepare(Packet *pkt)
+ {
+ 
+   hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+   hdr_cmn* cmh = HDR_CMN(pkt);
+ 
+   vbh->forward_agent_id = here_; 
+  
+   cmh->xmit_failure_ = 0;
+   // printf("vectorbased: the mac_Broadcast is:%d\n",MAC_BROADCAST);
+   cmh->next_hop() = MAC_BROADCAST; 
+   cmh->addr_type() = NS_AF_ILINK;  
+   // cmh->txtime()=0;
+   // printf("vectorbased: the address type is :%d and suppose to be %d and  nexthop %d MAC_BROAD %d\n", cmh->addr_type(),NS_AF_ILINK,cmh->next_hop(),MAC_BROADCAST);
+   cmh->direction() = hdr_cmn::DOWN;
+   // cmh->ptype_==PT_UWVB;
+   // printf("vectorbased: the packet type is :%d\n", cmh->ptype_);
+   //  printf("ok\n");
+ 
+   //if (node) printf("ok, node is not empty\n");
+   //printf("vectorbasedvoidavoidance: inside MACprepare%d %d %d \n",node->X(),node->Y(),node->Z());
+   
+ 
+   // iph->src_ = here_;
+   //iph->dst_.addr_ = MAC_BROADCAST;
+   //iph->dst_.port_ = ROUTING_PORT;
+ 
+   //  vbh->num_next = 1;
+   // vbh->next_nodes[0] = MAC_BROADCAST;
+ 
+ 
+   if(!node->sinkStatus()){       //!! I add new part
+   vbh->info.fx=node->CX();
+   vbh->info.fy=node->CY();
+   vbh->info.fz=node->CZ();
+   }
+   else{
+     vbh->info.fx=node->X();
+     vbh->info.fy=node->Y();
+     vbh->info.fz=node->Z();
+ }
+ 
+ }
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::MACsend(Packet *pkt, Time delay)
+ {
+   hdr_cmn*  cmh = HDR_CMN(pkt);
+   hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+ 
+   // cmh->size() +=control_packet_size;
+   Scheduler::instance().schedule(ll, pkt, delay);
+ }
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsControlMessage(const Packet* pkt){
+ 
+   hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+   if ((vbh->mess_type == DATA)||(vbh->mess_type==FLOODING))
+       return false;
+   else
+       return true;
+ }
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsUpstreamNode(const position& mp, const position& fp, const position& tp){
+ 
+  double dtx=tp.x-mp.x;
+  double dty=tp.y-mp.y;
+  double dtz=tp.z-mp.z;  
+ 
+  // double mydistance= sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+  double dis=calculateMappedDistance(&mp,&tp,&fp);
+  if(dis>0) return true;
+  else false;   
+ }
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::DataForSink(Packet *pkt)
+ {
+ 
+   //  printf("DataforSink: the packet is send to demux\n");
+       send_to_dmux(pkt, 0);
+ 
+ }
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::trace (char *fmt,...)
+ {
+   va_list ap;
+ 
+   if (!tracetarget)
+     return;
+ 
+   va_start (ap, fmt);
+   vsprintf (tracetarget->pt_->buffer(), fmt, ap);
+   tracetarget->pt_->dump ();
+   va_end (ap);
+ }
+ 
+ void VectorbasedVoidAvoidanceAgent::setForwardDelayTimer(Packet* pkt, double c){
+    printf(">>> vectorbased node(%d) is setting the timer %f at %f\n",THIS_NODE.addr_,c,NOW);
+       Scheduler& s=Scheduler::instance();
+       s.schedule(&forward_delay_handler,(Event*)pkt,c);
+ }
+  
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::set_shift_timer(Packet* pkt, double c){
+  if(!pkt) {
+    // printf("Vectorbasedvoidavoidance: node(%d) the packet does exist in the set_shifter_timer \n",here_.addr_);
+    return;
+  }
+ 
+  hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+  
+  ns_addr_t source=vbh->sender_id;
+  unsigned int pkt_num=vbh->pk_num;
+  position s_position,t_position;
+ 
+  unsigned int* status=PacketStatusTable.GetHash(source,pkt_num);
+  if(!status) {
+    //   printf("Vectorbasedvoidavoidance: node(%d) the packet status does exist in the set_shifter_timer \n",here_.addr_);
+    return;
+  }
+ 
+  
+ //  added by peng xiw 20071118
+ 
+ 
+ /*
+  s_position.x=vbh->info.ox;
+  s_position.y=vbh->info.oy;
+  s_position.z=vbh->info.oz;
+ */
+ 
+  s_position.x=vbh->info.fx;
+  s_position.y=vbh->info.fy;
+  s_position.z=vbh->info.fz;
+ 
+ 
+ 
+  t_position.x=vbh->info.tx;
+  t_position.y=vbh->info.ty;
+  t_position.z=vbh->info.tz;
+ 
+  //printf("vectorbased: node(%d) set v-shift  timer sp (%f,%f,%f) tp (%f,%f,%f) \n",here_.addr_,vbh->info.ox,vbh->info.oy,vbh->info.oz,vbh->info.tx,vbh->info.ty,vbh->info.tz);
+ 
+  Packet* p=generateVectorShiftPacket(&source, pkt_num,&s_position,&t_position);
+  
+  if(!p) {
+    printf ("vectorbasedvoidavoidance (%d): can not generate v_shift data\n ",here_.addr_);
+    return;
+  }
+  hdr_uwvbva* vbh1 = HDR_UWVBVA(p);  
+  if((*status)==CENTER_FORWARDED) vbh1->mess_type=EXPENSION;
+ 
+  //printf ("vectorbasedvoidavoidance (%d): sets void_avoidance timer at %f and delay is %f\n ",here_.addr_,NOW,c);
+        Scheduler& s=Scheduler::instance();
+        s.schedule(&void_avoidance_handler,(Event*)p,c);
+       return;
+ }
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::process_backpressure_timeout(Packet* pkt)
+ {  
+   //printf ("vectorbasedvoidavoidance (%d): processp  back pressure timeout at %f\n ",here_.addr_,NOW);
+   if(!pkt) {
+     // printf ("vectorbasedvoidavoidance %d: back pressure packet is null\n ",here_.addr_);
+  return;
+   }
+  
+   hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+ 
+   hdr_cmn* cmh = HDR_CMN(pkt);
+   int size=cmh->size();
+ 
+    ns_addr_t source=vbh->sender_id;
+    ns_addr_t forward=vbh->forward_agent_id;
+ 
+ 
+    
+    unsigned int pkt_num=vbh->pk_num;
+  
+     neighbornode* forwarder_list;
+     int num_of_forwarder;
+   
+ 
+       unsigned int * statusPtr=PacketStatusTable.GetHash(source, pkt_num);
+       if(!statusPtr) {
+  printf ("vectorbasedvoidavoidance(%d): The packet is already terminated!\n ",here_.addr_);
+       Packet::free(pkt);
+       return;
+       }
+ 
+       if ((*statusPtr)==TERMINATED){
+     printf ("vectorbasedvoidavoidance(%d): The packet is already terminated!\n ",here_.addr_);
+       Packet::free(pkt);
+   return;
+      }
+      
+ 
+      
+      if(IsEndNode(source, pkt_num)){   
+         printf("vectorbased node %d is an end node size is %d\n",here_.addr_,size); 
+   
+         MACprepare(pkt);    
+         MACsend(pkt,0);   
+         PacketStatusTable.put_in_hash(source,pkt_num,TERMINATED); 
+     } else {
+ printf("vectorbased node %d is not a end node\n",here_.addr_);
+ Packet::free(pkt);
+     }
+ 
+     return;
+ }
+ 
+ 
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::process_selfcentered_timeout(Packet* pkt)
+ {
+   // printf ("vectorbasedvoidavoidance(%d):self-centered timer expires! at %f\n ",here_.addr_,NOW);
+   if(!pkt)// printf ("vectorbasedvoidavoidance(%d): the packet doesn't exist \n ",here_.addr_);
+ 
+     neighbornode* forwarder_list;
+     int num_of_forwarder;
+     ns_addr_t source;
+     ns_addr_t forward;
+     unsigned int pkt_num;
+     hdr_uwvbva* vbh=HDR_UWVBVA(pkt);   
+   
+     source=vbh->sender_id;
+     forward=vbh->forward_agent_id;
+     pkt_num=vbh->pk_num;
+ 
+     unsigned int  *statusPtr=PacketStatusTable.GetHash(source, pkt_num);
+   
+     if(!statusPtr) {
+  printf ("vectorbasedvoidavoidance(%d): The packet status is null!\n ",here_.addr_);
+     Packet::free(pkt);
+     return;
+     }
+     
+     if(((*statusPtr)==TERMINATED)||((*statusPtr)==FLOODED))
+     {
+   printf ("vectorbasedvoidavoidance(%d): The packet is already terminated or self-center forwarded!\n ",here_.addr_);
+     Packet::free(pkt);
+     return;
+      }
+    
+     /*
+     neighborhood *hashPtr=PktTable.GetHash(source, pkt_num);
+     int num=hashPtr->number; 
+     neighbornode* neighbor_list=hashPtr->neighbor;
+     */
+ 
+     if (!IsWorthFloodingForward(source,pkt_num))
+      {
+      printf ("vectorbasedvoidavoidance(%d): is not worth forwarding this packet\n ",here_.addr_);
+ 
+      //????????????????????????
+      //      PacketStatusTable.put_in_hash(source,pkt_num, SUPPRESSED); 
+      //       PacketStatusTable.delete_hash(source,pkt_num); 
+       Packet::free(pkt);
+       return;
+     }
+ 
+     //        printf ("vectorbasedvoidavoidance(%d): is worth forwarding this packet\n ",here_.addr_);
+        
+           double d3=(UnderwaterChannel::Transmit_distance())/SPEED_OF_SOUND_IN_WATER;     
+           double d4=Random::uniform()*JITTER;    
+           set_shift_timer(pkt,(sqrt(mini_threshold)*DELAY*2+d3*3+d4)); 
+ 	
+ 
+ 	  /*
+ 	Packet* pt=generateBackpressurePacket(&source,pkt_num);
+ 	PktTable.delete_hash(source, pkt_num);
+ 
+             double d3=(UnderwaterChannel::Transmit_distance())/SPEED_OF_SOUND_IN_WATER;
+      
+             double d4=Random::uniform()*JITTER;    
+ 	    
+ 	    //   double c=DELAY*sqrt(mini_threshold)+JITTER+d3*3+d4;
+             double c=DELAY*sqrt(3.0)*4.0+d3*3+d4;
+   
+ 
+        Scheduler& s=Scheduler::instance();
+        s.schedule(&backpressure_handler,(Event*)pt,c);
+ 	  */
+          
+      if(*statusPtr==VOID_SUPPRESSED)PacketStatusTable.put_in_hash(source,pkt_num, CENTER_FORWARDED);
+      else PacketStatusTable.put_in_hash(source,pkt_num, FORWARDED);
+ 
+      MACprepare(pkt);
+      MACsend(pkt,0);
+        return;
+ }
+  	    
+  
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::process_forward_timeout(Packet * pkt){
+   //printf("vectorbased: node (%d) pkt  self-adaption timeout at %f\n", here_.addr_,NOW);  
+  hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+  unsigned char msg_type =vbh->mess_type;
+  neighborhood  *hashPtr;
+  int c=0;
+  double tdelay=calculateDesirableness(pkt);
+  double td=tdelay;
+  ns_addr_t source=vbh->sender_id;
+  unsigned int pkt_num=vbh->pk_num;
+  unsigned int status;
+      unsigned int  *statusPtr= PacketStatusTable.GetHash(source, pkt_num);
+      int ncounter=0;
+ 
+      position tsp,ttp,tmp,tfp;
+ 
+      tsp.x=vbh->info.ox;
+      tsp.y=vbh->info.oy;
+      tsp.z=vbh->info.oz;
+ 
+ 
+      ttp.x=vbh->info.tx;
+      ttp.y=vbh->info.ty;
+      ttp.z=vbh->info.tz;
+  
+      tfp.x=vbh->info.fx;
+      tfp.y=vbh->info.fy;
+      tfp.z=vbh->info.fz;
+ 
+      tmp.x=node->CX();
+      tmp.y=node->CY();
+      tmp.z=node->CZ();
+   
+      //     td=calculateDelay(&tfp,&ttp,&tmp,&tfp);
+ 
+      /*
+      if(statusPtr){
+     printf ("vectorbasedvoidavoidance(%d): The packet is already processed!\n ",here_.addr_);
+   Packet::free(pkt);
+   return;
+      }
+      */
+     
+      // printf("vectorbased: node (%d) pkt %d self-adaption timeout at %f\n", here_.addr_,pkt_num,NOW);  
+  switch (msg_type){
+  case DATA:
+        hashPtr= PktTable.GetHash(vbh->sender_id, vbh->pk_num);
+       
+ 
+ 	if (hashPtr) {
+           int num_neighbor=hashPtr->number;
+ 	  position mysp,myep;
+           int i=0;
+ 
+ 	  mysp.x=vbh->info.ox;
+           mysp.y=vbh->info.oy;
+           mysp.z=vbh->info.oz;
+ 
+           myep.x=vbh->info.tx;
+           myep.y=vbh->info.ty;
+           myep.z=vbh->info.tz;
+ 
+                        
+ 	       position  sp,fp;
+ 	       tdelay=1000;
+ 
+ 	       //printf("vectorbased: node (%d) self-adaption, num of neighbor is %d\n", here_.addr_,num_neighbor);  
+ 	         while (i<num_neighbor){
+ 		     sp=hashPtr->neighbor[i].vec.start;
+                      fp=hashPtr->neighbor[i].node;
+ 		     //printf("vectorbased: node (%d) self-adaption, sp.x=  %f sp.y=%f and sp.z=%f, fp.x=%f, fp.y=%f and fp.z=%f, myposition is (%f,%f,%f)\n", here_.addr_,sp.x, sp.y,sp.z,fp.x, fp.y,fp.z,node->X(), node->Y(),node->Z()); 		   
+ 		     double t2delay=calculateDelay(pkt,&fp);
+ 		     //printf("vectorbased: node (%d) self-adaption, t2delay is  %f\n", here_.addr_,t2delay); 
+ 		 if (t2delay<tdelay) tdelay=t2delay;
+ 		 	 i++; 
+ 		 }
+ 		 ncounter=i;
+ 	}
+ 		if(ncounter>0) ncounter--; // delete my first packet record    
+ 
+ 		priority=mini_threshold/pow(2.0,ncounter);
+                 // priority=mini_threshold;
+ 
+  
+                if(tdelay<=priority) {  
+ 		 // printf("vectorbased: node (%d) is still worth forwarding the data packet c=%d and tdelay=%f \n", here_.addr_,ncounter,tdelay);  
+ 
+ double d3=(UnderwaterChannel::Transmit_distance())/SPEED_OF_SOUND_IN_WATER;  
+             double d4=Random::uniform()*JITTER;    
+          
+            set_shift_timer(pkt,(sqrt(mini_threshold)*DELAY*2+d3*3+d4)); 
+            PacketStatusTable.put_in_hash(source, pkt_num,FORWARDED);
+                MACprepare(pkt);
+                MACsend(pkt,0);      
+ 		 } else{
+ 		   //printf("vectorbased: node (%d) is not worth forwarding the data packet c=%d and tdelay=%f \n", here_.addr_,c,tdelay);       
+ // PktTable.MarkNextHopStatus(vbh->sender_id, vbh->pk_num,forwarder_id, SUPPRESSED);//??
+ // PacketStatusTable.put_in_hash(source, pkt_num,SUPPRESSED);
+ //  if(ncounter==0)     PacketStatusTable.delete_hash(source, pkt_num); 
+ //  if(td>2.0)     PacketStatusTable.delete_hash(source, pkt_num);
+ 	   Packet::free(pkt); //to much overlap, don't send 
+ 	       }
+ 	break; 
+  default: 
+        break;
+  }
+ }
+ 
+ 
+ //not necessary
+  void VectorbasedVoidAvoidanceAgent::makeCopy(Packet* pkt){
+      Packet* p1=pkt->copy();
+      void_avoidance_buffer.AddNewPacket(pkt);        
+  }
+ 
+ 
+  void VectorbasedVoidAvoidanceAgent::sendFloodingPacket(Packet* pkt){
+   
+      hdr_uwvbva* vbh=HDR_UWVBVA(pkt);
+     
+      vbh->mess_type=FLOODING;   
+  
+      vbh->info.fx=node->CX();
+      vbh->info.fy=node->CY();
+      vbh->info.fz=node->CZ();
+ 
+      vbh->info.ox=node->CX();
+      vbh->info.oy=node->CY();
+      vbh->info.oz=node->CZ();
+ 
+      vbh->forward_agent_id=here_;
+      
+      //     printf ("vectorbasedvoidavoidance(%d): sends the flooding packet at %f !\n ",here_.addr_, NOW);
+      MACprepare(pkt);    
+      MACsend(pkt,0);
+      return;
+  }
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::process_void_avoidance_timeout(Packet* pkt)
+ {
+   //printf ("vectorbasedvoidavoidance(%d): void_avoidance timeout at  %f !\n ",here_.addr_, NOW);
+ 
+   if(!pkt) {
+     //printf ("vectorbasedvoidavoidance(%d): void_avoidance timeout at  %f ! and the packet is empty\n ",here_.addr_, NOW);
+  return;
+   }
+     hdr_uwvbva* vbh=HDR_UWVBVA(pkt);
+     ns_addr_t source=vbh->sender_id;
+     ns_addr_t forward=vbh->forward_agent_id;
+     unsigned int pkt_num=vbh->pk_num;
+ 
+     position t_p;
+     position sp;
+     unsigned int  * statusPtr=0;
+ 
+ 
+     t_p.x=vbh->info.tx;
+     t_p.y=vbh->info.ty;
+     t_p.z=vbh->info.tz;
+ 
+     sp.x=vbh->info.ox;
+     sp.y=vbh->info.oy;
+     sp.z=vbh->info.oz;
+ 
+     neighbornode* forwarder_list;
+     int num_of_forwarder;
+ 
+     // printf ("vectorbasedvoidavoidance(%d): the timer for v_shift expires at %f !\n ",here_.addr_, NOW);
+ 
+     statusPtr= PacketStatusTable.GetHash(source, pkt_num);
+     
+      if(statusPtr && (((*statusPtr)==TERMINATED) ||((*statusPtr)==FLOODED)))  { 
+  
+ printf ("vectorbasedvoidavoidance(%d): The packet is already terminated!\n ",here_.addr_);
+  Packet::free(pkt);
+   return;
+      }
+ 
+ 
+        if (IsVoidNode(source,pkt_num,&sp)){
+ 
+      //         if (IsVoidNode(source,pkt_num)){
+        printf ("vectorbasedvoidavoidance(%d): is void node\n ",here_.addr_);
+      
+         PacketStatusTable.put_in_hash(source,pkt_num,FLOODED);    
+         
+ 	// Packet* pt=generateBackpressurePacket(pkt);
+ 
+ 	// MACprepare(pkt);  
+         MACsend(pkt, 0);       
+ 
+ 
+         Packet* pdata=void_avoidance_buffer.LookupCopy(source,pkt_num); 
+ 
+    if(!pdata){
+      printf("Vectorbasedvoidavoidance: %d the data packet referenced by this flooding packet does not exist\n", here_.addr_);
+      return; 
+    }
+ 
+ 	//	Packet* pt=generateBackpressurePacket(&source,pkt_num);
+         
+         Packet* pt=generateBackpressurePacket(pdata);
+ 
+ 	PktTable.delete_hash(source, pkt_num);
+         double d3=(UnderwaterChannel::Transmit_distance())/SPEED_OF_SOUND_IN_WATER;
+      
+             double d4=Random::uniform()*JITTER;    
+ 	    //   double c=DELAY*sqrt(mini_threshold)+JITTER+d3*3+d4;
+             double c=DELAY*sqrt(3.0)*4.0+d3*3+d4;
+ 
+        if(!pt){
+  printf("Vectorbasedvoidavoidance(%d): can not generate backpressure packet\n ",here_.addr_);
+  return;
+        } else {
+ printf("Vectorbasedvoidavoidance(%d): set timer  backpressure packet(%d) delay=%f at %f\n ",here_.addr_,pkt_num,c,NOW);
+        Scheduler& s=Scheduler::instance();
+        s.schedule(&backpressure_handler,(Event*)pt,c);
+       return;   
+        }
+     } else{
+    printf ("vectorbasedvoidavoidance(%d): is not a void node\n ",here_.addr_);
+    Packet::free(pkt);
+    return;
+      }
+ }
+ 
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::sendDataTermination(const Packet* p)
+ {
+      hdr_uwvbva* vbh2=HDR_UWVBVA(p);
+      ns_addr_t source=vbh2->sender_id; 
+      unsigned int pkt_num=vbh2->pk_num;
+  
+       DataTerminationPktTable.put_in_hash(vbh2);
+ 
+ 
+       Packet * pkt=Packet::alloc();
+      
+ 
+       hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+       hdr_ip* iph = HDR_IP(pkt);
+       hdr_cmn*  cmh = HDR_CMN(pkt);
+      
+ 
+       cmh->ptype()=PT_UWVB;
+       cmh->size() =control_packet_size*8;
+ 
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+ 
+ 
+       vbh->mess_type =DATA_TERMINATION;
+       vbh->pk_num = pkt_num;
+       vbh->ts_=NOW;     
+       vbh->sender_id = source;
+       vbh->forward_agent_id=here_;       
+  
+       vbh->info.ox=node->X();
+       vbh->info.oy=node->Y();
+       vbh->info.oz=node->Z();
+ 
+       vbh->info.fx=node->X();
+       vbh->info.fy=node->Y();
+       vbh->info.fz=node->Z();
+  
+         cmh->xmit_failure_ = 0;
+         cmh->next_hop() = MAC_BROADCAST; 
+         cmh->addr_type() = NS_AF_ILINK;  
+         cmh->direction() = hdr_cmn::DOWN;
+     
+         MACsend(pkt, 0);
+        printf("node (%d,%d) send data termination %d at %lf\n ",here_.addr_,here_.port_,pkt_num,NOW);
+           
+ }
+ 
+ // Is sp useful? 
+ Packet* VectorbasedVoidAvoidanceAgent::generateVectorShiftPacket(const ns_addr_t* source,int pkt_num, const position* sp, const position* tp)
+ {
+   //printf("Vectorbasedvoidavoidance node (%d) generates V_Shift\n",here_.addr_);
+ 
+       Packet * v_shift=Packet::alloc();
+ 
+  if(!v_shift) {
+ printf("Vectorbasedvoidavoidance node (%d) can't not generate v_shift packet since the data packet is empty\n",here_.addr_);
+ return NULL;
+   }
+ 
+ printf("vectorbased: node(%d) generate v-shift sp (%f,%f,%f) tp (%f,%f,%f) \n",here_.addr_,sp->x,sp->y,sp->z,tp->x,tp->y,tp->z);
+ 
+ 
+       hdr_uwvbva* vbh = HDR_UWVBVA(v_shift);
+       hdr_ip* iph = HDR_IP(v_shift);
+       hdr_cmn*  cmh = HDR_CMN(v_shift);
+      
+ 
+       cmh->ptype()=PT_UWVB;
+       cmh->size() =control_packet_size*8;
+ 
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+ 
+ 
+       vbh->mess_type =V_SHIFT;
+       vbh->pk_num = pkt_num;
+       vbh->ts_=0;     
+       vbh->sender_id =(*source);
+       vbh->forward_agent_id=here_;       
+  
+       /*
+       vbh->info.ox=node->CX();
+       vbh->info.oy=node->CY();
+       vbh->info.oz=node->CZ();
+       */
+ 
+       // delete by peng xie 20071118
+ 
+       
+       vbh->info.ox=sp->x;
+       vbh->info.oy=sp->y;
+       vbh->info.oz=sp->z;
+       
+ 
+ 
+       vbh->info.fx=node->CX();
+       vbh->info.fy=node->CY();
+       vbh->info.fz=node->CZ();
+ 
+       vbh->info.tx=tp->x;
+       vbh->info.ty=tp->y;
+       vbh->info.tz=tp->z;
+ 
+       vbh->original_source=(*sp); 
+ 
+         cmh->xmit_failure_ = 0;
+         cmh->next_hop() = MAC_BROADCAST;        
+      cmh->addr_type() = NS_AF_ILINK;  
+         cmh->direction() = hdr_cmn::DOWN;
+ 	return v_shift;          
+ }
+ 
+ 
+ Packet* VectorbasedVoidAvoidanceAgent::generateControlDataPacket(Packet* packet, unsigned int type)
+ {
+  if(!packet) {
+    //printf("Vectorbasedvoidavoidance node (%d) can't not generate control data packet since the data packet is empty\n",here_.addr_);
+ return NULL;
+   }
+ 
+       Packet * vD=packet->copy();
+ 
+ if(!vD) {
+ printf("Vectorbasedvoidavoidance node (%d) can't not generate control data packet due to the failure of meme allocation\n",here_.addr_);
+ return NULL;
+   }
+       hdr_uwvbva* vbh = HDR_UWVBVA(vD);
+       hdr_ip* iph = HDR_IP(vD);
+       hdr_cmn*  cmh = HDR_CMN(vD);
+      
+       cmh->ptype()=PT_UWVB;
+      
+       /*
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+       */
+ 
+       vbh->mess_type =type;
+       vbh->ts_=0;     
+       
+        vbh->forward_agent_id=here_;
+ 
+         cmh->xmit_failure_ = 0;
+         cmh->next_hop() = MAC_BROADCAST; 
+         cmh->addr_type() = NS_AF_ILINK;  
+         cmh->direction() = hdr_cmn::DOWN;
+ 	return vD;          
+ }
+ 
+ 
+ 
+ Packet* VectorbasedVoidAvoidanceAgent::generateBackpressurePacket(Packet* packet)
+ {
+ 
+   if(!packet) {
+     //printf("Vectorbasedvoidavoidance node (%d) can't not generate backpressure since the data packet is empty\n",here_.addr_);
+ return NULL;
+   }
+       Packet * backpressure=packet->copy();
+ 
+  if(!backpressure) {
+ printf("Vectorbasedvoidavoidance node (%d) can't not generate backpressure due to the meme allocation\n",here_.addr_);
+ return NULL;
+   }
+ 
+ 
+       hdr_uwvbva* vbh = HDR_UWVBVA(backpressure);
+       hdr_ip* iph = HDR_IP(backpressure);
+       hdr_cmn*  cmh = HDR_CMN(backpressure);
+      
+       cmh->ptype()=PT_UWVBVA;
+      
+       
+       iph->src_=here_;
+       iph->dst_.addr_=here_.addr_;
+       iph->dst_.port_=255;
+       
+ 
+       vbh->mess_type =BACKPRESSURE;
+       vbh->ts_=0;     
+       
+        vbh->forward_agent_id=here_;
+  
+         cmh->xmit_failure_ = 0;
+         cmh->next_hop() = MAC_BROADCAST; 
+         cmh->addr_type() = NS_AF_ILINK;  
+         cmh->direction() = hdr_cmn::DOWN;
+ 	return backpressure;          
+ }
+ 
+ 
+ 
+ double VectorbasedVoidAvoidanceAgent::calculateFloodingDesirableness(const Packet* pkt)
+ {
+   
+    double d1=distance(pkt);  
+    double dt=UnderwaterChannel::Transmit_distance(); 
+    double dr=dt-d1;
+    if(dr<0) dr=0.0; // in case of location error
+    double d2=dr/SPEED_OF_SOUND_IN_WATER;
+ 
+      return (dr/dt)*DELAY+2*d2;       
+   
+ }
+ 
+ 
+ double VectorbasedVoidAvoidanceAgent::calculateDesirableness(const Packet* pkt)
+ {
+ 
+     hdr_uwvbva* vbh = HDR_UWVBVA(pkt);
+     position sp,tp,fp, mp;
+  
+ 
+ 	sp.x=vbh->info.ox;
+         sp.y=vbh->info.oy;
+         sp.z=vbh->info.oz;
+    
+      
+    tp.x=vbh->info.tx;
+    tp.y=vbh->info.ty;
+    tp.z=vbh->info.tz;
+ 
+    fp.x=vbh->info.fx;
+    fp.y=vbh->info.fy;
+    fp.z=vbh->info.fz;
+ 
+ 
+    mp.x=node->CX();
+    mp.y=node->CY();
+    mp.z=node->CZ();
+ 
+    return calculateDelay(&sp,&tp,&mp,&fp);
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsStuckNode(const neighbornode* neighbor_list,const position* tp,int num_of_neighbor, unsigned int status )
+ {
+ 
+   position mp;
+ 
+   mp.x=node->CX();
+   mp.y=node->CY();
+   mp.z=node->CZ();
+  
+   double mydis=distance(tp,&mp);
+   //  unsigned int * statusPtr= PacketStatusTable.GetHash(source,pk_num);  
+ 
+ 
+     for(int i=0;i<num_of_neighbor;i++){
+ 	position fp=neighbor_list[i].node;
+         double tmp_dis=distance(tp, &fp);
+         if ((tmp_dis<mydis)&&(neighbor_list[i].status!=DEAD)) return false;
+     }
+     if((status==FORWARDED)||(status==CENTER_FORWARDED)) return true;    
+     if(status==FLOODED){
+     for(int i=0;i<num_of_neighbor;i++){
+ 	position fp=neighbor_list[i].node;
+         position sp=neighbor_list[i].vec.start;
+         if ((IsSamePosition(&fp,&sp))&&(neighbor_list[i].status!=DEAD)) return false;
+     }
+     }
+     return true;
+ }
+ 
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsWorthFloodingForward(ns_addr_t source, int pkt_num)
+ {
+     printf("vectorbased: node(%d) is determining if it worth flooding forward \n",here_.addr_);
+  
+     neighborhood *hashPtr=PktTable.GetHash(source, pkt_num);
+     if(!hashPtr) return true;
+ 
+     int num=hashPtr->number; 
+      neighbornode* neighbor_list=hashPtr->neighbor;
+ 
+     // to check if there is some one self-centered sending the packet before me?? 
+     for(int i=0;i<num;i++){
+ 	position fp=neighbor_list[i].node;
+         position sp=neighbor_list[i].vec.start;
+         // added by peng xie
+ 	unsigned fid=neighbor_list[i].forwarder_id;
+ 
+ 	//added by peng xie 20071118
+      if(IsSamePosition(&fp,&sp)&&((fid!=source.addr_))) return false;
+     }
+     return true;
+ }
+ 
+ 
+ 
+ 
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsEndNode(ns_addr_t source,int pkt_num)
+ {
+     printf("vectorbased: node(%d) is determining if it is an end node\n",here_.addr_);
+    
+     neighborhood *hashPtr= PktTable.GetHash(source, pkt_num);
+     if(!hashPtr) return true;
+ 
+      neighbornode* neighbor_list= hashPtr->neighbor;       
+      int num_of_neighbor=hashPtr->number;
+   
+     for(int i=0;i<num_of_neighbor;i++){
+ 	position fp=neighbor_list[i].node;
+         position op=neighbor_list[i].vec.start;
+         unsigned int forwarder_id=neighbor_list[i].forwarder_id;
+ 	//printf("vectorbased: node(%d)  fp.x=%f,fp.y=%f and pf.z=%f op.x=%f, op.y=%f and op.z=%f\n",here_.addr_,fp.x,fp.y,fp.z,op.x,op.y,op.z);
+ 
+         if (IsSamePosition(&op,&fp)) return false;
+     }
+     return true;
+ }
+ 
+ 
+ 
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsVoidNode(ns_addr_t source, int pkt_num,const position* sp)
+ {
+     printf("vectorbased: node(%d) is determining if it is void node\n",here_.addr_);
+ 
+     neighborhood *hashPtr= PktTable.GetHash(source, pkt_num);
+ 
+     if (!hashPtr) return true;
+ 
+     neighbornode* neighbor_list= hashPtr->neighbor; 
+     int num_of_neighbor=hashPtr->number;
+      position mp;
+      //  position sp=neighbor_list[0].vec.start; 
+       position tp=neighbor_list[0].vec.end;
+ 
+      mp.x=node->CX();
+     mp.y=node->CY();
+     mp.z=node->CZ();   
+       printf("my position (%f %f %f) sp is (%f %f %f) tp is(%f %f %f)\n",mp.x,mp.y,mp.z, sp->x,sp->y,sp->z,tp.x,tp.y,tp.z);
+  double myadvance=calculateMappedDistance(sp,&tp,&mp);
+ 
+     printf("vectorbased: node(%d) is determining if it is void node,  # of neighbor is %d  dis is %f\n",here_.addr_,num_of_neighbor,myadvance);
+     if(num_of_neighbor<=1) return true; // I only has one packet record in my hashtable
+     for(int i=0;i<num_of_neighbor;i++){     
+       position fp=neighbor_list[i].node;
+     
+       double advance=calculateMappedDistance(sp,&tp,&fp);
+       //   printf("neighbor position (%f %f %f) dis is %f\n",fp.x,fp.y,fp.z,advance);
+         if (advance>myadvance) return false;
+     }
+     return true;
+ }
+ 
+ 
+ // added by peng xie at 20071106 sp is start point and tp is the target
+ 
+ double VectorbasedVoidAvoidanceAgent::calculateMappedDistance(const position*  sp, const position* tp, const position* fp)
+ {
+ 
+   if(IsSamePosition(sp, fp)) return 0.0;
+  double fx=sp->x;
+  double fy=sp->y;
+  double fz=sp->z;
+ 
+  double dx=fp->x-fx; 
+  double dy=fp->y-fy;
+  double dz=fp->z-fz;
+ 
+   
+  double tx=tp->x;
+  double ty=tp->y;
+  double tz=tp->z; 
+ 
+  double dtx=tx-fx;
+  double dty=ty-fy;
+  double dtz=tz-fz;  
+ 
+  double dp=dx*dtx+dy*dty+dz*dtz;
+ 
+  double d=sqrt((dx*dx)+(dy*dy)+ (dz*dz));
+  double l=sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+  double cos_theta=dp/(d*l);
+ 
+     double mdis=d*cos_theta;
+       return mdis;
+ }
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsVoidNode(ns_addr_t source, int pkt_num)
+ {
+     printf("vectorbased: node(%d) is determining if it is void node\n",here_.addr_);
+ 
+     neighborhood *hashPtr= PktTable.GetHash(source, pkt_num);
+ 
+     if (!hashPtr) return true;
+ 
+     neighbornode* neighbor_list= hashPtr->neighbor; 
+     int num_of_neighbor=hashPtr->number;
+    
+     position mp,tp;
+ 
+     mp.x=node->CX();
+     mp.y=node->CY();
+     mp.z=node->CZ();
+ 
+     tp=neighbor_list[0].vec.end;
+ 
+     double mydis=distance(&tp,&mp);
+     for(int i=0;i<num_of_neighbor;i++){
+ 	position fp=neighbor_list[i].node;
+         double tmp_dis=distance(&tp, &fp);
+         if (tmp_dis<mydis) return false;
+     }
+     return true;
+ }
+ 
+ double VectorbasedVoidAvoidanceAgent::calculateSelfCenteredDelay(const position* sp,const position*  tp, const position* myp, const position* fp)
+ {
+ 
+ 
+ printf("vectorbased: node(%d) sp (%f,%f,%f) tp (%f,%f,%f) and fp(%f,%f,%f)\n",here_.addr_,sp->x,sp->y,sp->z,tp->x,tp->y,tp->z,fp->x,fp->y,fp->z);
+  double fx=fp->x;
+  double fy=fp->y;
+  double fz=fp->z;
+ 
+  double dx=myp->x-fx; 
+  double dy=myp->y-fy;
+  double dz=myp->z-fz;
+ 
+   
+  double tx=tp->x;
+  double ty=tp->y;
+  double tz=tp->z; 
+ 
+  double dtx=tx-fx;
+  double dty=ty-fy;
+  double dtz=tz-fz;  
+ 
+  double dp=dx*dtx+dy*dty+dz*dtz;
+ 
+  double p=projection(fp,tp,myp);
+  double d=sqrt((dx*dx)+(dy*dy)+ (dz*dz));
+  double l=sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+  double cos_theta=dp/(d*l);
+ 
+    double delay=(1.0-(p/width)) +((UnderwaterChannel::Transmit_distance()-d*cos_theta)/UnderwaterChannel::Transmit_distance());
+ 
+  //double delay=(1.0-(p/width));
+  
+ printf("vectorbased: node(%d) projection is %f, and cos is %f, and d is %f l is %f\n",here_.addr_,p, cos_theta, d,l);
+    if(delay<0.0) delay=0.0; // in case the location error, which may result in negative delay
+       return sqrt(delay);
+    //  return sqrt(delay)*DELAY*2.0;
+ }
+ 
+ 
+ 
+ double  VectorbasedVoidAvoidanceAgent::distance(const position* sp, const position* tp){
+  
+  double fx=sp->x;
+  double fy=sp->y;
+  double fz=sp->z;
+ 
+  double tx=tp->x;
+  double ty=tp->y;
+  double tz=tp->z; 
+ 
+  double dtx=tx-fx;
+  double dty=ty-fy;
+  double dtz=tz-fz;  
+ 
+  return sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+ }
+ 
+ double VectorbasedVoidAvoidanceAgent::calculateDelay(const position* sp,const position*  tp,
+                                                 const position* myp, const position* fp)
+ {
+ 
+  double fx=fp->x;
+  double fy=fp->y;
+  double fz=fp->z;
+ 
+  double dx=myp->x-fx; 
+  double dy=myp->y-fy;
+  double dz=myp->z-fz;
+ 
+   
+  double tx=tp->x;
+  double ty=tp->y;
+  double tz=tp->z; 
+ 
+  double dtx=tx-fx;
+  double dty=ty-fy;
+  double dtz=tz-fz;  
+ 
+  double dp=dx*dtx+dy*dty+dz*dtz;
+ 
+  double p=projection(sp,tp,myp);
+  double d=sqrt((dx*dx)+(dy*dy)+ (dz*dz));
+  double l=sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+  double cos_theta=dp/(d*l);
+ 
+    double delay=(p/width) +((UnderwaterChannel::Transmit_distance()-d*cos_theta)/UnderwaterChannel::Transmit_distance());
+  
+ // printf("vectorbased: node(%d) projection is %f, and cos is %f, and d is %f)\n",here_.addr_,p, cos_theta, d);
+    if(delay<0.0) delay=0.0; // in case the location error, which may result in negative delay
+    return delay;
+ }
+ 
+ 
+ double VectorbasedVoidAvoidanceAgent::projection(const position* sp, const position* tp,const position * p)
+ {
+ // two projection functions should be merged later
+  double tx=tp->x;
+  double ty=tp->y;
+  double tz=tp->z;
+  
+ 
+  double ox=sp->x;
+  double oy=sp->y;
+  double oz=sp->z;
+ 
+  double x=p->x;
+  double y=p->y;
+  double z=p->z;
+  
+  double wx=tx-ox;
+  double wy=ty-oy;
+  double wz=tz-oz;
+ 
+  double vx=x-ox;
+  double vy=y-oy;
+  double vz=z-oz;
+ 
+  double cross_product_x=vy*wz-vz*wy;
+  double cross_product_y=vz*wx-vx*wz;
+  double cross_product_z=vx*wy-vy*wx;
+   
+  double area=sqrt(cross_product_x*cross_product_x+ 
+           cross_product_y*cross_product_y+cross_product_z*cross_product_z);
+  double length=sqrt((tx-ox)*(tx-ox)+(ty-oy)*(ty-oy)+ (tz-oz)*(tz-oz));
+  // printf("vectorbasedvoidavoidance: the area is %f and length is %f\n",area,length);
+  return area/length;
+ }
+ 
+ 
+ void VectorbasedVoidAvoidanceAgent::calculatePosition(Packet* pkt)
+ {
+ 
+ 
+   node->CX_=node->X();
+   node->CY_=node->Y();
+   node->CZ_=node->Z();
+ 
+   /*
+  hdr_uwvbva     *vbh  = HDR_UWVBVA(pkt); 
+  double fx=vbh->info.fx;
+  double fy=vbh->info.fy;
+  double fz=vbh->info.fz;
+ 
+  double dx=vbh->info.dx;
+  double dy=vbh->info.dy;
+  double dz=vbh->info.dz;
+ 
+  node->CX_=fx+dx;
+  node->CY_=fy+dy;
+  node->CZ_=fz+dz;
+  printf("vectorbasedvoidavoidance: my position is computed as (%f,%f,%f) dx=%f dy=%f and dz=%f \n",node->CX_, node->CY_,node->CZ_,dx,dy,dz);
+   */
+ }
+ 
+ double VectorbasedVoidAvoidanceAgent::calculateDelay(Packet* pkt,position* p1)
+ {
+  
+  hdr_uwvbva     *vbh  = HDR_UWVBVA(pkt); 
+  double fx=p1->x;
+  double fy=p1->y;
+  double fz=p1->z;
+ 
+  double dx=node->CX_-fx; 
+  double dy=node->CY_-fy;
+  double dz=node->CZ_-fz;
+ 
+   
+  double tx=vbh->info.tx;
+  double ty=vbh->info.ty;
+  double tz=vbh->info.tz; 
+ 
+  double dtx=tx-fx;
+  double dty=ty-fy;
+  double dtz=tz-fz;  
+ 
+  double dp=dx*dtx+dy*dty+dz*dtz;
+ 
+  // double a=advance(pkt);
+  double p=projection(pkt);
+  double d=sqrt((dx*dx)+(dy*dy)+ (dz*dz));
+  double l=sqrt((dtx*dtx)+(dty*dty)+ (dtz*dtz));
+  double cos_theta=dp/(d*l);
+  // double delay=(TRANSMISSION_DISTANCE-d*cos_theta)/TRANSMISSION_DISTANCE;
+    double delay=(p/width) +((UnderwaterChannel::Transmit_distance()-d*cos_theta)/UnderwaterChannel::Transmit_distance());
+  // double delay=(p/width) +((TRANSMISSION_DISTANCE-d)/TRANSMISSION_DISTANCE)+(1-cos_theta);
+   //printf("vectorbased: node(%d) projection is %f, and cos is %f, and d is %f)\n",here_.addr_,p, cos_theta, d);
+    return delay;
+ }
+ 
+ 
+ double VectorbasedVoidAvoidanceAgent::distance(const Packet* pkt)
+ {
+  
+  hdr_uwvbva     *vbh  = HDR_UWVBVA(pkt); 
+  double tx=vbh->info.fx;
+  double ty=vbh->info.fy;
+  double tz=vbh->info.fz;
+  // printf("vectorbased: the target is %lf,%lf,%lf \n",tx,ty,tz);
+  double x=node->CX(); //change later
+  double y=node->CY();// printf(" Vectorbasedvoidavoidance: I am in advanced\n");
+  double z=node->CZ();
+  printf("the forwarder  is %lf,%lf,%lf and my coordinates are %lf,%lf,%lf\n",tx,ty,tz,x,y,z);
+  return sqrt((tx-x)*(tx-x)+(ty-y)*(ty-y)+ (tz-z)*(tz-z));
+ }
+ 
+ 
+ double VectorbasedVoidAvoidanceAgent::advance(Packet* pkt)
+ {
+  
+  hdr_uwvbva     *vbh  = HDR_UWVBVA(pkt); 
+  double tx=vbh->info.tx;
+  double ty=vbh->info.ty;
+  double tz=vbh->info.tz;
+  // printf("vectorbased: the target is %lf,%lf,%lf \n",tx,ty,tz);
+  double x=node->CX(); //change later
+  double y=node->CY();// printf(" Vectorbasedvoidavoidance: I am in advanced\n");
+  double z=node->CZ();
+  // printf("the target is %lf,%lf,%lf and my coordinates are %lf,%lf,%lf\n",tx,ty,tz,x,y,z);
+  return sqrt((tx-x)*(tx-x)+(ty-y)*(ty-y)+ (tz-z)*(tz-z));
+ }
+ 
+ 
+ double VectorbasedVoidAvoidanceAgent::projection(Packet* pkt)
+ {
+ 
+  hdr_uwvbva     *vbh  = HDR_UWVBVA(pkt);
+  
+  double tx=vbh->info.tx;
+  double ty=vbh->info.ty;
+  double tz=vbh->info.tz;
+  
+ 
+  double ox=vbh->info.ox;
+  double oy=vbh->info.oy;
+  double oz=vbh->info.oz;
+  
+ 
+  double x=node->CX();
+  double y=node->CY();
+  double z=node->CZ();
+  
+  double wx=tx-ox;
+  double wy=ty-oy;
+  double wz=tz-oz;
+ 
+  double vx=x-ox;
+  double vy=y-oy;
+  double vz=z-oz;
+ 
+  double cross_product_x=vy*wz-vz*wy;
+  double cross_product_y=vz*wx-vx*wz;
+  double cross_product_z=vx*wy-vy*wx;
+   
+  double area=sqrt(cross_product_x*cross_product_x+ 
+           cross_product_y*cross_product_y+cross_product_z*cross_product_z);
+  double length=sqrt((tx-ox)*(tx-ox)+(ty-oy)*(ty-oy)+ (tz-oz)*(tz-oz));
+  return area/length;
+ }
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsTarget(Packet* pkt)
+ {
+   hdr_uwvbva * vbh=HDR_UWVBVA(pkt);
+ 
+   if (vbh->target_id.addr_==0){
+ 
+   //  printf("vectorbased: advanced is %lf and my range is %f\n",advance(pkt),vbh->range);
+     return (advance(pkt)<vbh->range);
+ }
+   else return(THIS_NODE.addr_==vbh->target_id.addr_);
+ 
+ 
+ }
+ 
+ 
+ 
+ bool VectorbasedVoidAvoidanceAgent::IsCloseEnough(Packet* pkt)
+ {
+   hdr_uwvbva     *vbh  = HDR_UWVBVA(pkt);
+   double range=vbh->range;
+ 
+  
+   position sp, tp,p;
+ 
+  
+   sp.x=vbh->info.ox;
+   sp.y=vbh->info.oy;
+   sp.z=vbh->info.oz;
+   
+   tp.x=vbh->info.tx;
+   tp.y=vbh->info.ty;
+   tp.z=vbh->info.tz;
+ 
+   p.x=node->CX();
+   p.y=node->CY();
+   p.z=node->CZ();
+ 
+   printf ("vectorbasedvoidavoidance(%d): The projection is %f\n ",here_.addr_,projection(&sp,&tp,&p));  
+  if ((projection(&sp,&tp,&p)<=width))  return true;
+  return false;
+ 
+ }
+ 
+ 
+ int VectorbasedVoidAvoidanceAgent::command(int argc, const char*const* argv)
+ {  
+   Tcl& tcl =  Tcl::instance();
+ 
+   if (argc == 2) {
+ 
+     if (strcasecmp(argv[1], "reset-state")==0) {
+       
+       reset();
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "reset")==0) {
+       
+       return Agent::command(argc, argv);
+     }
+ 
+     if (strcasecmp(argv[1], "start")==0) {
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "stop")==0) {
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "terminate")==0) {
+       Terminate();
+       return TCL_OK;
+     }
+ 
+    if (strcasecmp(argv[1], "name")==0) {
+      printf("vectorbased \n");
+       return TCL_OK;
+     }
+    // if (strcasecmp(argv[1], "stop-source")==0) {
+    // StopSource();
+    // return TCL_OK;
+    // }
+ 
+   } else if (argc == 3) {
+ 
+     if (strcasecmp(argv[1], "on-node")==0) {
+       //   printf ("inside on node\n");
+       node = (UnderwaterSensorNode *)tcl.lookup(argv[2]);
+       return TCL_OK;
+     }
+     /*
+       if (strcasecmp(argv[1], "set-port")==0) {
+       printf ("inside on node\n");
+       port_number=atoi(argv[2]);
+       return TCL_OK;
+     }
+     */
+     if (strcasecmp(argv[1], "add-ll") == 0) {
+ 
+       TclObject *obj;
+ 
+       if ( (obj = TclObject::lookup(argv[2])) == 0) {
+     fprintf(stderr, "Vectorbasedvoidavoidanceing Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 	return TCL_ERROR;
+       }
+       ll = (NsObject *) obj;
+ 
+      return TCL_OK;
+     }
+ 
+     if (strcasecmp (argv[1], "tracetarget") == 0) {
+       TclObject *obj;
+       if ((obj = TclObject::lookup (argv[2])) == 0) {
+ 	  fprintf (stderr, "%s: %s lookup of %s failed\n", __FILE__, argv[1],
+ 		   argv[2]);
+ 	  return TCL_ERROR;
+       }
+ 
+       tracetarget = (Trace *) obj;
+       return TCL_OK;
+     }
+ 
+     if (strcasecmp(argv[1], "port-dmux") == 0) {
+       // printf("vectorbasedvoidavoidance:port demux is called \n");
+       TclObject *obj;
+ 
+       if ( (obj = TclObject::lookup(argv[2])) == 0) {
+ 	fprintf(stderr, "VB node Node: %d lookup of %s failed\n", THIS_NODE.addr_, argv[2]);
+ 	return TCL_ERROR;
+       }
+       port_dmux = (NsObject *) obj;
+       return TCL_OK;
+     }
+ 
+   } 
+ 
+   return Agent::command(argc, argv);
+ }
+ 
diff -crBN ns-2.35/underwatersensor/uw_routing/vectorbasedvoidavoidance.h ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedvoidavoidance.h
*** ns-2.35/underwatersensor/uw_routing/vectorbasedvoidavoidance.h	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_routing/vectorbasedvoidavoidance.h	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,315 ----
+ #ifndef ns_vectorbasedvoidavoidance_h
+ #define ns_vectorbasedvoidavoidance_h
+ 
+ #include <assert.h>
+ #include <math.h>
+ #include <stdio.h>
+ //#include <signal.h>
+ //#include <float.h>
+ #include <stdlib.h>
+ 
+ #include <tcl.h>
+ 
+ #include "agent.h"
+ #include "tclcl.h"
+ #include "config.h"
+ #include "packet.h"
+ #include "trace.h"
+ #include "random.h"
+ #include "classifier.h"
+ #include "underwatersensor/uw_common/underwatersensornode.h"
+ #include "arp.h"
+ #include "mac.h"
+ #include "ll.h"
+ #include "dsr/path.h"
+ #include "uw_routing_buffer.h"
+ #include "uw_datastructure.h"
+ 
+ typedef struct Neighbornode{
+       routing_vector    vec;
+       position node;   
+       unsigned int forwarder_id;
+       unsigned int status;
+  
+ } neighbornode;
+ 
+ 
+ typedef struct Neighborhood{
+   int number;
+   neighbornode  neighbor[MAX_NEIGHBOR];
+ } neighborhood;
+ 
+ 
+ // the same as hdr_uwvb, just for isolation
+ struct hdr_uwvbva{
+ 	unsigned int mess_type;
+ 	unsigned int pk_num;
+         ns_addr_t target_id; // the target id  of this data 
+         ns_addr_t sender_id;  //original sender id
+          // nsaddr_t next_nodes[MAX_NEIGHBORS];
+         //int      num_next;
+         unsigned int data_type;
+         ns_addr_t forward_agent_id;// the forwarder id
+ 
+        struct uw_extra_info info;
+        position original_source;
+     //  double token;
+   	double ts_;                       // Timestamp when pkt is generated.
+         double range;    // target range
+ 	static int offset_;
+   	inline static int& offset() { return offset_; }
+   	inline static hdr_uwvbva* access(const Packet*  p) {
+ 		return (hdr_uwvbva*) p->access(offset_);
+ 	}
+ };
+ 
+ 
+ class UWVBVAPkt_Hash_Table {
+  public:
+   Tcl_HashTable htable;
+ 
+   UWVBVAPkt_Hash_Table() {
+     window_size=WINDOW_SIZE;
+     Tcl_InitHashTable(&htable, 3);
+   }
+ 
+   int  window_size;
+   void reset();
+   void delete_hash(hdr_uwvbva*); //delete the enrty that has the same key as the new packet
+   void delete_hash(ns_addr_t, unsigned); 
+ 
+   void MarkNextHopStatus(ns_addr_t, unsigned int,unsigned int, unsigned int);
+ 
+   void put_in_hash(hdr_uwvbva *);
+   void put_in_hash(hdr_uwvbva *, const position *, const position*, const position*, unsigned int=FRESHED);
+   neighborhood* GetHash(ns_addr_t sender_id, unsigned int pkt_num);
+ };
+ 
+ 
+ class UWVBVAData_Hash_Table {
+  public:
+   Tcl_HashTable htable;
+ 
+   UWVBVAData_Hash_Table() {
+     Tcl_InitHashTable(&htable, MAX_ATTRIBUTE);
+   }
+ 
+   void reset();
+   void delete_hash(ns_addr_t, unsigned int);
+   void put_in_hash(ns_addr_t, unsigned int,unsigned int);
+   unsigned int  *GetHash(ns_addr_t, unsigned int);
+ };
+ 
+ 
+ 
+ class VectorbasedVoidAvoidanceAgent;
+ 
+ class UWDelayHandler: public Handler{
+ public:
+ UWDelayHandler(VectorbasedVoidAvoidanceAgent * a):Handler(){a_=a;}
+ void handle(Event* e);
+ protected :
+   VectorbasedVoidAvoidanceAgent * a_;
+   
+ };
+ 
+ class UWVoidAvoidHandler: public Handler{
+ public:
+ UWVoidAvoidHandler(VectorbasedVoidAvoidanceAgent * a):Handler(){a_=a;}
+ void handle(Event* e);
+ protected :
+   VectorbasedVoidAvoidanceAgent * a_;
+ };
+ 
+ 
+ // no use right now
+ /*
+ class UWFloodingHandler: public Handler{
+ public:
+ UWFloodingHandler(VectorbasedforwardAgent * a):Handler(){a_=a;}
+  void handle(Event*);
+ protected :
+   VectorbasedforwardAgent * a_;
+ };
+ */
+ 
+ 
+ class UWFloodingBackwardHandler: public Handler{
+ public:
+ UWFloodingBackwardHandler(VectorbasedVoidAvoidanceAgent * a):Handler(){a_=a;}
+  void handle(Event*);
+ protected :
+   VectorbasedVoidAvoidanceAgent * a_;
+ };
+ 
+ 
+ class UWFloodingForwardHandler: public Handler{
+ public:
+ UWFloodingForwardHandler(VectorbasedVoidAvoidanceAgent * a):Handler(){a_=a;}
+  void handle(Event*);
+ protected :
+   VectorbasedVoidAvoidanceAgent * a_;
+ };
+ 
+ 
+ // no use right now
+ /*
+ class UWBackwardFloodingPacketHandler: public Handler{
+ public:
+ UWBackwardFloodingPacketHandler(VectorbasedforwardAgent * a):Handler(){a_=a;}
+  void handle(Event*);
+ protected :
+   VectorbasedforwardAgent * a_;
+ };
+ */
+ 
+ 
+ 
+ class VectorbasedVoidAvoidanceAgent : public Agent {
+  public:
+   VectorbasedVoidAvoidanceAgent();
+   int command(int argc, const char*const* argv);
+   void recv(Packet*, Handler*);
+ 
+   // Vectorbasedforward_Entry routing_table[MAX_DATA_TYPE];
+ 
+  protected:
+   double position_update_time;
+   int pk_count;
+   int counter;
+   double priority;
+   const double mini_distance;// distance used for flooding packet delay
+   const double mini_threshold;// desirablenss used for normal data packet delay
+   bool measureStatus;  //?? where do I use this?
+   int control_packet_size;
+  
+   // int port_number;
+   UWVBVAPkt_Hash_Table PktTable;
+   UWVBVAPkt_Hash_Table SourceTable;
+   UWVBVAPkt_Hash_Table Target_discoveryTable;
+   UWVBVAPkt_Hash_Table SinkTable;
+ 
+   UWVBVAData_Hash_Table PacketStatusTable;
+ 
+ 
+  
+   //delete later 
+   UWVBVAPkt_Hash_Table CenterPktTable;
+   UWVBVAPkt_Hash_Table DataTerminationPktTable; 
+ 
+   UWDelayHandler forward_delay_handler; 
+   UWVoidAvoidHandler void_avoidance_handler;
+   //  UWFloodingHandler  flooding_handler;// no use right now 
+   UWFloodingForwardHandler self_centered_forward_handler;
+   UWFloodingBackwardHandler backpressure_handler;
+   //UWBackwardFloodingPacketHandler backwardflooding_packet_handler;// no use right now
+   
+   RoutingBuffer void_avoidance_buffer;
+   //  RoutingBuffer receiving_buffer;
+   
+   UnderwaterSensorNode *node;
+   Trace *tracetarget;       // Trace Target
+   NsObject *ll;  
+   NsObject *port_dmux;
+   double width; 
+ // the width is used to test if the node is close enough to the path specified by the packet  
+   
+ 
+    inline void send_to_dmux(Packet *pkt, Handler *h) { 
+     port_dmux->recv(pkt, h); 
+   }
+ 
+   void Terminate();
+   void reset();
+   void ConsiderNew(Packet*);
+ 
+   void setForwardDelayTimer(Packet*,double);
+   //void set_shift_timer(ns_addr_t,int,double);
+   void set_shift_timer(Packet*,double);
+   // void set_flooding_timer(ns_addr_t,int,double);
+ //  void set_flooding_forward_timer(Packet*, double);
+ 
+  
+   void recordPacket(hdr_uwvbva*, unsigned int=FRESHED);
+   //  void recordPacket(hdr_uwvb*);
+   void process_flooding_timeout(Packet*);// no use right now 
+   void process_selfcentered_timeout(Packet*);
+   void process_void_avoidance_timeout(Packet*);
+   void process_backpressure_timeout(Packet*);
+   void process_void_avoidance_timeout(ns_addr_t,position*,position*,int);
+   void process_forward_timeout(Packet*);
+   void process_backwardflooding_packet_timeout(Packet*);// no use right
+ 
+   //void processFloodingPacket(Packet*);
+ 
+   void processBackpressurePacket(Packet*);
+   void processCenteredPacket(Packet*);
+   void processBackFloodedPacket(Packet*);
+  
+   void makeCopy(Packet*);
+   void sendFloodingPacket(Packet*); // delete this function later
+   // void sendVectorShiftPacket(ns_addr_t, int);
+   void sendDataTermination(const Packet*);
+ 
+   double advance(Packet *);
+   double distance(const Packet *);
+   double distance(const position*, const position*);
+ 
+   double projection(Packet*);
+   double projection(const position*, const position*, const position *);
+   double calculateMappedDistance(const position*, const position*, const position*);
+   double calculateDelay(Packet*, position*);
+   double calculateDelay(const position*,const position*,const position*, const position*);
+ 
+   double calculateSelfCenteredDelay(const position*,const position*, const position*, const position*);
+ 
+   double calculateFloodingDesirableness(const Packet*);// no use right now
+   double calculateDesirableness(const Packet*);
+   double calculateBackFloodDelay(const position*,const position*, const position*, const position*);// no use right now
+ 
+   Packet* generateVectorShiftPacket(const ns_addr_t*, int,const position*, const position*);
+ 
+  Packet* generateControlDataPacket(Packet*,unsigned int);
+   //  Packet* generateBackpressurePacket(const ns_addr_t*,int);
+   Packet* generateBackpressurePacket(Packet*);
+   void calculatePosition(Packet*);
+   void setMeasureTimer(Packet*,double);
+ 
+   bool IsStuckNode(const neighbornode*,const position*,int,unsigned int);
+   bool IsWorthFloodingForward(ns_addr_t,int);// useless??
+   //bool IsWorthFloodingForward(ns_addr_t,int);
+   bool IsVoidNode(ns_addr_t,int,const position*);
+   bool IsUpstreamNode(const position&,const position&, const position&);
+   bool IsVoidNode(ns_addr_t,int);
+   bool IsEndNode(ns_addr_t,int);
+   bool IsNewlyTouchedNode(ns_addr_t, unsigned int);
+   bool IsTarget(Packet*);
+   bool IsCloseEnough(Packet*);
+   bool IsSamePosition(const position*, const position*);
+   bool IsControlMessage(const Packet*);
+  
+ //  Packet *create_packet();
+ //  Packet *prepare_message(unsigned int dtype, ns_addr_t to_addr, int msg_type);
+ 
+   
+   void DataForSink(Packet *pkt);
+   // void StopSource();
+   void MACprepare(Packet *pkt);
+   void MACsend(Packet *pkt, Time delay=0);
+ 
+   void trace(char *fmt,...);
+   friend class UWDelayHandler;
+ 
+   friend class UWVoidAvoidHandler;
+   // friend class UWFloodingHandler;
+   friend class UWFloodingForwardHandler;
+   friend class UWFloodingBackwardHandler;
+ };
+ 
+ 
+ 
+ #endif
+ 
+ 
+ 
+ 
diff -crBN ns-2.35/underwatersensor/uw_tcl/broadcastMAC_example.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/broadcastMAC_example.tcl
*** ns-2.35/underwatersensor/uw_tcl/broadcastMAC_example.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/broadcastMAC_example.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,259 ----
+ set opt(chan)		Channel/UnderwaterChannel
+ set opt(prop)		Propagation/UnderwaterPropagation
+ set opt(netif)		Phy/UnderwaterPhy
+ set opt(mac)		Mac/UnderwaterMac/BroadcastMac
+ set opt(ifq)		Queue/DropTail
+ set opt(ll)		LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        1
+ set opt(rxpower)        1
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ 
+ set opt(dz)             10
+ set opt(ifqlen)		50	;# max packet in ifq
+ set opt(nn)		4	;# number of nodes in each layer
+ set opt(layers)         1
+ set opt(x)		100	;# X dimension of the topography
+ set opt(y)	        100  ;# Y dimension of the topography
+ set opt(z)              [expr ($opt(layers)-1)*$opt(dz)]
+ set opt(datarate)       0.1
+ set opt(seed)		0        ;# random seed
+ set opt(stop)		600	;# simulation time
+ set opt(prestop)        20     ;# time to prepare to stop
+ set opt(tr)		"broadcastmac.tr"	;# trace file
+ set opt(nam)            "broadcastmac.nam"  ;# nam file
+ set opt(datafile)	 "broadcastmac.data";# data file
+ set opt(adhocRouting)   Vectorbasedforward
+ set opt(width)           20
+ set opt(adj)             10
+ set opt(interval)        0.001
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ #Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ 
+ 
+ Mac/UnderwaterMac set bit_rate_  1.0e4
+ Mac/UnderwaterMac set encoding_efficiency_  1
+ Mac/UnderwaterMac/BroadcastMac set packet_size_  568
+ 
+ 
+ 
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 10  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ 
+ 
+ remove-all-packet-headers 
+ #remove-packet-header AODV ARP TORA  IMEP TFRC
+ add-packet-header IP Mac LL  ARP  UWVB RMAC
+ 
+ 
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ $ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ set data [open $opt(datafile) a]
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ $ns_ at 0.0 "$god_  set_filename $opt(datafile)"
+ 
+ 
+ global defaultRNG
+ $defaultRNG seed $opt(seed)
+ 
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace OFF \
+                  -routerTrace OFF \
+                  -macTrace OFF\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txPower $opt(txpower)\
+                  -rxPower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+ 
+ 
+ set node_(0) [$ns_  node 0]
+ $node_(0) set sinkStatus_ 1
+ $node_(0) set passive 1
+     
+ $god_ new_node $node_(0)
+ $node_(0) set X_  0
+ $node_(0) set Y_  0
+ $node_(0) set Z_   0.0
+ $node_(0) set passive 1
+ set a_(0) [new Agent/UWSink]
+ $ns_ attach-agent $node_(0) $a_(0)
+ $a_(0) attach-vectorbasedforward $opt(width)
+ $a_(0) cmd set-range 20
+ $a_(0) cmd set-target-x -20
+ $a_(0) cmd set-target-y -10
+ $a_(0) cmd set-target-z -20
+ $a_(0) cmd set-filename $opt(datafile)
+ 
+ 
+ set node_(1) [$ns_  node 1]
+ $node_(1) set sinkStatus_ 1
+ $god_ new_node $node_(1)
+ $node_(1) set X_  -80
+ $node_(1) set Y_   0
+ $node_(1) set Z_   0
+ $node_(1) set-cx  -80
+ $node_(1) set-cy  0
+ $node_(1) set-cz  0
+ $node_(1) set_next_hop 0 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(1) [new Agent/UWSink]
+ $ns_ attach-agent $node_(1) $a_(1)
+ $a_(1) attach-vectorbasedforward $opt(width)
+  $a_(1) cmd set-range 20
+  $a_(1) cmd set-target-x   0
+  $a_(1) cmd set-target-y   0
+  $a_(1) cmd set-target-z   0
+  $a_(1) set data_rate_ $opt(datarate)
+ $a_(1) cmd set-filename $opt(datafile)
+ 
+ 
+ set node_(2) [$ns_  node 2]
+ $node_(2) set sinkStatus_ 1
+ $god_ new_node $node_(2)
+ $node_(2) set X_  80
+ $node_(2) set Y_  0
+ $node_(2) set Z_   0
+ $node_(2) set-cx  80
+ $node_(2) set-cy  0
+ $node_(2) set-cz  0
+ $node_(2) set_next_hop 0 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(2) [new Agent/UWSink]
+ $ns_ attach-agent $node_(2) $a_(2)
+ $a_(2) attach-vectorbasedforward $opt(width)
+  $a_(2) cmd set-range 20
+  $a_(2) cmd set-target-x   0
+  $a_(2) cmd set-target-y   0
+  $a_(2) cmd set-target-z   0
+  $a_(2) set data_rate_ $opt(datarate)
+ $a_(2) cmd set-filename $opt(datafile)
+ 
+ #puts "the total number is $total_number"
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ $node_($total_number) set X_  0
+ $node_($total_number) set Y_  50
+ $node_($total_number) set Z_  0
+ $node_($total_number) set-cx  0
+ $node_($total_number) set-cy  40
+ $node_($total_number) set-cz  0
+ $node_($total_number) set_next_hop 0 ;# target is node 0 
+ 
+ set a_($total_number) [new Agent/UWSink]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $a_($total_number) attach-vectorbasedforward $opt(width)
+  $a_($total_number) cmd set-range 20
+  $a_($total_number) cmd set-target-x 0
+  $a_($total_number) cmd set-target-y 0
+  $a_($total_number) cmd set-target-z 0
+  $a_($total_number) set data_rate_ $opt(datarate)
+  $a_($total_number) cmd set-filename $opt(datafile)
+ 
+ 
+ 
+ 
+ #set max_num [expr $total_number -1]
+ 
+ 
+ 
+ #$ns_ at 15 "$a_($total_number) cbr-start"
+ $ns_ at 20 "$a_($total_number) exp-start"
+ $ns_ at 20 "$a_(1) exp-start"
+ $ns_ at 20 "$a_(2) exp-start"
+ #$ns_ at 20 "$a_(2) cbr-start"
+ 
+ #$ns_ at 4 "$a_(0) cbr-start"
+ #$ns_ at 2.0003 "$a_(2) cbr-start"
+ 
+ #$ns_ at 0.1 "$a_(0) announce"
+ 
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ 
+ 
+ 
+ $ns_ at $opt(stop).001 "$a_(0) terminate"
+ $ns_ at $opt(stop).002 "$a_($total_number) terminate"
+ $ns_ at $opt(stop).003 "$a_(1) terminate"
+ $ns_ at $opt(stop).004 "$a_(2) terminate"
+ #$ns_ at $opt(stop).002 "$a_(3) terminate"
+ 
+ 
+ $ns_ at $opt(stop).05  "$god_ compute_energy"
+ $ns_ at $opt(stop).05  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).05 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "vectorbased"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+ 
+  puts  $data  "New simulation...."
+  close $data
+ 
+  $ns_ run
diff -crBN ns-2.35/underwatersensor/uw_tcl/hop_by_hop_VBF_example.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/hop_by_hop_VBF_example.tcl
*** ns-2.35/underwatersensor/uw_tcl/hop_by_hop_VBF_example.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/hop_by_hop_VBF_example.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,247 ----
+ set opt(chan)		Channel/UnderwaterChannel
+ set opt(prop)		Propagation/UnderwaterPropagation
+ set opt(netif)		Phy/UnderwaterPhy
+ set opt(mac)		Mac/UnderwaterMac/BroadcastMac
+ set opt(ifq)		Queue/DropTail/PriQueue
+ set opt(ll)		LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        1.0
+ set opt(rxpower)        0.2
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.0001
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ 
+ 
+ 
+ set opt(maxspeed)            20
+ set opt(minspeed)            10
+ set opt(speed)               5
+ set opt(position_update_interval) 0.2
+ 
+ set opt(ifqlen)		50	;# max packet in ifq
+ set opt(nn)		4	;# number of nodes in each layer
+ set opt(x)		100	;# X dimension of the topography
+ set opt(y)	        100  ;# Y dimension of the topography
+ set opt(z)              100
+ set opt(seed)		1.88
+ set opt(stop)		100	;# simulation time
+ set opt(prestop)        90    ;# time to prepare to stop
+ set opt(tr)		"hop_hop_vbf.tr"	;# trace file
+ set opt(nam)            "hop_hop_vbf.nam"  ;# nam file
+ set opt(adhocRouting)   Vectorbasedforward
+ set opt(width)           20
+ set opt(adj)             10
+ set opt(interval)        0.001
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ #set the mode of Vectorbasedforward as hop by hop
+ Agent/Vectorbasedforward set hop_by_hop_ 1
+ 
+ Mac/UnderwaterMac set bit_rate_  1.0e4  ;#10kbps
+ Mac/UnderwaterMac set encoding_efficiency_  1
+ Mac/UnderwaterMac/BroadcastMac set packet_size_  400 ;# bits 
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 10  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ $ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y) 
+ 
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ global defaultRNG
+ $defaultRNG seed $opt(seed)
+ 
+ 
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace ON \
+                  -routerTrace OFF \
+                  -macTrace ON\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txPower $opt(txpower)\
+                  -rxPower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+                  
+ 
+ set node_(0) [$ns_  node 0]
+ #puts "after create underwater sensor node\n"
+ $node_(0) set sinkStatus_ 1
+ $god_ new_node $node_(0)
+ $node_(0) set X_  0
+ $node_(0) set Y_  0
+ $node_(0) set Z_   0.0
+ $node_(0) set passive 1
+ set a_(0) [new Agent/UWSink]
+ $ns_ attach-agent $node_(0) $a_(0)
+ $a_(0) attach-vectorbasedforward $opt(width)
+  $a_(0) cmd set-range 20
+  $a_(0) cmd set-target-x -20
+  $a_(0) cmd set-target-y -10
+  $a_(0) cmd set-target-z -20
+ 
+ 
+ set node_(1) [$ns_  node 1]
+ $node_(1) set sinkStatus_ 1
+ $god_ new_node $node_(1)
+ $node_(1) set X_  60
+ $node_(1) set Y_  5
+ $node_(1) set Z_   0
+ $node_(1) set-cx  60
+ $node_(1) set-cy  5
+ $node_(1) set-cz  0
+ 
+ # make  node 1 to fail
+ $node_(1) set-failure_status 1 
+ set a_(1) [new Agent/UWSink]
+ $ns_ attach-agent $node_(1) $a_(1)
+ $a_(1) attach-vectorbasedforward $opt(width)
+  $a_(1) cmd set-range 20
+  $a_(1) cmd set-target-x   0
+  $a_(1) cmd set-target-y   0
+  $a_(1) cmd set-target-z   0
+  $a_(1) set interval_ 4
+ 
+ 
+ 
+ 
+ set node_(2) [$ns_  node 2]
+ $node_(2) set sinkStatus_ 1
+ $god_ new_node $node_(2)
+ $node_(2) set X_  20
+ $node_(2) set Y_  10
+ $node_(2) set Z_  0
+ $node_(2) set-cx  20
+ $node_(2) set-cy  10
+ $node_(2) set-cz  0
+ #$node_(2) set passive 1
+ set a_(2) [new Agent/UWSink]
+ $ns_ attach-agent $node_(2) $a_(2)
+ $a_(2) attach-vectorbasedforward $opt(width)
+  $a_(2) cmd set-range 20
+  $a_(2) cmd set-target-x   0
+  $a_(2) cmd set-target-y   0
+  $a_(2) cmd set-target-z   0
+  $a_(2) set interval_ 4
+ 
+ 
+ 
+ 
+ 
+ #puts "the total number is $total_number"
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ $node_($total_number) set X_  -20
+ $node_($total_number) set Y_  10
+ $node_($total_number) set Z_  0
+ $node_($total_number) set-cx  -20
+ $node_($total_number) set-cy  10
+ $node_($total_number) set-cz  0
+ 
+ 
+ set a_($total_number) [new Agent/UWSink]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $a_($total_number) attach-vectorbasedforward $opt(width)
+  $a_($total_number) cmd set-range 20
+  $a_($total_number) cmd set-target-x 0
+  $a_($total_number) cmd set-target-y 0
+  $a_($total_number) cmd set-target-z 0
+  $a_($total_number) set interval_ 4
+ 
+ 
+ 
+ # make node 2  mobile
+ 
+ $node_($total_number) set max_speed $opt(maxspeed)
+ $node_($total_number) set min_speed $opt(minspeed)
+ 
+ $node_($total_number) set position_update_interval_ $opt(position_update_interval)
+ $ns_  at 1.2 "$node_($total_number) move"
+ 
+ 
+ $ns_ at 2 "$a_($total_number) cbr-start"
+ $ns_ at 2 "$a_(2) cbr-start"
+ #$ns_ at 2.0003 "$a_(2) cbr-start"
+ 
+ #$ns_ at 0.1 "$a_(0) announce"
+ 
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ 
+ 
+ 
+ $ns_ at $opt(stop).001 "$a_(0) terminate"
+ $ns_ at $opt(stop).001 "$a_(2) terminate"
+ $ns_ at $opt(stop).002 "$a_($total_number) terminate"
+ 
+ 
+ 
+ 
+ $ns_ at $opt(stop).003  "$god_ compute_energy"
+ $ns_ at $opt(stop).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "vectorbased"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+  $ns_ run
diff -crBN ns-2.35/underwatersensor/uw_tcl/kinematic.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/kinematic.tcl
*** ns-2.35/underwatersensor/uw_tcl/kinematic.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/kinematic.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,252 ----
+ #$0 pkt interval; $1 bandwidth; $2 pkt length of cbr;  $3 stop time; $4 number of hops
+ set opt(chan)			Channel/UnderwaterChannel
+ set opt(prop)			Propagation/UnderwaterPropagation
+ set opt(netif)			Phy/UnderwaterPhy
+ set opt(mac)			Mac/UnderwaterMac/BroadcastMac
+ set opt(ifq)			Queue/DropTail
+ set opt(ll)				LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        0.6
+ set opt(rxpower)        0.3
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.01
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ 
+ set opt(max_pkts)		300
+ set opt(interval_)	          0.2 ;# [lindex $argv 0] 
+ set opt(pkt_len)	          80;  #[lindex $argv 2] ;# pkt length of cbr
+ 
+ # the following parameters are set fot protocols
+ set opt(bit_rate)                         5.0e3 ;#[lindex $argv 1];#1.0e4    ;#bandwidth of the phy link
+ set opt(encoding_efficiency)          1
+ set opt(ND_window)                    1
+ set opt(ACKND_window)                 1
+ set opt(PhaseOne_window)              3
+ set opt(PhaseTwo_window)              1
+ set opt(PhaseTwo_interval)            0.5
+ set opt(IntervalPhase2Phase3)         1 
+ set opt(duration)                     0.1
+ set opt(PhyOverhead)                  8 
+ set opt(large_packet_size)            480 ;# 60 bytes
+ set opt(short_packet_size)            40  ;# 5 bytes
+ set opt(PhaseOne_cycle)               4 ;
+ set opt(PhaseTwo_cycle)               2 ;
+ set opt(PeriodInterval)               2
+ set opt(transmission_time_error)      0.0001; 
+ 
+ set opt(dz)                           	10
+ set opt(hop)				       7 ;#	[lindex $argv 4]
+ set opt(ifqlen)		              50	;# max packet in ifq
+ set opt(nn)	                		[expr $opt(hop)+1] ;#5	;# number of nodes in the network
+ set opt(layers)                         	1
+ set opt(x)	                		300	;# X dimension of the topography
+ set opt(y)	                        	300  ;# Y dimension of the topography
+ set opt(z)                      		10
+ set opt(seed)	                		648.88
+ set opt(stop)	                		1000 ;#[lindex $argv 3] ;#150	;# simulation time
+ set opt(prestop)                       	80     ;# time to prepare to stop
+ set opt(tr)	                		"kinematic.tr"	;# trace file
+ set opt(nam)                            	"kinematic.nam"  ;# nam file
+ set opt(adhocRouting)                 	Vectorbasedforward 
+ set opt(width)                           	20
+ set opt(adj)                             	10
+ set opt(interval)                        	0.001
+ 
+ set start_time				10
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ #Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ 
+ 
+ Mac/UnderwaterMac set bit_rate_  $opt(bit_rate)
+ Mac/UnderwaterMac set encoding_efficiency_  $opt(encoding_efficiency)
+ #Mac/UnderwaterMac/AlohaOverhear set  MaxResendInterval_ 0.2
+ #Mac/UnderwaterMac/AlohaOverhear set  DeltaDelay_ 1
+ 
+ 
+ Node/MobileNode/UnderwaterSensorNode set position_update_interval_ 1.0
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 100  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ 
+ 
+ #remove-all-packet-headers 
+ 
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ #$ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ global defaultRNG
+ 
+ $defaultRNG seed $opt(seed)
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace ON \
+          -routerTrace ON \
+          -macTrace ON \
+          -movementTrace ON \
+          -topoInstance $topo\
+          -energyModel $opt(energy)\
+          -txpower $opt(txpower)\
+          -rxpower $opt(rxpower)\
+          -initialEnergy $opt(initialenergy)\
+          -idlePower $opt(idlepower)\
+          -channel $chan_1_
+ 
+ 
+ set node_(0) [$ns_  node 0]
+ #$node_(0) set sinkStatus_ 1
+ #$node_(0) set passive 1
+     
+ $god_ new_node $node_(0)
+ $node_(0) set X_  5
+ $node_(0) set Y_  5
+ $node_(0) set Z_  0.0
+ $node_(0) set passive 1
+ set a_(0) [new Agent/Null]
+ $node_(0) set-mobilitypattern kinematic
+ $ns_ attach-agent $node_(0) $a_(0)
+ 
+ 
+ 
+ for {set i 1} {$i<$total_number} {incr i} {
+ 
+ set node_($i) [$ns_  node $i]
+ $node_($i) set sinkStatus_ 1
+ $god_ new_node $node_($i)
+ $node_($i) set X_  [expr $i*20]
+ $node_($i) set Y_  [expr $i*20]
+ $node_($i) set Z_  0.0
+ $node_($i) set-cx   50
+ $node_($i) set-cy   50
+ $node_($i) set-cz   0
+ $node_($i) set_next_hop [expr $i-1] ;# target is node 0 
+ $node_($i) set-mobilitypattern  kinematic
+ 
+ }
+ 
+ 
+ 
+ #puts "the total number is $total_number"
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ $node_($total_number) set X_  [expr $total_number*20]
+ $node_($total_number) set Y_  [expr $total_number*20]
+ $node_($total_number) set Z_  0.0
+ $node_($total_number) set-cx  50
+ $node_($total_number) set-cy  50
+ $node_($total_number) set-cz  0
+ $node_($total_number) set_next_hop  [expr $total_number-1] ;# target is node 0 
+ $node_($total_number) set-mobilitypattern  kinematic
+ 
+ set a_($total_number) [new Agent/UDP]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $ns_ connect $a_($total_number) $a_(0)
+ 
+ set cbr_(0) [new Application/Traffic/CBR]
+ $cbr_(0) set packetSize $opt(pkt_len)   ;#80
+ $cbr_(0) set interval_ $opt(interval_)
+ $cbr_(0) set random 1
+ $cbr_(0) set maxpkts_  $opt(max_pkts)
+ $cbr_(0) attach-agent $a_($total_number)
+ 
+ 
+ 
+ for {set i 0} { $i < $opt(nn)} {incr i} {
+   $ns_ initial_node_pos $node_($i) 2
+   $node_($i) setPositionUpdateInterval 0.01
+   $node_($i) random-motion 0
+   $ns_ at 5.0 "$node_($i) start-mobility-pattern"
+ }
+ 
+ 
+ $ns_ at $start_time "$cbr_(0) start"
+ 
+ 
+ #$ns_ at 15 "$a_($total_number) cbr-start"
+ #$ns_ at $start_time "$a_($total_number) exp-start"
+ #$ns_ at 4 "$a_(0) cbr-start"
+ #$ns_ at 2.0003 "$a_(2) cbr-start"
+ #$ns_ at 0.1 "$a_(0) announce"
+ 
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ 
+ 
+ 
+ ;#$ns_ at $opt(stop).001 "$a_(0) terminate"
+ 
+ 
+ ;#$ns_ at $opt(stop).002 "$a_($total_number) terminate"
+ 
+ for {set i 1} {$i<$total_number} {incr i} {
+ #;$ns_ at $opt(stop).002 "$a_($i) terminate"
+ 	$ns_ at $opt(stop).002 "$node_($i) reset"
+ }
+ 
+ $ns_ at $opt(stop).003  "$god_ compute_energy"
+ $ns_ at $opt(stop).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "vectorbased"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+  $ns_ run
+  
diff -crBN ns-2.35/underwatersensor/uw_tcl/rmac-example.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/rmac-example.tcl
*** ns-2.35/underwatersensor/uw_tcl/rmac-example.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/rmac-example.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,316 ----
+ set opt(chan)		Channel/UnderwaterChannel
+ set opt(prop)		Propagation/UnderwaterPropagation
+ set opt(netif)		Phy/UnderwaterPhy
+ set opt(mac)		Mac/UnderwaterMac/RMac
+ set opt(ifq)		Queue/DropTail/PriQueue
+ set opt(ll)		LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        0.6
+ set opt(rxpower)        0.3
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.01
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ 
+ 
+ 
+ # the following parameters are set fot protocols
+ set opt(bit_rate)                     1.0e4
+ set opt(encoding_efficiency)          1
+ set opt(ND_window)                    1
+ set opt(ACKND_window)                 1
+ set opt(PhaseOne_window)              3
+ set opt(PhaseTwo_window)              1
+ set opt(PhaseTwo_interval)            0.5
+ set opt(IntervalPhase2Phase3)         1 
+ set opt(duration)                     0.1
+ set opt(PhyOverhead)                  8 
+ set opt(large_packet_size)            480 ;# 60 bytes
+ set opt(short_packet_size)            40  ;# 5 bytes
+ set opt(PhaseOne_cycle)               4 ;
+ set opt(PhaseTwo_cycle)               2 ;
+ set opt(PeriodInterval)               1 
+ set opt(transmission_time_error)      0.0001; 
+ 
+ set opt(dz)                           10
+ set opt(ifqlen)		              50	;# max packet in ifq
+ set opt(nn)	                	5	;# number of nodes in each layer
+ set opt(layers)                         1
+ set opt(x)	                	100	;# X dimension of the topography
+ set opt(y)	                        100  ;# Y dimension of the topography
+ set opt(z)                              [expr ($opt(layers)-1)*$opt(dz)]
+ set opt(seed)	                	348.88
+ set opt(stop)	                	1000	;# simulation time
+ set opt(prestop)                        20     ;# time to prepare to stop
+ set opt(tr)	                	"rmac.tr"	;# trace file
+ set opt(nam)                            "rmac.nam"  ;# nam file
+ set opt(adhocRouting)                    Vectorbasedforward
+ set opt(width)                           20
+ set opt(adj)                             10
+ set opt(interval)                        0.001
+ #set opt(traf)	                	"diffusion-traf.tcl"      ;# traffic file
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ #Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ 
+ 
+ Mac/UnderwaterMac set bit_rate_  $opt(bit_rate)
+ Mac/UnderwaterMac set encoding_efficiency_  $opt(encoding_efficiency)
+ Mac/UnderwaterMac/RMac set ND_window_  $opt(ND_window)
+ Mac/UnderwaterMac/RMac set ACKND_window_ $opt(ACKND_window)
+ Mac/UnderwaterMac/RMac set PhaseOne_window_ $opt(PhaseOne_window)
+ Mac/UnderwaterMac/RMac set PhaseTwo_window_ $opt(PhaseTwo_window)
+ Mac/UnderwaterMac/RMac set PhaseTwo_interval_ $opt(PhaseTwo_interval)
+ Mac/UnderwaterMac/RMac set IntervalPhase2Phase3_ $opt(IntervalPhase2Phase3)
+ #Mac/UnderwaterMac/RMac set ACKRevInterval_ 0.1 
+ Mac/UnderwaterMac/RMac set duration_ $opt(duration)
+ Mac/UnderwaterMac/RMac set PhyOverhead_ $opt(PhyOverhead)
+ Mac/UnderwaterMac/RMac set large_packet_size_  $opt(large_packet_size) 
+ Mac/UnderwaterMac/RMac set short_packet_size_  $opt(short_packet_size)
+ Mac/UnderwaterMac/RMac set PhaseOne_cycle_   $opt(PhaseOne_cycle)
+ Mac/UnderwaterMac/RMac set PhaseTwo_cycle_   $opt(PhaseTwo_cycle)
+ Mac/UnderwaterMac/RMac set PeriodInterval_   $opt(PeriodInterval)
+ Mac/UnderwaterMac/RMac set transmission_time_error_ $opt(transmission_time_error) 
+ 
+ 
+ 
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 100  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ 
+ 
+ remove-all-packet-headers 
+ #remove-packet-header AODV ARP TORA  IMEP TFRC
+ add-packet-header IP Mac LL  ARP  UWVB RMAC
+ 
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ #$ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set phase1_time [expr $opt(PhaseOne_cycle)*$opt(PhaseOne_window)]
+ set phase2_time [expr $opt(PhaseTwo_cycle)*($opt(PhaseTwo_window)+$opt(PhaseTwo_interval))]
+ 
+ 
+ set start_time [expr $phase1_time+$phase2_time+$opt(IntervalPhase2Phase3)]
+  
+ puts "the start time is $start_time"
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ global defaultRNG
+ $defaultRNG seed $opt(seed)
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace OFF \
+                  -routerTrace OFF \
+                  -macTrace ON\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txpower $opt(txpower)\
+                  -rxpower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+ 
+ 
+ set node_(0) [$ns_  node 0]
+ $node_(0) set sinkStatus_ 1
+ $node_(0) set passive 1
+     
+ $god_ new_node $node_(0)
+ $node_(0) set X_  0
+ $node_(0) set Y_  0
+ $node_(0) set Z_   0.0
+ $node_(0) set passive 1
+ set a_(0) [new Agent/UWSink]
+ $ns_ attach-agent $node_(0) $a_(0)
+ $a_(0) attach-vectorbasedforward $opt(width)
+ $a_(0) cmd set-range 20
+ $a_(0) cmd set-target-x -20
+ $a_(0) cmd set-target-y -10
+ $a_(0) cmd set-target-z -20
+ 
+ 
+ 
+ set node_(1) [$ns_  node 1]
+ $node_(1) set sinkStatus_ 1
+ $god_ new_node $node_(1)
+ $node_(1) set X_  0
+ $node_(1) set Y_  -15
+ $node_(1) set Z_   0
+ $node_(1) set-cx  0
+ $node_(1) set-cy  -15
+ $node_(1) set-cz  0
+ $node_(1) set_next_hop 0 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(1) [new Agent/UWSink]
+ $ns_ attach-agent $node_(1) $a_(1)
+ $a_(1) attach-vectorbasedforward $opt(width)
+  $a_(1) cmd set-range 20
+  $a_(1) cmd set-target-x   0
+  $a_(1) cmd set-target-y   0
+  $a_(1) cmd set-target-z   0
+  $a_(1) set data_rate_ 0.05
+ 
+ 
+ set node_(2) [$ns_  node 2]
+ $node_(2) set sinkStatus_ 1
+ $god_ new_node $node_(2)
+ $node_(2) set X_  0
+ $node_(2) set Y_  40
+ $node_(2) set Z_   0
+ $node_(2) set-cx  0
+ $node_(2) set-cy  40
+ $node_(2) set-cz  0
+ $node_(2) set_next_hop 0 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(2) [new Agent/UWSink]
+ $ns_ attach-agent $node_(2) $a_(2)
+ $a_(2) attach-vectorbasedforward $opt(width)
+  $a_(2) cmd set-range 20
+  $a_(2) cmd set-target-x   0
+  $a_(2) cmd set-target-y   0
+  $a_(2) cmd set-target-z   0
+  $a_(2) set data_rate_ 0.05
+ 
+ 
+ set node_(3) [$ns_  node 3]
+ $node_(3) set sinkStatus_ 1
+ $god_ new_node $node_(3)
+ $node_(3) set X_  -30
+ $node_(3) set Y_  0
+ $node_(3) set Z_   0
+ $node_(3) set-cx  0
+ $node_(3) set-cy  -30
+ $node_(3) set-cz  0
+ $node_(3) set_next_hop 0 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(3) [new Agent/UWSink]
+ $ns_ attach-agent $node_(3) $a_(3)
+ $a_(3) attach-vectorbasedforward $opt(width)
+  $a_(3) cmd set-range 20
+  $a_(3) cmd set-target-x   0
+  $a_(3) cmd set-target-y   0
+  $a_(3) cmd set-target-z   0
+  $a_(3) set data_rate_ 0.05
+ 
+ 
+ #puts "the total number is $total_number"
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ $node_($total_number) set X_  60
+ $node_($total_number) set Y_  0
+ $node_($total_number) set Z_  0
+ $node_($total_number) set-cx  60
+ $node_($total_number) set-cy  0
+ $node_($total_number) set-cz  0
+ $node_($total_number) set_next_hop 0 ;# target is node 0 
+ 
+ set a_($total_number) [new Agent/UWSink]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $a_($total_number) attach-vectorbasedforward $opt(width)
+  $a_($total_number) cmd set-range 20
+  $a_($total_number) cmd set-target-x 0
+  $a_($total_number) cmd set-target-y 0
+  $a_($total_number) cmd set-target-z 0
+  $a_($total_number) set data_rate_  0.05
+ 
+ 
+ 
+ 
+ 
+ #set max_num [expr $total_number -1]
+ 
+ 
+ 
+ #$ns_ at 15 "$a_($total_number) cbr-start"
+ $ns_ at $start_time "$a_($total_number) exp-start"
+ $ns_ at $start_time "$a_(1) exp-start"
+ $ns_ at $start_time "$a_(2) exp-start"
+ $ns_ at $start_time "$a_(3) exp-start"
+ 
+ #$ns_ at 4 "$a_(0) cbr-start"
+ #$ns_ at 2.0003 "$a_(2) cbr-start"
+ #$ns_ at 0.1 "$a_(0) announce"
+ 
+ 
+ 
+ set node_size 10
+ for {set k 0} { $k<$opt(nn) } { incr k } {
+ 	$ns_ initial_node_pos $node_($k) $node_size
+ }
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ 
+ 
+ 
+ $ns_ at $opt(stop).001 "$a_(0) terminate"
+ $ns_ at $opt(stop).002 "$a_($total_number) terminate"
+ $ns_ at $opt(stop).002 "$a_(1) terminate"
+ $ns_ at $opt(stop).002 "$a_(2) terminate"
+ $ns_ at $opt(stop).002 "$a_(3) terminate"
+ 
+ 
+ $ns_ at $opt(stop).003  "$god_ compute_energy"
+ $ns_ at $opt(stop).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "vectorbased"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+  $ns_ run
diff -crBN ns-2.35/underwatersensor/uw_tcl/tmac-example.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/tmac-example.tcl
*** ns-2.35/underwatersensor/uw_tcl/tmac-example.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/tmac-example.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,346 ----
+ set opt(chan)		Channel/UnderwaterChannel
+ set opt(prop)		Propagation/UnderwaterPropagation
+ set opt(netif)		Phy/UnderwaterPhy
+ set opt(mac)		Mac/UnderwaterMac/TMac
+ set opt(ifq)		Queue/DropTail/PriQueue
+ set opt(ll)		LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        1.0
+ set opt(rxpower)        0.0
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.0
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ 
+ 
+ set opt(bit_rate)                     1.0e4
+ set opt(encoding_efficiency)          1
+ set opt(ND_window)                    1
+ set opt(ACKND_window)                 1
+ set opt(PhaseOne_window)              3
+ set opt(PhaseTwo_window)              1
+ set opt(PhaseTwo_interval)            0.5
+ set opt(IntervalPhase2Phase3)         1 
+ set opt(duration)                     0.1
+ set opt(PhyOverhead)                  8 
+ set opt(large_packet_size)            480 ;# 60 bytes
+ set opt(short_packet_size)            40  ;# 5 bytes
+ set opt(PhaseOne_cycle)               4 ;
+ set opt(PhaseTwo_cycle)               2 ;
+ set opt(PeriodInterval)               1
+ set opt(transmission_time_error)      0.0001; 
+ set opt(ContentionWindow)             0.1;
+ 
+ 
+ 
+ set opt(dz)             10
+ set opt(ifqlen)		50	;# max packet in ifq
+ set opt(nn)		7	;# number of nodes in each layer
+ set opt(layers)         1
+ set opt(x)		100	;# X dimension of the topography
+ set opt(y)	        100  ;# Y dimension of the topography
+ set opt(z)              [expr ($opt(layers)-1)*$opt(dz)]
+ set opt(seed)		55
+ set opt(stop)		100	;# simulation time
+ set opt(prestop)        60     ;# time to prepare to stop
+ set opt(tr)		"tmac.tr"	;# trace file
+ set opt(nam)            "tmac.nam"  ;# nam file
+ set opt(adhocRouting)   Vectorbasedforward
+ set opt(width)           20
+ set opt(adj)             10
+ set opt(interval)        0.001
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ 
+ 
+ Mac/UnderwaterMac set bit_rate_  1.0e4
+ Mac/UnderwaterMac set encoding_efficiency_              $opt(encoding_efficiency)
+ Mac/UnderwaterMac/TMac set ND_window_                   $opt(ND_window)
+ Mac/UnderwaterMac/TMac set ACKND_window_                $opt(ACKND_window)
+ Mac/UnderwaterMac/TMac set PhaseOne_window_             $opt(PhaseOne_window)
+ Mac/UnderwaterMac/TMac set PhaseTwo_window_             $opt(PhaseTwo_window)
+ Mac/UnderwaterMac/TMac set IntervalPhase2Phase3_        $opt(IntervalPhase2Phase3)
+ Mac/UnderwaterMac/TMac set duration_                    $opt(duration)
+ Mac/UnderwaterMac/TMac set PhyOverhead_                 $opt(PhyOverhead)
+ Mac/UnderwaterMac/TMac set large_packet_size_           $opt(large_packet_size)
+ Mac/UnderwaterMac/TMac set short_packet_size_           $opt(short_packet_size) 
+ Mac/UnderwaterMac/TMac set PhaseOne_cycle_              $opt(PhaseOne_cycle)
+ Mac/UnderwaterMac/TMac set PeriodInterval_              $opt(PeriodInterval)
+ Mac/UnderwaterMac/TMac set transmission_time_error_     $opt(transmission_time_error)
+ Mac/UnderwaterMac/TMac set ContentionWindow_            $opt(ContentionWindow)
+ Mac/UnderwaterMac/TMac set TransmissionRange_           90
+ 
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 2  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ $ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set phase1_time [expr $opt(PhaseOne_cycle)*$opt(PhaseOne_window)]
+ set phase2_time [expr $opt(PhaseTwo_window)+$opt(PhaseTwo_interval)]
+ set start_time [expr $phase1_time+$phase2_time+$opt(IntervalPhase2Phase3)]
+ 
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ global defaultRNG
+ $defaultRNG seed $opt(seed)
+ 
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace ON \
+                  -routerTrace OFF \
+                  -macTrace OFF\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txpower $opt(txpower)\
+                  -rxpower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+                  
+ 
+ set node_(0) [$ns_  node 0]
+ $node_(0) set sinkStatus_ 1
+ $node_(0) set passive 1
+     
+ $god_ new_node $node_(0)
+ $node_(0) set X_  0
+ $node_(0) set Y_  0
+ $node_(0) set Z_   0.0
+ $node_(0) set passive 1
+ set a_(0) [new Agent/UWSink]
+ $ns_ attach-agent $node_(0) $a_(0)
+ $a_(0) attach-vectorbasedforward $opt(width)
+ $a_(0) cmd set-range 20
+ $a_(0) cmd set-target-x -20
+ $a_(0) cmd set-target-y -10
+ $a_(0) cmd set-target-z -20
+ 
+ 
+ 
+ set node_(1) [$ns_  node 1]
+ $node_(1) set sinkStatus_ 1
+ $god_ new_node $node_(1)
+ $node_(1) set X_  80
+ $node_(1) set Y_   0
+ $node_(1) set Z_   0
+ $node_(1) set-cx  80
+ $node_(1) set-cy  0
+ $node_(1) set-cz  0
+ $node_(1) set_next_hop 0 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(1) [new Agent/UWSink]
+ $ns_ attach-agent $node_(1) $a_(1)
+ $a_(1) attach-vectorbasedforward $opt(width)
+  $a_(1) cmd set-range 20
+  $a_(1) cmd set-target-x   0
+  $a_(1) cmd set-target-y   0
+  $a_(1) cmd set-target-z   0
+  $a_(1) set data_rate_ 0.1
+ 
+ 
+ 
+ set node_(2) [$ns_  node 2]
+ $node_(2) set sinkStatus_ 1
+ $god_ new_node $node_(2)
+ $node_(2) set X_  160
+ $node_(2) set Y_  0
+ $node_(2) set Z_   0
+ $node_(2) set-cx  160
+ $node_(2) set-cy  0
+ $node_(2) set-cz  0
+ $node_(2) set_next_hop 1 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(2) [new Agent/UWSink]
+ $ns_ attach-agent $node_(2) $a_(2)
+ $a_(2) attach-vectorbasedforward $opt(width)
+  $a_(2) cmd set-range 20
+  $a_(2) cmd set-target-x   0
+  $a_(2) cmd set-target-y   0
+  $a_(2) cmd set-target-z   0
+  $a_(2) set data_rate_ 0.1
+ 
+ 
+ set node_(3) [$ns_  node 3]
+ $node_(3) set sinkStatus_ 1
+ $god_ new_node $node_(3)
+ $node_(3) set X_  240
+ $node_(3) set Y_  0
+ $node_(3) set Z_   0
+ $node_(3) set-cx  240
+ $node_(3) set-cy  0
+ $node_(3) set-cz  0
+ $node_(3) set_next_hop 2 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(3) [new Agent/UWSink]
+ $ns_ attach-agent $node_(3) $a_(3)
+ $a_(3) attach-vectorbasedforward $opt(width)
+  $a_(3) cmd set-range 20
+  $a_(3) cmd set-target-x   0
+  $a_(3) cmd set-target-y   0
+  $a_(3) cmd set-target-z   0
+  $a_(3) set data_rate_ 0.1
+ 
+ 
+ 
+ 
+ set node_(4) [$ns_  node 4]
+ $node_(4) set sinkStatus_ 1
+ $god_ new_node $node_(4)
+ $node_(4) set X_  320
+ $node_(4) set Y_   0
+ $node_(4) set Z_   0
+ $node_(4) set-cx  320
+ $node_(4) set-cy   0
+ $node_(4) set-cz  0
+ $node_(4) set_next_hop 3 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(4) [new Agent/UWSink]
+ $ns_ attach-agent $node_(4) $a_(4)
+ $a_(4) attach-vectorbasedforward $opt(width)
+  $a_(4) cmd set-range 20
+  $a_(4) cmd set-target-x   0
+  $a_(4) cmd set-target-y   0
+  $a_(4) cmd set-target-z   0
+  $a_(4) set data_rate_ 0.1
+ 
+ 
+ 
+ set node_(5) [$ns_  node 5]
+ $node_(5) set sinkStatus_ 1
+ $god_ new_node $node_(5)
+ $node_(5) set X_  400
+ $node_(5) set Y_  0
+ $node_(5) set Z_   0
+ $node_(5) set-cx  400
+ $node_(5) set-cy  0
+ $node_(5) set-cz  0
+ $node_(5) set_next_hop 4 ;# target is node 0 
+ #$node_(1) set passive 1
+ set a_(5) [new Agent/UWSink]
+ $ns_ attach-agent $node_(5) $a_(5)
+ $a_(5) attach-vectorbasedforward $opt(width)
+  $a_(5) cmd set-range 20
+  $a_(5) cmd set-target-x   0
+  $a_(5) cmd set-target-y   0
+  $a_(5) cmd set-target-z   0
+  $a_(5) set data_rate_ 0.1
+ 
+ #puts "the total number is $total_number"
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ $node_($total_number) set X_  480
+ $node_($total_number) set Y_  0
+ $node_($total_number) set Z_  0
+ $node_($total_number) set-cx  480
+ $node_($total_number) set-cy  0
+ $node_($total_number) set-cz  0
+ $node_($total_number) set_next_hop 5 ;# target is node 0 
+ 
+ set a_($total_number) [new Agent/UWSink]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $a_($total_number) attach-vectorbasedforward $opt(width)
+  $a_($total_number) cmd set-range 20
+  $a_($total_number) cmd set-target-x 0
+  $a_($total_number) cmd set-target-y 0
+  $a_($total_number) cmd set-target-z 0
+  $a_($total_number) set data_rate_ 0.5
+ 
+ 
+ 
+ 
+ 
+ #set max_num [expr $total_number -1]
+ 
+ 
+ 
+ #$ns_ at 15 "$a_($total_number) cbr-start"
+ $ns_ at $start_time "$a_($total_number) exp-start"
+ #$ns_ at $start_time "$a_(1) exp-start"
+ #$ns_ at $start_time "$a_(2) exp-start"
+ #$ns_ at $start_time "$a_(3) exp-start"
+ #$ns_ at $start_time "$a_(4) exp-start"
+ #$ns_ at $start_time "$a_(5) exp-start"
+ #$ns_ at 4 "$a_(0) cbr-start"
+ #$ns_ at 2.0003 "$a_(2) cbr-start"
+ #$ns_ at 0.1 "$a_(0) announce"
+ 
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ 
+ 
+ 
+ $ns_ at $opt(stop).001 "$a_(0) terminate"
+ $ns_ at $opt(stop).002 "$a_($total_number) terminate"
+ $ns_ at $opt(stop).002 "$a_(1) terminate"
+ $ns_ at $opt(stop).002 "$a_(2) terminate"
+ $ns_ at $opt(stop).002 "$a_(3) terminate"
+ $ns_ at $opt(stop).002 "$a_(4) terminate"
+ $ns_ at $opt(stop).002 "$a_(5) terminate"
+ 
+ $ns_ at $opt(stop).003  "$god_ compute_energy"
+ $ns_ at $opt(stop).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "vectorbased"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+  $ns_ run
+ 
diff -crBN ns-2.35/underwatersensor/uw_tcl/uwan-mac-random.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/uwan-mac-random.tcl
*** ns-2.35/underwatersensor/uw_tcl/uwan-mac-random.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/uwan-mac-random.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,262 ----
+ set opt(chan)			Channel/UnderwaterChannel
+ set opt(prop)			Propagation/UnderwaterPropagation
+ set opt(netif)			Phy/UnderwaterPhy
+ set opt(mac)			Mac/UnderwaterMac/UWANMac
+ set opt(ifq)			Queue/DropTail/PriQueue
+ set opt(ll)				LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        2.0
+ set opt(rxpower)        0.75
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.008
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ 
+ 
+ set opt(data_rate_) 0.02  ;#  [lindex $argv 0]  ;#0.02
+ 
+ # the following parameters are set fot protocols
+ set opt(bit_rate)                     1.0e4
+ set opt(encoding_efficiency)          1
+ set opt(ND_window)                    1
+ set opt(ACKND_window)                 1
+ set opt(transmission_time_error)      0.0001; 
+ 
+ set opt(dz)                           10
+ set opt(ifqlen)		              50	;# max packet in ifq
+ set opt(nn)	                	8;# number of nodes
+ set opt(layers)                         1
+ set opt(x)	                	100	;# X dimension of the topography
+ set opt(y)	                        100  ;# Y dimension of the topography
+ set opt(z)                              [expr ($opt(layers)-1)*$opt(dz)]
+ set opt(seed)	                	348.88
+ set opt(stop)	                	1000	;# simulation time
+ set opt(prestop)                        20     ;# time to prepare to stop
+ set opt(tr)	                	"t4.tr"	;# trace file
+ set opt(nam)                            "t4.nam"  ;# nam file
+ set opt(adhocRouting)                   Vectorbasedforward ;#SillyRouting
+ set opt(width)                           20
+ set opt(adj)                             10
+ set opt(interval)                        0.001
+ #set opt(traf)	                	"diffusion-traf.tcl"      ;# traffic file
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ #Queue/DropTail/PriQueue set Prefer_Routing_Protocols    
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ 
+ 
+ Mac/UnderwaterMac set bit_rate_  $opt(bit_rate)
+ Mac/UnderwaterMac set encoding_efficiency_  $opt(encoding_efficiency)
+ 
+ Mac/UnderwaterMac/UWANMac set AvgCyclePeriod [expr 1/$opt(data_rate_)]
+ Mac/UnderwaterMac/UWANMac set StdCyclePeriod 1
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 100  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ 
+ 
+ remove-all-packet-headers 
+ #remove-packet-header AODV ARP TORA  IMEP TFRC
+ add-packet-header IP Mac LL  ARP  UWVB RMAC
+ 
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ #$ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set start_time 0.001
+ puts "the start time is $start_time"
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ global defaultRNG
+ $defaultRNG seed $opt(seed)
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace OFF \
+                  -routerTrace OFF \
+                  -macTrace ON\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txpower $opt(txpower)\
+                  -rxpower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+ 
+ 
+ 
+ for {set i 0} {$i<$opt(nn)} {incr i} {
+ 
+ 	set node_($i) [$ns_  node $i]
+ 	$node_($i) set sinkStatus_ 1
+ 	$node_($i) set passive 1
+ 	$god_ new_node $node_($i)
+ 	
+ 	set a_($i) [new Agent/UWSink]
+ 	$ns_ attach-agent $node_($i) $a_($i)
+ 	$a_($i) attach-vectorbasedforward $opt(width)
+ 	$a_($i) cmd set-range 20
+ 	$a_($i) set data_rate_ $opt(data_rate_)
+ 	
+ }
+ 
+ 
+ $node_(0) set X_  70
+ $node_(0) set Y_  70
+ $node_(0) set Z_  0
+ $a_(0) setTargetAddress 1
+ $node_(0) set_next_hop 1
+ $node_(0) set-cx 70
+ $node_(0) set-cy 70
+ $node_(0) set-cz 0
+ 
+ $node_(1) set X_  30
+ $node_(1) set Y_  30
+ $node_(1) set Z_  1
+ #$node_(1) set_next_hop 5
+ #$a_(1) setTargetAddress 5
+ $node_(1) set-cx 30
+ $node_(1) set-cy 30
+ $node_(1) set-cz 1
+ 
+ $node_(2) set X_  90
+ $node_(2) set Y_  50
+ $node_(2) set Z_  6
+ $node_(2) set_next_hop 3
+ $a_(2) setTargetAddress 3
+ $node_(2) set-cx 90
+ $node_(2) set-cy 50
+ $node_(2) set-cz 6
+ 
+ $node_(3) set X_  30
+ $node_(3) set Y_  100
+ $node_(3) set Z_  0
+ #$node_(3) set_next_hop 0
+ #$a_(3) setTargetAddress 0
+ $node_(3) set-cx 30
+ $node_(3) set-cy 100
+ $node_(3) set-cz 0
+ 
+ $node_(4) set X_  110
+ $node_(4) set Y_  130
+ $node_(4) set Z_  3
+ $node_(4) set_next_hop 6
+ $a_(4) setTargetAddress 6
+ $node_(4) set-cx 110
+ $node_(4) set-cy 130
+ $node_(4) set-cz 0
+ 
+ $node_(5) set X_  120
+ $node_(5) set Y_  200
+ $node_(5) set Z_  0
+ $node_(5) set_next_hop 7
+ $a_(5) setTargetAddress 7
+ $node_(5) set-cx 120
+ $node_(5) set-cy 200
+ $node_(5) set-cz 0
+ 
+ $node_(6) set X_  130
+ $node_(6) set Y_  80
+ $node_(6) set Z_  0
+ #$node_(6) set_next_hop 4
+ #$a_(6) setTargetAddress 4
+ $node_(6) set-cx 130
+ $node_(6) set-cy 80
+ $node_(6) set-cz 0
+ 
+ $node_(7) set X_  80
+ $node_(7) set Y_  160
+ $node_(7) set Z_  0
+ #$node_(7) set_next_hop 3
+ #$a_(7) setTargetAddress 3
+ $node_(7) set-cx 80
+ $node_(7) set-cy 160
+ $node_(7) set-cz 0
+ 
+ #for { set i 0 } { $i < 8 } { incr i } {
+ #	set start_time [expr $start_time+0.69238]
+ #	$ns_ at $start_time "$a_($i) cbr-start"
+ #}
+ 
+ $ns_ at $start_time.11 "$a_(0) cbr-start"
+ $ns_ at $start_time.33 "$a_(2) cbr-start"
+ #$ns_ at $start_time "$a_(3) cbr-start"
+ $ns_ at $start_time.56 "$a_(4) cbr-start"
+ $ns_ at $start_time.79 "$a_(5) cbr-start"
+ #$ns_ at $start_time "$a_(6) cbr-start"
+ #$ns_ at $start_time "$a_(7) cbr-start"
+ 
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ $ns_ at $opt(stop).001 "$a_(0) terminate"
+ $ns_ at $opt(stop).002 "$a_(7) terminate"
+ $ns_ at $opt(stop).002 "$a_(1) terminate"
+ $ns_ at $opt(stop).002 "$a_(2) terminate"
+ $ns_ at $opt(stop).002 "$a_(3) terminate"
+ $ns_ at $opt(stop).002 "$a_(4) terminate"
+ $ns_ at $opt(stop).002 "$a_(5) terminate"
+ $ns_ at $opt(stop).002 "$a_(6) terminate"
+ 
+ 
+ $ns_ at $opt(stop).003  "$god_ compute_energy"
+ $ns_ at $opt(stop).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "SillyRrouting"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+  $ns_ run
diff -crBN ns-2.35/underwatersensor/uw_tcl/uw_rwp.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/uw_rwp.tcl
*** ns-2.35/underwatersensor/uw_tcl/uw_rwp.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/uw_rwp.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,250 ----
+ #$0 pkt interval; $1 bandwidth; $2 pkt length of cbr;  $3 stop time; $4 number of hops
+ set opt(chan)			Channel/UnderwaterChannel
+ set opt(prop)			Propagation/UnderwaterPropagation
+ set opt(netif)			Phy/UnderwaterPhy
+ set opt(mac)			Mac/UnderwaterMac/BroadcastMac
+ set opt(ifq)			Queue/DropTail
+ set opt(ll)				LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        0.6
+ set opt(rxpower)        0.3
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.01
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ 
+ set opt(max_pkts)		300
+ set opt(interval_)	          0.2 ;# [lindex $argv 0] 
+ set opt(pkt_len)	          80;  #[lindex $argv 2] ;# pkt length of cbr
+ 
+ # the following parameters are set fot protocols
+ set opt(bit_rate)                         5.0e3 ;#[lindex $argv 1];#1.0e4    ;#bandwidth of the phy link
+ set opt(encoding_efficiency)          1
+ set opt(ND_window)                    1
+ set opt(ACKND_window)                 1
+ set opt(PhaseOne_window)              3
+ set opt(PhaseTwo_window)              1
+ set opt(PhaseTwo_interval)            0.5
+ set opt(IntervalPhase2Phase3)         1 
+ set opt(duration)                     0.1
+ set opt(PhyOverhead)                  8 
+ set opt(large_packet_size)            480 ;# 60 bytes
+ set opt(short_packet_size)            40  ;# 5 bytes
+ set opt(PhaseOne_cycle)               4 ;
+ set opt(PhaseTwo_cycle)               2 ;
+ set opt(PeriodInterval)               2
+ set opt(transmission_time_error)      0.0001; 
+ 
+ set opt(dz)                           	10
+ set opt(hop)				       7 ;#	[lindex $argv 4]
+ set opt(ifqlen)		              50	;# max packet in ifq
+ set opt(nn)	                		[expr $opt(hop)+1] ;#5	;# number of nodes in the network
+ set opt(layers)                         	1
+ set opt(x)	                		300	;# X dimension of the topography
+ set opt(y)	                        	300  ;# Y dimension of the topography
+ set opt(z)                      		10
+ set opt(seed)	                		648.88
+ set opt(stop)	                		1000 ;#[lindex $argv 3] ;#150	;# simulation time
+ set opt(prestop)                       	80     ;# time to prepare to stop
+ set opt(tr)	                		"uw_rwp.tr"	;# trace file
+ set opt(nam)                            	"uw_rwp.nam"  ;# nam file
+ set opt(adhocRouting)                 	Vectorbasedforward 
+ set opt(width)                           	20
+ set opt(adj)                             	10
+ set opt(interval)                        	0.001
+ 
+ set start_time				10
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ #Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ 
+ 
+ Mac/UnderwaterMac set bit_rate_  $opt(bit_rate)
+ Mac/UnderwaterMac set encoding_efficiency_  $opt(encoding_efficiency)
+ #Mac/UnderwaterMac/AlohaOverhear set  MaxResendInterval_ 0.2
+ #Mac/UnderwaterMac/AlohaOverhear set  DeltaDelay_ 1
+ 
+ 
+ Node/MobileNode/UnderwaterSensorNode set position_update_interval_ 1.0
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 100  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ 
+ 
+ #remove-all-packet-headers 
+ 
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ #$ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ global defaultRNG
+ 
+ $defaultRNG seed $opt(seed)
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace ON \
+          -routerTrace ON \
+          -macTrace ON \
+          -movementTrace ON \
+          -topoInstance $topo\
+          -energyModel $opt(energy)\
+          -txpower $opt(txpower)\
+          -rxpower $opt(rxpower)\
+          -initialEnergy $opt(initialenergy)\
+          -idlePower $opt(idlepower)\
+          -channel $chan_1_
+ 
+ 
+ set node_(0) [$ns_  node 0]
+ #$node_(0) set sinkStatus_ 1
+ #$node_(0) set passive 1
+     
+ $god_ new_node $node_(0)
+ $node_(0) set passive 1
+ set a_(0) [new Agent/Null]
+ $node_(0) set-mobilitypattern RWP
+ $node_(0) set max_speed 5
+ $node_(0) set min_speed 1
+ 
+ $ns_ attach-agent $node_(0) $a_(0)
+ 
+ 
+ 
+ for {set i 1} {$i<$total_number} {incr i} {
+ 
+ set node_($i) [$ns_  node $i]
+ $node_($i) set sinkStatus_ 1
+ $god_ new_node $node_($i)
+ $node_($i) set-cx   50
+ $node_($i) set-cy   50
+ $node_($i) set-cz   0
+ $node_($i) set_next_hop [expr $i-1] ;# target is node 0 
+ $node_($i) set-mobilitypattern  RWP
+ $node_($i) set max_speed 5
+ $node_($i) set min_speed 1
+ 
+ }
+ 
+ 
+ 
+ #puts "the total number is $total_number"
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ $node_($total_number) set-cx  50
+ $node_($total_number) set-cy  50
+ $node_($total_number) set-cz  0
+ $node_($total_number) set_next_hop  [expr $total_number-1] ;# target is node 0 
+ $node_($total_number) set-mobilitypattern  RWP
+ $node_($total_number) set max_speed 5
+ $node_($total_number) set min_speed 1
+ 
+ set a_($total_number) [new Agent/UDP]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $ns_ connect $a_($total_number) $a_(0)
+ 
+ set cbr_(0) [new Application/Traffic/CBR]
+ $cbr_(0) set packetSize $opt(pkt_len)   ;#80
+ $cbr_(0) set interval_ $opt(interval_)
+ $cbr_(0) set random 1
+ $cbr_(0) set maxpkts_  $opt(max_pkts)
+ $cbr_(0) attach-agent $a_($total_number)
+ 
+ 
+ 
+ for {set i 0} { $i < $opt(nn)} {incr i} {
+   $ns_ initial_node_pos $node_($i) 2
+   $node_($i) setPositionUpdateInterval 0.01
+   $node_($i) random-motion 0
+   $ns_ at 5.0 "$node_($i) start-mobility-pattern"
+ }
+ 
+ 
+ $ns_ at $start_time "$cbr_(0) start"
+ 
+ 
+ #$ns_ at 15 "$a_($total_number) cbr-start"
+ #$ns_ at $start_time "$a_($total_number) exp-start"
+ #$ns_ at 4 "$a_(0) cbr-start"
+ #$ns_ at 2.0003 "$a_(2) cbr-start"
+ #$ns_ at 0.1 "$a_(0) announce"
+ 
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ 
+ 
+ 
+ ;#$ns_ at $opt(stop).001 "$a_(0) terminate"
+ 
+ 
+ ;#$ns_ at $opt(stop).002 "$a_($total_number) terminate"
+ 
+ for {set i 1} {$i<$total_number} {incr i} {
+ #;$ns_ at $opt(stop).002 "$a_($i) terminate"
+ 	$ns_ at $opt(stop).002 "$node_($i) reset"
+ }
+ 
+ $ns_ at $opt(stop).003  "$god_ compute_energy"
+ $ns_ at $opt(stop).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "vectorbased"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+  $ns_ run
+  
diff -crBN ns-2.35/underwatersensor/uw_tcl/vbf_example_5.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/vbf_example_5.tcl
*** ns-2.35/underwatersensor/uw_tcl/vbf_example_5.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/vbf_example_5.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,337 ----
+ set opt(chan)		Channel/UnderwaterChannel
+ set opt(prop)		Propagation/UnderwaterPropagation
+ set opt(netif)		Phy/UnderwaterPhy
+ set opt(mac)		Mac/UnderwaterMac/BroadcastMac
+ set opt(ifq)		Queue/DropTail/PriQueue
+ set opt(ll)		LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        2.0
+ set opt(rxpower)        0.75
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.008
+ set opt(ant)            Antenna/OmniAntenna
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ set opt(minspeed)           0  ;#minimum speed of node
+ set opt(maxspeed)           3   ;#maximum speed of node
+ set opt(speed)              0.5  ;#speed of node
+ set opt(position_update_interval) 0.3  ;# the length of period to update node's position
+ set opt(packet_size) 50  ;#50 bytes
+ set opt(routing_control_packet_size) 20 ;#bytes 
+ 
+ set opt(ifqlen)		50	;# max queue length in if
+ set opt(nn)		6	;# number of nodes 
+ set opt(x)		1000	;# X dimension of the topography
+ set opt(y)	        10  ;# Y dimension of the topography
+ set opt(z)              10
+ set opt(seed)		11
+ set opt(stop)		500	;# simulation time
+ set opt(prestop)        90     ;# time to prepare to stop
+ set opt(tr)		"vbf_example_5.tr"	;# trace file
+ set opt(datafile)	"vbf_example_5.data"
+ set opt(nam)            "vbf_example_5.nam"  ;# nam file
+ set opt(adhocRouting)   Vectorbasedforward
+ set opt(width)           100
+ set opt(interval)        10.0
+ set opt(range)           120    ;#range of each node in meters
+ 
+ if { $argc > 0 } {
+   set opt(seed) [lindex $argv 0]
+   set opt(nn) [lindex $argv 1]
+   set opt(datafile) [lindex $argv 2]
+ }
+ 
+ puts "the file name is $opt(datafile)"
+ puts "the sending interval is $opt(interval)"
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ #Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ Agent/Vectorbasedforward set hop_by_hop_ 0
+ 
+ Mac/UnderwaterMac set bit_rate_  1.0e4 ;#10kbps
+ Mac/UnderwaterMac set encoding_efficiency_ 1
+ Mac/UnderwaterMac/BroadcastMac set packetheader_size_ 0 ;# #of bytes
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_  10  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_  0    ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_  0    ;#3.652e-10
+ #Phy/WirelessPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_  0.2818
+ Phy/UnderwaterPhy set freq_  25  ;# 25khz  
+ Phy/UnderwaterPhy set K_ 2.0    ;# spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ #$ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set data [open $opt(datafile) a]
+ 
+ 
+ set total_number  [expr $opt(nn)-1]
+ set god_ [create-god  $opt(nn)]
+ 
+ 
+ $ns_ at 0.0 "$god_  set_filename $opt(datafile)"
+ 
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ global defaultRNG
+ $defaultRNG seed $opt(seed)
+ 
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace OFF \
+                  -routerTrace OFF \
+                  -macTrace ON\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txPower $opt(txpower)\
+                  -rxPower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+                  
+ 
+ puts "Width=$opt(width)"
+ #Set the Sink node
+ 
+ 
+ set node_(0) [ $ns_  node 0]
+ $node_(0) set sinkStatus_ 1
+ $god_ new_node $node_(0)
+ $node_(0) set X_  500
+ $node_(0) set Y_  0
+ $node_(0) set Z_  0
+ $node_(0) set passive 1
+ 
+ set rt [$node_(0) set ragent_]
+ $rt set control_packet_size  $opt(routing_control_packet_size)
+ 
+ set a_(0) [new Agent/UWSink]
+ $ns_ attach-agent $node_(0) $a_(0)
+ $a_(0) attach-vectorbasedforward $opt(width)
+ $a_(0) cmd set-range $opt(range) 
+ $a_(0) cmd set-target-x -20
+ $a_(0) cmd set-target-y -10
+ $a_(0) cmd set-target-z -20
+ $a_(0) cmd set-filename $opt(datafile)
+ $a_(0) cmd set-packetsize $opt(packet_size) ;# # of bytes
+ 
+ 
+ 
+ set node_(1) [ $ns_  node 1]
+ $node_(1) set sinkStatus_ 1
+ $god_ new_node $node_(1)
+ $node_(1) set X_  440
+ $node_(1) set Y_  0
+ $node_(1) set Z_  0
+ $node_(1) set passive 1
+ 
+ set rt [$node_(1) set ragent_]
+ $rt set control_packet_size  $opt(routing_control_packet_size)
+ $node_(1) set max_speed $opt(maxspeed)
+ $node_(1) set min_speed $opt(minspeed)
+ $node_(1) set position_update_interval_ $opt(position_update_interval)
+ set a_(1) [new Agent/UWSink]
+ $ns_ attach-agent $node_(1) $a_(1)
+ $a_(1) attach-vectorbasedforward $opt(width)
+ $a_(1) cmd set-range $opt(range) 
+ $a_(1) cmd set-target-x -20
+ $a_(1) cmd set-target-y -10
+ $a_(1) cmd set-target-z -20
+ $a_(1) cmd set-filename $opt(datafile)
+ $a_(1) cmd set-packetsize $opt(packet_size) ;# # of bytes
+ #$node_(1) move
+ 
+ set node_(2) [ $ns_  node 2]
+ $node_(2) set sinkStatus_ 1
+ $node_(2) random-motion 1
+ $node_(2) set max_speed $opt(maxspeed)
+ $node_(2) set min_speed $opt(minspeed)
+ $node_(2) set position_update_interval_ $opt(position_update_interval)
+ 
+ $god_ new_node $node_(2)
+ $node_(2) set X_  450
+ $node_(2) set Y_  50
+ $node_(2) set Z_  0
+ $node_(2) set passive 1
+ 
+ set rt [$node_(2) set ragent_]
+ $rt set control_packet_size  $opt(routing_control_packet_size)
+ 
+ set a_(2) [new Agent/UWSink]
+ $ns_ attach-agent $node_(2) $a_(2)
+ $a_(2) attach-vectorbasedforward $opt(width)
+ $a_(2) cmd set-range $opt(range) 
+ $a_(2) cmd set-target-x -20
+ $a_(2) cmd set-target-y -10
+ $a_(2) cmd set-target-z -20
+ $a_(2) cmd set-filename $opt(datafile)
+ $a_(2) cmd set-packetsize $opt(packet_size) ;# # of bytes
+ #$node_(2) move
+ 
+ 
+ set node_(3) [ $ns_  node 3]
+ $node_(3) set sinkStatus_ 1
+ $node_(3) random-motion 1
+ 
+ $node_(3) set max_speed $opt(maxspeed)
+ $node_(3) set min_speed $opt(minspeed)
+ $node_(3) set position_update_interval_ $opt(position_update_interval)
+ 
+ $god_ new_node $node_(3)
+ $node_(3) set X_  500
+ $node_(3) set Y_  70
+ $node_(3) set Z_  0
+ $node_(3) set passive 1
+ 
+ set rt [$node_(3) set ragent_]
+ $rt set control_packet_size  $opt(routing_control_packet_size)
+ 
+ set a_(3) [new Agent/UWSink]
+ $ns_ attach-agent $node_(3) $a_(3)
+ $a_(3) attach-vectorbasedforward $opt(width)
+ $a_(3) cmd set-range $opt(range) 
+ $a_(3) cmd set-target-x -20
+ $a_(3) cmd set-target-y -10
+ $a_(3) cmd set-target-z -20
+ $a_(3) cmd set-filename $opt(datafile)
+ $a_(3) cmd set-packetsize $opt(packet_size) ;# # of bytes
+ 
+ 
+ 
+ 
+ set node_(4) [ $ns_  node 4]
+ $node_(4) set sinkStatus_ 1
+ $node_(4) random-motion 1
+ 
+ $node_(4) set max_speed $opt(maxspeed)
+ $node_(4) set min_speed $opt(minspeed)
+ $node_(4) set position_update_interval_ $opt(position_update_interval)
+ 
+ $god_ new_node $node_(4)
+ $node_(4) set X_  470
+ $node_(4) set Y_  20
+ $node_(4) set Z_  30
+ $node_(4) set passive 1
+ 
+ set rt [$node_(4) set ragent_]
+ $rt set control_packet_size  $opt(routing_control_packet_size)
+ 
+ set a_(4) [new Agent/UWSink]
+ $ns_ attach-agent $node_(4) $a_(4)
+ $a_(4) attach-vectorbasedforward $opt(width)
+ $a_(4) cmd set-range $opt(range) 
+ $a_(4) cmd set-target-x -20
+ $a_(4) cmd set-target-y -10
+ $a_(4) cmd set-target-z -20
+ $a_(4) cmd set-filename $opt(datafile)
+ $a_(4) cmd set-packetsize $opt(packet_size) ;# # of bytes
+  
+ 
+ 
+ #Set the source node
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ 
+ $node_($total_number) set  sinkStatus_ 1
+ 
+ $node_($total_number) set X_  490
+ $node_($total_number) set Y_  10
+ $node_($total_number) set Z_  40
+ $node_($total_number) set-cx  200
+ $node_($total_number) set-cy  0
+ $node_($total_number) set-cz  0
+ set rt [$node_($total_number) set ragent_]
+ $rt set control_packet_size  $opt(routing_control_packet_size)
+ 
+ 
+ set a_($total_number) [new Agent/UWSink]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $a_($total_number) attach-vectorbasedforward $opt(width)
+ $a_($total_number) cmd set-range $opt(range)
+ $a_($total_number) cmd set-target-x 500
+ $a_($total_number) cmd set-target-y 0
+ $a_($total_number) cmd set-target-z 0
+ $a_($total_number) cmd set-filename $opt(datafile)
+ $a_($total_number) cmd set-packetsize $opt(packet_size) ;# # of bytes
+ 
+ set start_time 1.33
+ for { set i 1 } { $i<$opt(nn) } {incr i } {
+ 	$a_($i) set data_rate_ [expr 1.0/$opt(interval)]
+ 	$ns_ at $start_time "$a_($i) cbr-start"
+ 	set start_time [expr $start_time+0.5 ]
+ 	$ns_ at $opt(stop).001 "$a_($i) terminate"
+ }
+ 
+ # make nam workable
+ set node_size 10
+ for {set k 0} { $k<$opt(nn)} {incr k} {
+ $ns_ initial_node_pos $node_($k) $node_size
+ }
+ 
+ 
+ set opt(stop2) [expr $opt(stop)+200]
+ 
+ 
+ puts "Node $total_number is sending first!!"
+ #$ns_ at 1.33 "$a_($total_number) cbr-start"
+ #$ns_ at $opt(stop).001 "$a_($total_number) terminate"
+ 
+ $ns_ at $opt(stop2).002 "$a_(0) terminate"
+ 
+ 
+ $ns_ at $opt(stop2).003  "$god_ compute_energy"
+ $ns_ at $opt(stop2).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop2).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+ 
+  puts $data  "New simulation...."
+  puts $data "nodes  = $opt(nn), maxspeed = $opt(maxspeed), minspeed = $opt(minspeed), random_seed = $opt(seed), sending_interval_=$opt(interval), width=$opt(width)"
+  puts $data "x= $opt(x) y= $opt(y) z= $opt(z)"
+  close $data
+  puts "starting Simulation..."
+  $ns_ run
diff -crBN ns-2.35/underwatersensor/uw_tcl/vbf_example_6.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/vbf_example_6.tcl
*** ns-2.35/underwatersensor/uw_tcl/vbf_example_6.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/vbf_example_6.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,269 ----
+ set opt(chan)		Channel/UnderwaterChannel
+ set opt(prop)		Propagation/UnderwaterPropagation
+ set opt(netif)		Phy/UnderwaterPhy
+ set opt(mac)		Mac/UnderwaterMac/BroadcastMac
+ set opt(ifq)		Queue/DropTail/PriQueue
+ set opt(ll)		LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        2.0
+ set opt(rxpower)        0.75
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.008
+ set opt(ant)            Antenna/OmniAntenna
+ set opt(filters)        GradientFilter    ;# options can be one or more of 
+                                 ;# TPP/OPP/Gear/Rmst/SourceRoute/Log/TagFilter
+ set opt(minspeed)           0.2  ;#minimum speed of node
+ set opt(maxspeed)           3   ;#maximum speed of node
+ set opt(speed)              0.5  ;#speed of node
+ set opt(position_update_interval) 0.3  ;# the length of period to update node's position
+ set opt(packet_size)    50  ;#50 bytes
+ set opt(routing_control_packet_size) 20 ;#bytes 
+ set opt(ifqlen)		50	;# max queue length in if
+ set opt(nn)	        100	;# number of nodes 
+ set opt(x)		300	;# X dimension of the topography
+ set opt(y)	        300  ;# Y dimension of the topography
+ set opt(z)              500
+ set opt(seed)		10
+ set opt(stop)		100	;# simulation time
+ set opt(prestop)        90     ;# time to prepare to stop
+ set opt(tr)		"vbf_example_6.tr"	;# trace file
+ set opt(datafile)	"vbf_example_6.data"
+ set opt(nam)            "vbf_example_6.nam"  ;# nam file
+ set opt(adhocRouting)   Vectorbasedforward
+ set opt(width)           100
+ set opt(interval)        10.0
+ set opt(range)           120    ;#range of each node in meters
+ 
+ if { $argc > 0 } {
+   set opt(seed) [lindex $argv 0]
+   set opt(nn) [lindex $argv 1]
+   set opt(datafile) [lindex $argv 2]
+ }
+ 
+ puts "the file name is $opt(datafile)"
+ puts "the sending interval is $opt(interval)"
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ #Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ Agent/Vectorbasedforward set hop_by_hop_ 0
+ 
+ Mac/UnderwaterMac set bit_rate_  1.0e4 ;#10kbps
+ Mac/UnderwaterMac set encoding_efficiency_ 1
+ Mac/UnderwaterMac/BroadcastMac set packetheader_size_ 0 ;# #of bytes
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_  10  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_  0    ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_  0    ;#3.652e-10
+ #Phy/WirelessPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_  0.2818
+ Phy/UnderwaterPhy set freq_  25  ;# 25khz  
+ Phy/UnderwaterPhy set K_ 2.0    ;# spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ $ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set data [open $opt(datafile) a]
+ 
+ 
+ set total_number  [expr $opt(nn)-1]
+ set god_ [create-god  $opt(nn)]
+ 
+ 
+ $ns_ at 0.0 "$god_  set_filename $opt(datafile)"
+ 
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ global defaultRNG
+ $defaultRNG seed $opt(seed)
+ 
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 #-channelType $opt(chan) \
+ 		 -agentTrace OFF \
+                  -routerTrace ON \
+                  -macTrace OFF\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txPower $opt(txpower)\
+                  -rxPower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+                  
+ 
+ puts "Width=$opt(width)"
+ #Set the Sink node
+ 
+ #node 0 is the sink
+ set node_(0) [ $ns_  node 0]
+ $node_(0) set sinkStatus_ 1
+ $god_ new_node $node_(0)
+ $node_(0) set X_  250
+ $node_(0) set Y_  250
+ $node_(0) set Z_  0
+ $node_(0) set passive 1
+ 
+ set rt [$node_(0) set ragent_]
+ $rt set control_packet_size  $opt(routing_control_packet_size)
+ 
+ set a_(0) [new Agent/UWSink]
+ $ns_ attach-agent $node_(0) $a_(0)
+ $a_(0) attach-vectorbasedforward $opt(width)
+ $a_(0) cmd set-range $opt(range) 
+ $a_(0) cmd set-target-x 250
+ $a_(0) cmd set-target-y 200
+ $a_(0) cmd set-target-z 10
+ $a_(0) cmd set-filename $opt(datafile)
+ $a_(0) cmd set-packetsize $opt(packet_size) ;# # of bytes
+ 
+ 
+ 
+ set xrand_ [new RandomVariable/Uniform]
+ $xrand_ set min_ 0
+ $xrand_ set max_ $opt(x)
+ set yrand_ [new RandomVariable/Uniform]
+ $yrand_ set min_ 0
+ $yrand_ set max_ $opt(y)
+ set zrand_ [new RandomVariable/Uniform]
+ $zrand_ set min_ 0
+ $zrand_ set max_ $opt(z)
+ 
+ 
+ for {set i 2} { $i < $opt(nn) } { incr i } {
+ 
+ 	set node_($i) [ $ns_  node $i]
+ 	$node_($i) set sinkStatus_ 1
+ 	$node_($i) random-motion 1
+ 
+ 	$node_($i) set max_speed $opt(maxspeed)
+ 	$node_($i) set min_speed $opt(minspeed)
+ 	$node_($i) set position_update_interval_ $opt(position_update_interval)
+ 
+ 	$god_ new_node $node_($i)
+ 	$node_($i) set X_  [$xrand_ value]
+ 	$node_($i) set Y_  [$yrand_ value]
+ 	$node_($i) set Z_  [$zrand_ value]
+ 	$node_($i) set passive 1
+ 	$node_($i) move
+ 
+ 	set rt [$node_($i) set ragent_]
+ 	$rt set control_packet_size  $opt(routing_control_packet_size)
+ 
+ 	set a_($i) [new Agent/UWSink]
+ 	$ns_ attach-agent $node_($i) $a_($i)
+ 	$a_($i) attach-vectorbasedforward $opt(width)
+ 	$a_($i) cmd set-range $opt(range) 
+ 	$a_($i) cmd set-target-x 250
+ 	$a_($i) cmd set-target-y 200
+ 	$a_($i) cmd set-target-z 10
+ 	$a_($i) cmd set-filename $opt(datafile)
+ 	$a_($i) cmd set-packetsize $opt(packet_size) ;# # of bytes
+  
+ } 
+ 
+ 
+ #Set the source node
+ set node_(1) [$ns_  node 1]
+ $god_ new_node $node_(1)
+ 
+ $node_(1) set  sinkStatus_ 1
+ 
+ $node_(1) set max_speed $opt(maxspeed)
+ $node_(1) set min_speed $opt(minspeed)
+ $node_(1) set position_update_interval_ $opt(position_update_interval)
+ 
+ $node_(1) set X_  100
+ $node_(1) set Y_  300
+ $node_(1) set Z_  $opt(z)
+ $node_(1) set-cx  100
+ $node_(1) set-cy  300
+ $node_(1) set-cz  $opt(z)
+ set rt [$node_(1) set ragent_]
+ #$rt set control_packet_size  $opt(routing_control_packet_size)
+ $ns_ at 2.0 "$node_(1) move"
+ 
+ set a_(1) [new Agent/UWSink]
+ $ns_ attach-agent $node_(1) $a_(1)
+ $a_(1) attach-vectorbasedforward $opt(width)
+ $a_(1) cmd set-range $opt(range)
+ $a_(1) cmd set-target-x 250
+ $a_(1) cmd set-target-y 200
+ $a_(1) cmd set-target-z 10
+ $a_(1) cmd set-filename $opt(datafile)
+ $a_(1) cmd set-packetsize $opt(packet_size) ;# # of bytes
+ $a_(1) set data_rate_ [expr 1.0/$opt(interval)]
+ 
+ 
+ 
+ # make nam workable
+ set node_size 10
+ for {set k 0} { $k<$opt(nn)} {incr k} {
+ $ns_ initial_node_pos $node_($k) $node_size
+ }
+ 
+ 
+ set opt(stop2) [expr $opt(stop)+2]
+ 
+ 
+ puts "Node 1 is sending first!!"
+ $ns_ at 1.33 "$a_(1) cbr-start"
+ $ns_ at $opt(stop).001 "$a_(1) stop"
+ $ns_ at $opt(stop2).002 "$a_(1) terminate"
+ 
+ $ns_ at $opt(stop2).002 "$a_(0) terminate"
+ 
+ 
+ $ns_ at $opt(stop2).003  "$god_ compute_energy"
+ $ns_ at $opt(stop2).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop2).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+ 
+  puts $data  "New simulation...."
+  puts $data "nodes  = $opt(nn), maxspeed = $opt(maxspeed), minspeed = $opt(minspeed), random_seed = $opt(seed), sending_interval_=$opt(interval), width=$opt(width)"
+  puts $data "x= $opt(x) y= $opt(y) z= $opt(z)"
+  close $data
+  puts "starting Simulation..."
+  $ns_ run
diff -crBN ns-2.35/underwatersensor/uw_tcl/vbva_example.tcl ns-2.35-aquasim/underwatersensor/uw_tcl/vbva_example.tcl
*** ns-2.35/underwatersensor/uw_tcl/vbva_example.tcl	1970-01-01 08:00:00.000000000 +0800
--- ns-2.35-aquasim/underwatersensor/uw_tcl/vbva_example.tcl	2012-01-31 23:53:15.000000000 +0800
***************
*** 0 ****
--- 1,393 ----
+ set opt(chan)		Channel/UnderwaterChannel
+ set opt(prop)		Propagation/UnderwaterPropagation
+ set opt(netif)		Phy/UnderwaterPhy
+ set opt(mac)		Mac/UnderwaterMac/BroadcastMac
+ set opt(ifq)		Queue/DropTail/PriQueue
+ set opt(ll)		LL
+ set opt(energy)         EnergyModel
+ set opt(txpower)        0.6
+ set opt(rxpower)        0.3
+ set opt(initialenergy)  10000
+ set opt(idlepower)      0.01
+ set opt(ant)            Antenna/OmniAntenna  ;#we don't use it in underwater
+ 
+ set opt(ifqlen)		50	;# max queue length in if
+ set opt(nn)		12	;# number of nodes in each layer
+ set opt(x)		400	;# X dimension of the topography
+ set opt(y)	        400  ;# Y dimension of the topography
+ set opt(z)              400
+ set opt(seed)		12
+ set opt(stop)		100	;# simulation time
+ set opt(prestop)        50     ;# time to prepare to stop
+ set opt(tr)		"vbva_example.tr"	;# trace file
+ set opt(nam)            "vbva_example.nam"  ;# nam file
+ set opt(adhocRouting)   VectorbasedVoidAvoidance
+ set opt(width)           100
+ set opt(adj)             10
+ set opt(interval)        0.001
+ 
+ # ==================================================================
+ 
+ LL set mindelay_		50us
+ LL set delay_			25us
+ LL set bandwidth_		0	;# not used
+ 
+ Queue/DropTail/PriQueue set Prefer_Routing_Protocols    1
+ 
+ # unity gain, omni-directional antennas
+ # set up the antennas to be centered in the node and 1.5 meters above it
+ Antenna/OmniAntenna set X_ 0
+ Antenna/OmniAntenna set Y_ 0
+ Antenna/OmniAntenna set Z_ 1.5
+ Antenna/OmniAntenna set Z_ 0.05
+ Antenna/OmniAntenna set Gt_ 1.0
+ Antenna/OmniAntenna set Gr_ 1.0
+ 
+ Agent/VectorbasedVoidAvoidance set width 1
+ 
+ Mac/UnderwaterMac set bit_rate_  1.0e4
+ Mac/UnderwaterMac set encoding_efficiency_  1
+ Mac/UnderwaterMac/BroadcastMac set packetheader_size_  0  ;# # of bytes
+ 
+ # Initialize the SharedMedia interface with parameters to make
+ # it work like the 914MHz Lucent WaveLAN DSSS radio interface
+ Phy/UnderwaterPhy set CPThresh_ 2  ;#10.0
+ Phy/UnderwaterPhy set CSThresh_ 0  ;#1.559e-11
+ Phy/UnderwaterPhy set RXThresh_ 0   ;#3.652e-10
+ #Phy/UnderwaterPhy set Rb_ 2*1e6
+ Phy/UnderwaterPhy set Pt_ 0.2818
+ Phy/UnderwaterPhy set freq_ 25  ;#frequency range in khz 
+ Phy/UnderwaterPhy set K_ 2.0   ;#spherical spreading
+ 
+ # ==================================================================
+ # Main Program
+ # =================================================================
+ 
+ #
+ # Initialize Global Variables
+ # 
+ #set sink_ 1
+ set ns_ [new Simulator]
+ set topo  [new Topography]
+ 
+ $topo load_cubicgrid $opt(x) $opt(y) $opt(z)
+ #$ns_ use-newtrace
+ set tracefd	[open $opt(tr) w]
+ $ns_ trace-all $tracefd
+ 
+ set nf [open $opt(nam) w]
+ $ns_ namtrace-all-wireless $nf $opt(x) $opt(y)
+ 
+ 
+ set total_number [expr $opt(nn)-1]
+ set god_ [create-god $opt(nn)]
+ 
+ set chan_1_ [new $opt(chan)]
+ 
+ 
+ 
+ $ns_ node-config -adhocRouting $opt(adhocRouting) \
+ 		 -llType $opt(ll) \
+ 		 -macType $opt(mac) \
+ 		 -ifqType $opt(ifq) \
+ 		 -ifqLen $opt(ifqlen) \
+ 		 -antType $opt(ant) \
+ 		 -propType $opt(prop) \
+ 		 -phyType $opt(netif) \
+ 		 -agentTrace ON \
+                  -routerTrace ON \
+                  -macTrace ON\
+                  -topoInstance $topo\
+                  -energyModel $opt(energy)\
+                  -txPower $opt(txpower)\
+                  -rxPower $opt(rxpower)\
+                  -initialEnergy $opt(initialenergy)\
+                  -idlePower $opt(idlepower)\
+                  -channel $chan_1_
+                  
+ set node_(0) [$ns_  node 0]
+ #puts "after create underwater sensor node\n"
+ $node_(0) set sinkStatus_ 1
+ $god_ new_node $node_(0)
+ $node_(0) set X_  0
+ $node_(0) set Y_  10
+ $node_(0) set Z_   0.0
+ $node_(0) set passive 1
+ set a_(0) [new Agent/UW_VBVA_Sink]
+ $ns_ attach-agent $node_(0) $a_(0)
+ $a_(0) attach-routing
+ $a_(0) cmd set-range 20
+ $a_(0) cmd set-target-x -20
+ $a_(0) cmd set-target-y -10
+ $a_(0) cmd set-target-z -20
+ $a_(0) cmd set-packetsize  40 ;# # of bytes  
+ 
+ 
+ 
+ set node_(1) [$ns_  node 1]
+ $node_(1) set sinkStatus_ 1
+ $god_ new_node $node_(1)
+ $node_(1) set X_  -10
+ $node_(1) set Y_  50
+ $node_(1) set Z_   0
+ $node_(1) set-cx  -10
+ $node_(1) set-cy  50
+ $node_(1) set-cz  0
+ #$node_(1) set passive 1
+ set a_(1) [new Agent/UW_VBVA_Sink]
+ $ns_ attach-agent $node_(1) $a_(1)
+ $a_(1) attach-routing
+  $a_(1) cmd set-range 20
+  $a_(1) cmd set-target-x   0
+  $a_(1) cmd set-target-y   0
+  $a_(1) cmd set-target-z   0
+  $a_(1) cmd set-packetsize  40 ;# # of bytes
+  $a_(1) set data_rate_ 4
+ 
+ 
+ 
+ 
+  set node_(2) [$ns_  node 2]
+  $node_(2) set sinkStatus_ 1
+  $god_ new_node $node_(2)
+  $node_(2) set X_    -10
+  $node_(2) set Y_    90
+  $node_(2) set Z_   0
+  $node_(2) set-cx   -10
+  $node_(2) set-cy   90
+  $node_(2) set-cz   0
+  set a_(2) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(2) $a_(2)
+  $a_(2) attach-routing
+  $a_(2) cmd set-range 20
+  $a_(2) cmd set-target-x   0
+  $a_(2) cmd set-target-y   0
+  $a_(2) cmd set-target-z   0
+  $a_(2) cmd set-packetsize  40 ;# 40 bytes
+  $a_(2) set data_rate_ 4
+ 
+ 
+ 
+ 
+  set node_(3) [$ns_  node 3]
+  $node_(3) set sinkStatus_ 1
+  $god_ new_node $node_(3)
+  $node_(3) set X_    20
+  $node_(3) set Y_    180
+  $node_(3) set Z_   0
+  $node_(3) set-cx   20
+  $node_(3) set-cy   180
+  $node_(3) set-cz   0
+  set a_(3) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(3) $a_(3)
+  $a_(3) attach-routing
+  $a_(3) cmd set-range 20
+  $a_(3) cmd set-target-x   0
+  $a_(3) cmd set-target-y   0
+  $a_(3) cmd set-target-z   0
+  $a_(3) cmd set-packetsize  40 ;# 40 bytes
+  $a_(3) set data_rate_ 4
+ 
+ 
+ 
+ 
+  set node_(4) [$ns_  node 4]
+  $node_(4) set sinkStatus_ 1
+  $god_ new_node $node_(4)
+  $node_(4) set X_    100
+  $node_(4) set Y_    210
+  $node_(4) set Z_   0
+  $node_(4) set-cx   100
+  $node_(4) set-cy   210
+  $node_(4) set-cz   0
+  set a_(4) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(4) $a_(4)
+  $a_(4) attach-routing
+  $a_(4) cmd set-range 20
+  $a_(4) cmd set-target-x   0
+  $a_(4) cmd set-target-y   0
+  $a_(4) cmd set-target-z   0
+  $a_(4) cmd set-packetsize  40 ;# 40 bytes
+  $a_(4) set data_rate_ 4
+ 
+ 
+  set node_(5) [$ns_  node 5]
+  $node_(5) set sinkStatus_ 1
+  $god_ new_node $node_(5)
+  $node_(5) set X_    150
+  $node_(5) set Y_    250
+  $node_(5) set Z_   0
+  $node_(5) set-cx   150
+  $node_(5) set-cy   250
+  $node_(5) set-cz   0
+  set a_(5) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(5) $a_(5)
+  $a_(5) attach-routing
+  $a_(5) cmd set-range 20
+  $a_(5) cmd set-target-x   0
+  $a_(5) cmd set-target-y   0
+  $a_(5) cmd set-target-z   0
+  $a_(5) cmd set-packetsize  40 ;# 40 bytes
+  $a_(5) set data_rate_ 4
+ 
+ 
+  set node_(6) [$ns_  node 6]
+  $node_(6) set sinkStatus_ 1
+  $god_ new_node $node_(6)
+  $node_(6) set X_    200
+  $node_(6) set Y_    200
+  $node_(6) set Z_   0
+  $node_(6) set-cx   200
+  $node_(6) set-cy   200
+  $node_(6) set-cz   0
+  set a_(6) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(6) $a_(6)
+  $a_(6) attach-routing
+  $a_(6) cmd set-range 20
+  $a_(6) cmd set-target-x   0
+  $a_(6) cmd set-target-y   0
+  $a_(6) cmd set-target-z   0
+  $a_(6) cmd set-packetsize  40 ;# 40 bytes
+  $a_(6) set data_rate_ 4
+ 
+ 
+  set node_(7) [$ns_  node 7]
+  $node_(7) set sinkStatus_ 1
+  $god_ new_node $node_(7)
+  $node_(7) set X_    200
+  $node_(7) set Y_    150
+  $node_(7) set Z_   0
+  $node_(7) set-cx   200
+  $node_(7) set-cy   150
+  $node_(7) set-cz   0
+  set a_(7) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(7) $a_(7)
+  $a_(7) attach-routing
+  $a_(7) cmd set-range 20
+  $a_(7) cmd set-target-x   0
+  $a_(7) cmd set-target-y   0
+  $a_(7) cmd set-target-z   0
+  $a_(7) cmd set-packetsize  40 ;# 40 bytes
+  $a_(7) set data_rate_ 4
+ 
+ 
+ 
+ 
+  set node_(8) [$ns_  node 8]
+  $node_(8) set sinkStatus_ 1
+  $god_ new_node $node_(8)
+  $node_(8) set X_    250
+  $node_(8) set Y_    50
+  $node_(8) set Z_   0
+  $node_(8) set-cx   250
+  $node_(8) set-cy   50
+  $node_(8) set-cz   0
+  set a_(8) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(8) $a_(8)
+  $a_(8) attach-routing
+  $a_(8) cmd set-range 20
+  $a_(8) cmd set-target-x   0
+  $a_(8) cmd set-target-y   0
+  $a_(8) cmd set-target-z   0
+  $a_(8) cmd set-packetsize  40 ;# 40 bytes
+  $a_(8) set data_rate_ 4
+ 
+ 
+ 
+ #dead path nodes
+  
+ set node_(9) [$ns_  node 9]
+  $node_(9) set sinkStatus_ 1
+  $god_ new_node $node_(9)
+  $node_(9) set X_    150
+  $node_(9) set Y_    80
+  $node_(9) set Z_   0
+  $node_(9) set-cx   150
+  $node_(9) set-cy   80
+  $node_(9) set-cz   0
+  set a_(9) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(9) $a_(9)
+  $a_(9) attach-routing
+  $a_(9) cmd set-range 20
+  $a_(9) cmd set-target-x   0
+  $a_(9) cmd set-target-y   0
+  $a_(9) cmd set-target-z   0
+  $a_(9) cmd set-packetsize  40 ;# 40 bytes
+  $a_(9) set data_rate_ 4
+ 
+ 
+ 
+ 
+  set node_(10) [$ns_  node 10]
+  $node_(10) set sinkStatus_ 1
+  $god_ new_node $node_(10)
+  $node_(10) set X_    100
+  $node_(10) set Y_    100
+  $node_(10) set Z_   0
+  $node_(10) set-cx   100
+  $node_(10) set-cy   100
+  $node_(10) set-cz   0
+  set a_(10) [new Agent/UW_VBVA_Sink]
+  $ns_ attach-agent $node_(10) $a_(10)
+  $a_(10) attach-routing
+  $a_(10) cmd set-range 20
+  $a_(10) cmd set-target-x   0
+  $a_(10) cmd set-target-y   0
+  $a_(10) cmd set-target-z   0
+  $a_(10) cmd set-packetsize  40 ;# 40 bytes
+  $a_(10) set data_rate_ 4
+ 
+ 
+ 
+ #puts "the total number is $total_number"
+ set node_($total_number) [$ns_  node $total_number]
+ $god_ new_node $node_($total_number)
+ $node_($total_number) set X_  200
+ $node_($total_number) set Y_  0
+ $node_($total_number) set Z_  0
+ $node_($total_number) set-cx  200
+ $node_($total_number) set-cy  0
+ $node_($total_number) set-cz  0
+ 
+ 
+ 
+ set a_($total_number) [new Agent/UW_VBVA_Sink]
+ $ns_ attach-agent $node_($total_number) $a_($total_number)
+ $a_($total_number) attach-routing
+  $a_($total_number) cmd set-range 100
+  $a_($total_number) cmd set-target-x 0
+ 
+  $a_($total_number) cmd set-target-y 0
+  $a_($total_number) cmd set-target-z 0
+  $a_($total_number) cmd set-packetsize  40 ;# 40 bytes
+ $a_($total_number) set data_rate_ 0.1;# #of packet per sec
+ 
+ 
+ # make nam workable
+ set node_size 10
+ for {set k 0} { $k<$opt(nn)} {incr k} {
+ $ns_ initial_node_pos $node_($k) $node_size
+ }
+ 
+ 
+ $ns_ at 2 "$a_($total_number) cbr-start"
+ 
+ 
+ 
+ puts "+++++++AFTER ANNOUNCE++++++++++++++"
+ 
+ 
+ $ns_ at $opt(stop).001 "$a_(0) terminate"
+ $ns_ at $opt(prestop).002 "$a_($total_number) stop"
+ $ns_ at $opt(stop).002 "$a_($total_number) terminate"
+ 
+ 
+ $ns_ at $opt(stop).003  "$god_ compute_energy"
+ $ns_ at $opt(stop).004  "$ns_ nam-end-wireless $opt(stop)"
+ $ns_ at $opt(stop).005 "puts \"NS EXISTING...\"; $ns_ halt"
+ 
+  puts $tracefd "vectorbased"
+  puts $tracefd "M 0.0 nn $opt(nn) x $opt(x) y $opt(y) z $opt(z)"
+  puts $tracefd "M 0.0 prop $opt(prop) ant $opt(ant)"
+  puts "starting Simulation..."
+  $ns_ run
